(function(){const a=document.createElement("link").relList;if(a&&a.supports&&a.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const t of r.addedNodes)t.tagName==="LINK"&&t.rel==="modulepreload"&&s(t)}).observe(document,{childList:!0,subtree:!0});function o(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=o(i);fetch(i.href,r)}})();function is(e){const a=Object.create(null);for(const o of e.split(","))a[o]=1;return o=>o in a}const H={},ha=[],we=()=>{},ui=()=>!1,vo=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),rs=e=>e.startsWith("onUpdate:"),ne=Object.assign,ts=(e,a)=>{const o=e.indexOf(a);o>-1&&e.splice(o,1)},Mr=Object.prototype.hasOwnProperty,F=(e,a)=>Mr.call(e,a),z=Array.isArray,ba=e=>ho(e)==="[object Map]",mi=e=>ho(e)==="[object Set]",T=e=>typeof e=="function",ae=e=>typeof e=="string",aa=e=>typeof e=="symbol",Z=e=>e!==null&&typeof e=="object",pi=e=>(Z(e)||T(e))&&T(e.then)&&T(e.catch),fi=Object.prototype.toString,ho=e=>fi.call(e),Pr=e=>ho(e).slice(8,-1),gi=e=>ho(e)==="[object Object]",ns=e=>ae(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,za=is(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),bo=e=>{const a=Object.create(null);return(o=>a[o]||(a[o]=e(o)))},qr=/-\w/g,Pe=bo(e=>e.replace(qr,a=>a.slice(1).toUpperCase())),zr=/\B([A-Z])/g,pa=bo(e=>e.replace(zr,"-$1").toLowerCase()),Ao=bo(e=>e.charAt(0).toUpperCase()+e.slice(1)),zo=bo(e=>e?`on${Ao(e)}`:""),ca=(e,a)=>!Object.is(e,a),Ya=(e,...a)=>{for(let o=0;o<e.length;o++)e[o](...a)},vi=(e,a,o,s=!1)=>{Object.defineProperty(e,a,{configurable:!0,enumerable:!1,writable:s,value:o})},Vo=e=>{const a=parseFloat(e);return isNaN(a)?e:a},xr=e=>{const a=ae(e)?Number(e):NaN;return isNaN(a)?e:a};let Ps;const Co=()=>Ps||(Ps=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function ds(e){if(z(e)){const a={};for(let o=0;o<e.length;o++){const s=e[o],i=ae(s)?Lr(s):ds(s);if(i)for(const r in i)a[r]=i[r]}return a}else if(ae(e)||Z(e))return e}const Nr=/;(?![^(]*\))/g,Tr=/:([^]+)/,Rr=/\/\*[^]*?\*\//g;function Lr(e){const a={};return e.replace(Rr,"").split(Nr).forEach(o=>{if(o){const s=o.split(Tr);s.length>1&&(a[s[0].trim()]=s[1].trim())}}),a}function Eo(e){let a="";if(ae(e))a=e;else if(z(e))for(let o=0;o<e.length;o++){const s=Eo(e[o]);s&&(a+=s+" ")}else if(Z(e))for(const o in e)e[o]&&(a+=o+" ");return a.trim()}const yr="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",jr=is(yr);function hi(e){return!!e||e===""}const bi=e=>!!(e&&e.__v_isRef===!0),le=e=>ae(e)?e:e==null?"":z(e)||Z(e)&&(e.toString===fi||!T(e.toString))?bi(e)?le(e.value):JSON.stringify(e,Ai,2):String(e),Ai=(e,a)=>bi(a)?Ai(e,a.value):ba(a)?{[`Map(${a.size})`]:[...a.entries()].reduce((o,[s,i],r)=>(o[xo(s,r)+" =>"]=i,o),{})}:mi(a)?{[`Set(${a.size})`]:[...a.values()].map(o=>xo(o))}:aa(a)?xo(a):Z(a)&&!z(a)&&!gi(a)?String(a):a,xo=(e,a="")=>{var o;return aa(e)?`Symbol(${(o=e.description)!=null?o:a})`:e};let Ee;class Br{constructor(a=!1){this.detached=a,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=Ee,!a&&Ee&&(this.index=(Ee.scopes||(Ee.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let a,o;if(this.scopes)for(a=0,o=this.scopes.length;a<o;a++)this.scopes[a].pause();for(a=0,o=this.effects.length;a<o;a++)this.effects[a].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let a,o;if(this.scopes)for(a=0,o=this.scopes.length;a<o;a++)this.scopes[a].resume();for(a=0,o=this.effects.length;a<o;a++)this.effects[a].resume()}}run(a){if(this._active){const o=Ee;try{return Ee=this,a()}finally{Ee=o}}}on(){++this._on===1&&(this.prevScope=Ee,Ee=this)}off(){this._on>0&&--this._on===0&&(Ee=this.prevScope,this.prevScope=void 0)}stop(a){if(this._active){this._active=!1;let o,s;for(o=0,s=this.effects.length;o<s;o++)this.effects[o].stop();for(this.effects.length=0,o=0,s=this.cleanups.length;o<s;o++)this.cleanups[o]();if(this.cleanups.length=0,this.scopes){for(o=0,s=this.scopes.length;o<s;o++)this.scopes[o].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!a){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0}}}function wr(){return Ee}let W;const No=new WeakSet;class Ci{constructor(a){this.fn=a,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,Ee&&Ee.active&&Ee.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,No.has(this)&&(No.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Di(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,qs(this),_i(this);const a=W,o=qe;W=this,qe=!0;try{return this.fn()}finally{Si(this),W=a,qe=o,this.flags&=-3}}stop(){if(this.flags&1){for(let a=this.deps;a;a=a.nextDep)us(a);this.deps=this.depsTail=void 0,qs(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?No.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Ho(this)&&this.run()}get dirty(){return Ho(this)}}let Ei=0,xa,Na;function Di(e,a=!1){if(e.flags|=8,a){e.next=Na,Na=e;return}e.next=xa,xa=e}function ls(){Ei++}function cs(){if(--Ei>0)return;if(Na){let a=Na;for(Na=void 0;a;){const o=a.next;a.next=void 0,a.flags&=-9,a=o}}let e;for(;xa;){let a=xa;for(xa=void 0;a;){const o=a.next;if(a.next=void 0,a.flags&=-9,a.flags&1)try{a.trigger()}catch(s){e||(e=s)}a=o}}if(e)throw e}function _i(e){for(let a=e.deps;a;a=a.nextDep)a.version=-1,a.prevActiveLink=a.dep.activeLink,a.dep.activeLink=a}function Si(e){let a,o=e.depsTail,s=o;for(;s;){const i=s.prevDep;s.version===-1?(s===o&&(o=i),us(s),Fr(s)):a=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=i}e.deps=a,e.depsTail=o}function Ho(e){for(let a=e.deps;a;a=a.nextDep)if(a.dep.version!==a.version||a.dep.computed&&(Oi(a.dep.computed)||a.dep.version!==a.version))return!0;return!!e._dirty}function Oi(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===ja)||(e.globalVersion=ja,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Ho(e))))return;e.flags|=2;const a=e.dep,o=W,s=qe;W=e,qe=!0;try{_i(e);const i=e.fn(e._value);(a.version===0||ca(i,e._value))&&(e.flags|=128,e._value=i,a.version++)}catch(i){throw a.version++,i}finally{W=o,qe=s,Si(e),e.flags&=-3}}function us(e,a=!1){const{dep:o,prevSub:s,nextSub:i}=e;if(s&&(s.nextSub=i,e.prevSub=void 0),i&&(i.prevSub=s,e.nextSub=void 0),o.subs===e&&(o.subs=s,!s&&o.computed)){o.computed.flags&=-5;for(let r=o.computed.deps;r;r=r.nextDep)us(r,!0)}!a&&!--o.sc&&o.map&&o.map.delete(o.key)}function Fr(e){const{prevDep:a,nextDep:o}=e;a&&(a.nextDep=o,e.prevDep=void 0),o&&(o.prevDep=a,e.nextDep=void 0)}let qe=!0;const Ii=[];function $e(){Ii.push(qe),qe=!1}function Je(){const e=Ii.pop();qe=e===void 0?!0:e}function qs(e){const{cleanup:a}=e;if(e.cleanup=void 0,a){const o=W;W=void 0;try{a()}finally{W=o}}}let ja=0;class kr{constructor(a,o){this.sub=a,this.dep=o,this.version=o.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Mi{constructor(a){this.computed=a,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(a){if(!W||!qe||W===this.computed)return;let o=this.activeLink;if(o===void 0||o.sub!==W)o=this.activeLink=new kr(W,this),W.deps?(o.prevDep=W.depsTail,W.depsTail.nextDep=o,W.depsTail=o):W.deps=W.depsTail=o,Pi(o);else if(o.version===-1&&(o.version=this.version,o.nextDep)){const s=o.nextDep;s.prevDep=o.prevDep,o.prevDep&&(o.prevDep.nextDep=s),o.prevDep=W.depsTail,o.nextDep=void 0,W.depsTail.nextDep=o,W.depsTail=o,W.deps===o&&(W.deps=s)}return o}trigger(a){this.version++,ja++,this.notify(a)}notify(a){ls();try{for(let o=this.subs;o;o=o.prevSub)o.sub.notify()&&o.sub.dep.notify()}finally{cs()}}}function Pi(e){if(e.dep.sc++,e.sub.flags&4){const a=e.dep.computed;if(a&&!e.dep.subs){a.flags|=20;for(let s=a.deps;s;s=s.nextDep)Pi(s)}const o=e.dep.subs;o!==e&&(e.prevSub=o,o&&(o.nextSub=e)),e.dep.subs=e}}const Ko=new WeakMap,ua=Symbol(""),$o=Symbol(""),Ba=Symbol("");function ce(e,a,o){if(qe&&W){let s=Ko.get(e);s||Ko.set(e,s=new Map);let i=s.get(o);i||(s.set(o,i=new Mi),i.map=s,i.key=o),i.track()}}function He(e,a,o,s,i,r){const t=Ko.get(e);if(!t){ja++;return}const n=l=>{l&&l.trigger()};if(ls(),a==="clear")t.forEach(n);else{const l=z(e),m=l&&ns(o);if(l&&o==="length"){const c=Number(s);t.forEach((f,C)=>{(C==="length"||C===Ba||!aa(C)&&C>=c)&&n(f)})}else switch((o!==void 0||t.has(void 0))&&n(t.get(o)),m&&n(t.get(Ba)),a){case"add":l?m&&n(t.get("length")):(n(t.get(ua)),ba(e)&&n(t.get($o)));break;case"delete":l||(n(t.get(ua)),ba(e)&&n(t.get($o)));break;case"set":ba(e)&&n(t.get(ua));break}}cs()}function fa(e){const a=G(e);return a===e?a:(ce(a,"iterate",Ba),ze(e)?a:a.map(fe))}function Do(e){return ce(e=G(e),"iterate",Ba),e}const Gr={__proto__:null,[Symbol.iterator](){return To(this,Symbol.iterator,fe)},concat(...e){return fa(this).concat(...e.map(a=>z(a)?fa(a):a))},entries(){return To(this,"entries",e=>(e[1]=fe(e[1]),e))},every(e,a){return ke(this,"every",e,a,void 0,arguments)},filter(e,a){return ke(this,"filter",e,a,o=>o.map(fe),arguments)},find(e,a){return ke(this,"find",e,a,fe,arguments)},findIndex(e,a){return ke(this,"findIndex",e,a,void 0,arguments)},findLast(e,a){return ke(this,"findLast",e,a,fe,arguments)},findLastIndex(e,a){return ke(this,"findLastIndex",e,a,void 0,arguments)},forEach(e,a){return ke(this,"forEach",e,a,void 0,arguments)},includes(...e){return Ro(this,"includes",e)},indexOf(...e){return Ro(this,"indexOf",e)},join(e){return fa(this).join(e)},lastIndexOf(...e){return Ro(this,"lastIndexOf",e)},map(e,a){return ke(this,"map",e,a,void 0,arguments)},pop(){return Oa(this,"pop")},push(...e){return Oa(this,"push",e)},reduce(e,...a){return zs(this,"reduce",e,a)},reduceRight(e,...a){return zs(this,"reduceRight",e,a)},shift(){return Oa(this,"shift")},some(e,a){return ke(this,"some",e,a,void 0,arguments)},splice(...e){return Oa(this,"splice",e)},toReversed(){return fa(this).toReversed()},toSorted(e){return fa(this).toSorted(e)},toSpliced(...e){return fa(this).toSpliced(...e)},unshift(...e){return Oa(this,"unshift",e)},values(){return To(this,"values",fe)}};function To(e,a,o){const s=Do(e),i=s[a]();return s!==e&&!ze(e)&&(i._next=i.next,i.next=()=>{const r=i._next();return r.done||(r.value=o(r.value)),r}),i}const Ur=Array.prototype;function ke(e,a,o,s,i,r){const t=Do(e),n=t!==e&&!ze(e),l=t[a];if(l!==Ur[a]){const f=l.apply(e,r);return n?fe(f):f}let m=o;t!==e&&(n?m=function(f,C){return o.call(this,fe(f),C,e)}:o.length>2&&(m=function(f,C){return o.call(this,f,C,e)}));const c=l.call(t,m,s);return n&&i?i(c):c}function zs(e,a,o,s){const i=Do(e);let r=o;return i!==e&&(ze(e)?o.length>3&&(r=function(t,n,l){return o.call(this,t,n,l,e)}):r=function(t,n,l){return o.call(this,t,fe(n),l,e)}),i[a](r,...s)}function Ro(e,a,o){const s=G(e);ce(s,"iterate",Ba);const i=s[a](...o);return(i===-1||i===!1)&&gs(o[0])?(o[0]=G(o[0]),s[a](...o)):i}function Oa(e,a,o=[]){$e(),ls();const s=G(e)[a].apply(e,o);return cs(),Je(),s}const Vr=is("__proto__,__v_isRef,__isVue"),qi=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(aa));function Hr(e){aa(e)||(e=String(e));const a=G(this);return ce(a,"has",e),a.hasOwnProperty(e)}class zi{constructor(a=!1,o=!1){this._isReadonly=a,this._isShallow=o}get(a,o,s){if(o==="__v_skip")return a.__v_skip;const i=this._isReadonly,r=this._isShallow;if(o==="__v_isReactive")return!i;if(o==="__v_isReadonly")return i;if(o==="__v_isShallow")return r;if(o==="__v_raw")return s===(i?r?at:Ri:r?Ti:Ni).get(a)||Object.getPrototypeOf(a)===Object.getPrototypeOf(s)?a:void 0;const t=z(a);if(!i){let l;if(t&&(l=Gr[o]))return l;if(o==="hasOwnProperty")return Hr}const n=Reflect.get(a,o,he(a)?a:s);if((aa(o)?qi.has(o):Vr(o))||(i||ce(a,"get",o),r))return n;if(he(n)){const l=t&&ns(o)?n:n.value;return i&&Z(l)?Wo(l):l}return Z(n)?i?Wo(n):ps(n):n}}class xi extends zi{constructor(a=!1){super(!1,a)}set(a,o,s,i){let r=a[o];if(!this._isShallow){const l=ma(r);if(!ze(s)&&!ma(s)&&(r=G(r),s=G(s)),!z(a)&&he(r)&&!he(s))return l||(r.value=s),!0}const t=z(a)&&ns(o)?Number(o)<a.length:F(a,o),n=Reflect.set(a,o,s,he(a)?a:i);return a===G(i)&&(t?ca(s,r)&&He(a,"set",o,s):He(a,"add",o,s)),n}deleteProperty(a,o){const s=F(a,o);a[o];const i=Reflect.deleteProperty(a,o);return i&&s&&He(a,"delete",o,void 0),i}has(a,o){const s=Reflect.has(a,o);return(!aa(o)||!qi.has(o))&&ce(a,"has",o),s}ownKeys(a){return ce(a,"iterate",z(a)?"length":ua),Reflect.ownKeys(a)}}class Kr extends zi{constructor(a=!1){super(!0,a)}set(a,o){return!0}deleteProperty(a,o){return!0}}const $r=new xi,Jr=new Kr,Wr=new xi(!0);const Jo=e=>e,Wa=e=>Reflect.getPrototypeOf(e);function Zr(e,a,o){return function(...s){const i=this.__v_raw,r=G(i),t=ba(r),n=e==="entries"||e===Symbol.iterator&&t,l=e==="keys"&&t,m=i[e](...s),c=o?Jo:a?io:fe;return!a&&ce(r,"iterate",l?$o:ua),{next(){const{value:f,done:C}=m.next();return C?{value:f,done:C}:{value:n?[c(f[0]),c(f[1])]:c(f),done:C}},[Symbol.iterator](){return this}}}}function Za(e){return function(...a){return e==="delete"?!1:e==="clear"?void 0:this}}function Xr(e,a){const o={get(i){const r=this.__v_raw,t=G(r),n=G(i);e||(ca(i,n)&&ce(t,"get",i),ce(t,"get",n));const{has:l}=Wa(t),m=a?Jo:e?io:fe;if(l.call(t,i))return m(r.get(i));if(l.call(t,n))return m(r.get(n));r!==t&&r.get(i)},get size(){const i=this.__v_raw;return!e&&ce(G(i),"iterate",ua),i.size},has(i){const r=this.__v_raw,t=G(r),n=G(i);return e||(ca(i,n)&&ce(t,"has",i),ce(t,"has",n)),i===n?r.has(i):r.has(i)||r.has(n)},forEach(i,r){const t=this,n=t.__v_raw,l=G(n),m=a?Jo:e?io:fe;return!e&&ce(l,"iterate",ua),n.forEach((c,f)=>i.call(r,m(c),m(f),t))}};return ne(o,e?{add:Za("add"),set:Za("set"),delete:Za("delete"),clear:Za("clear")}:{add(i){!a&&!ze(i)&&!ma(i)&&(i=G(i));const r=G(this);return Wa(r).has.call(r,i)||(r.add(i),He(r,"add",i,i)),this},set(i,r){!a&&!ze(r)&&!ma(r)&&(r=G(r));const t=G(this),{has:n,get:l}=Wa(t);let m=n.call(t,i);m||(i=G(i),m=n.call(t,i));const c=l.call(t,i);return t.set(i,r),m?ca(r,c)&&He(t,"set",i,r):He(t,"add",i,r),this},delete(i){const r=G(this),{has:t,get:n}=Wa(r);let l=t.call(r,i);l||(i=G(i),l=t.call(r,i)),n&&n.call(r,i);const m=r.delete(i);return l&&He(r,"delete",i,void 0),m},clear(){const i=G(this),r=i.size!==0,t=i.clear();return r&&He(i,"clear",void 0,void 0),t}}),["keys","values","entries",Symbol.iterator].forEach(i=>{o[i]=Zr(i,e,a)}),o}function ms(e,a){const o=Xr(e,a);return(s,i,r)=>i==="__v_isReactive"?!e:i==="__v_isReadonly"?e:i==="__v_raw"?s:Reflect.get(F(o,i)&&i in s?o:s,i,r)}const Qr={get:ms(!1,!1)},Yr={get:ms(!1,!0)},et={get:ms(!0,!1)};const Ni=new WeakMap,Ti=new WeakMap,Ri=new WeakMap,at=new WeakMap;function ot(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function st(e){return e.__v_skip||!Object.isExtensible(e)?0:ot(Pr(e))}function ps(e){return ma(e)?e:fs(e,!1,$r,Qr,Ni)}function it(e){return fs(e,!1,Wr,Yr,Ti)}function Wo(e){return fs(e,!0,Jr,et,Ri)}function fs(e,a,o,s,i){if(!Z(e)||e.__v_raw&&!(a&&e.__v_isReactive))return e;const r=st(e);if(r===0)return e;const t=i.get(e);if(t)return t;const n=new Proxy(e,r===2?s:o);return i.set(e,n),n}function Aa(e){return ma(e)?Aa(e.__v_raw):!!(e&&e.__v_isReactive)}function ma(e){return!!(e&&e.__v_isReadonly)}function ze(e){return!!(e&&e.__v_isShallow)}function gs(e){return e?!!e.__v_raw:!1}function G(e){const a=e&&e.__v_raw;return a?G(a):e}function rt(e){return!F(e,"__v_skip")&&Object.isExtensible(e)&&vi(e,"__v_skip",!0),e}const fe=e=>Z(e)?ps(e):e,io=e=>Z(e)?Wo(e):e;function he(e){return e?e.__v_isRef===!0:!1}function tt(e){return he(e)?e.value:e}const nt={get:(e,a,o)=>a==="__v_raw"?e:tt(Reflect.get(e,a,o)),set:(e,a,o,s)=>{const i=e[a];return he(i)&&!he(o)?(i.value=o,!0):Reflect.set(e,a,o,s)}};function Li(e){return Aa(e)?e:new Proxy(e,nt)}class dt{constructor(a,o,s){this.fn=a,this.setter=o,this._value=void 0,this.dep=new Mi(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=ja-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!o,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&W!==this)return Di(this,!0),!0}get value(){const a=this.dep.track();return Oi(this),a&&(a.version=this.dep.version),this._value}set value(a){this.setter&&this.setter(a)}}function lt(e,a,o=!1){let s,i;return T(e)?s=e:(s=e.get,i=e.set),new dt(s,i,o)}const Xa={},ro=new WeakMap;let da;function ct(e,a=!1,o=da){if(o){let s=ro.get(o);s||ro.set(o,s=[]),s.push(e)}}function ut(e,a,o=H){const{immediate:s,deep:i,once:r,scheduler:t,augmentJob:n,call:l}=o,m=P=>i?P:ze(P)||i===!1||i===0?Ke(P,1):Ke(P);let c,f,C,S,x=!1,R=!1;if(he(e)?(f=()=>e.value,x=ze(e)):Aa(e)?(f=()=>m(e),x=!0):z(e)?(R=!0,x=e.some(P=>Aa(P)||ze(P)),f=()=>e.map(P=>{if(he(P))return P.value;if(Aa(P))return m(P);if(T(P))return l?l(P,2):P()})):T(e)?a?f=l?()=>l(e,2):e:f=()=>{if(C){$e();try{C()}finally{Je()}}const P=da;da=c;try{return l?l(e,3,[S]):e(S)}finally{da=P}}:f=we,a&&i){const P=f,K=i===!0?1/0:i;f=()=>Ke(P(),K)}const oe=wr(),y=()=>{c.stop(),oe&&oe.active&&ts(oe.effects,c)};if(r&&a){const P=a;a=(...K)=>{P(...K),y()}}let w=R?new Array(e.length).fill(Xa):Xa;const V=P=>{if(!(!(c.flags&1)||!c.dirty&&!P))if(a){const K=c.run();if(i||x||(R?K.some((ie,me)=>ca(ie,w[me])):ca(K,w))){C&&C();const ie=da;da=c;try{const me=[K,w===Xa?void 0:R&&w[0]===Xa?[]:w,S];w=K,l?l(a,3,me):a(...me)}finally{da=ie}}}else c.run()};return n&&n(V),c=new Ci(f),c.scheduler=t?()=>t(V,!1):V,S=P=>ct(P,!1,c),C=c.onStop=()=>{const P=ro.get(c);if(P){if(l)l(P,4);else for(const K of P)K();ro.delete(c)}},a?s?V(!0):w=c.run():t?t(V.bind(null,!0),!0):c.run(),y.pause=c.pause.bind(c),y.resume=c.resume.bind(c),y.stop=y,y}function Ke(e,a=1/0,o){if(a<=0||!Z(e)||e.__v_skip||(o=o||new Map,(o.get(e)||0)>=a))return e;if(o.set(e,a),a--,he(e))Ke(e.value,a,o);else if(z(e))for(let s=0;s<e.length;s++)Ke(e[s],a,o);else if(mi(e)||ba(e))e.forEach(s=>{Ke(s,a,o)});else if(gi(e)){for(const s in e)Ke(e[s],a,o);for(const s of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,s)&&Ke(e[s],a,o)}return e}function Va(e,a,o,s){try{return s?e(...s):e()}catch(i){_o(i,a,o)}}function xe(e,a,o,s){if(T(e)){const i=Va(e,a,o,s);return i&&pi(i)&&i.catch(r=>{_o(r,a,o)}),i}if(z(e)){const i=[];for(let r=0;r<e.length;r++)i.push(xe(e[r],a,o,s));return i}}function _o(e,a,o,s=!0){const i=a?a.vnode:null,{errorHandler:r,throwUnhandledErrorInProduction:t}=a&&a.appContext.config||H;if(a){let n=a.parent;const l=a.proxy,m=`https://vuejs.org/error-reference/#runtime-${o}`;for(;n;){const c=n.ec;if(c){for(let f=0;f<c.length;f++)if(c[f](e,l,m)===!1)return}n=n.parent}if(r){$e(),Va(r,null,10,[e,l,m]),Je();return}}mt(e,o,i,s,t)}function mt(e,a,o,s=!0,i=!1){if(i)throw e;console.error(e)}const ge=[];let je=-1;const Ca=[];let Xe=null,ga=0;const yi=Promise.resolve();let to=null;function pt(e){const a=to||yi;return e?a.then(this?e.bind(this):e):a}function ft(e){let a=je+1,o=ge.length;for(;a<o;){const s=a+o>>>1,i=ge[s],r=wa(i);r<e||r===e&&i.flags&2?a=s+1:o=s}return a}function vs(e){if(!(e.flags&1)){const a=wa(e),o=ge[ge.length-1];!o||!(e.flags&2)&&a>=wa(o)?ge.push(e):ge.splice(ft(a),0,e),e.flags|=1,ji()}}function ji(){to||(to=yi.then(wi))}function gt(e){z(e)?Ca.push(...e):Xe&&e.id===-1?Xe.splice(ga+1,0,e):e.flags&1||(Ca.push(e),e.flags|=1),ji()}function xs(e,a,o=je+1){for(;o<ge.length;o++){const s=ge[o];if(s&&s.flags&2){if(e&&s.id!==e.uid)continue;ge.splice(o,1),o--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function Bi(e){if(Ca.length){const a=[...new Set(Ca)].sort((o,s)=>wa(o)-wa(s));if(Ca.length=0,Xe){Xe.push(...a);return}for(Xe=a,ga=0;ga<Xe.length;ga++){const o=Xe[ga];o.flags&4&&(o.flags&=-2),o.flags&8||o(),o.flags&=-2}Xe=null,ga=0}}const wa=e=>e.id==null?e.flags&2?-1:1/0:e.id;function wi(e){try{for(je=0;je<ge.length;je++){const a=ge[je];a&&!(a.flags&8)&&(a.flags&4&&(a.flags&=-2),Va(a,a.i,a.i?15:14),a.flags&4||(a.flags&=-2))}}finally{for(;je<ge.length;je++){const a=ge[je];a&&(a.flags&=-2)}je=-1,ge.length=0,Bi(),to=null,(ge.length||Ca.length)&&wi()}}let Oe=null,Fi=null;function no(e){const a=Oe;return Oe=e,Fi=e&&e.type.__scopeId||null,a}function ki(e,a=Oe,o){if(!a||e._n)return e;const s=(...i)=>{s._d&&mo(-1);const r=no(a);let t;try{t=e(...i)}finally{no(r),s._d&&mo(1)}return t};return s._n=!0,s._c=!0,s._d=!0,s}function Gi(e,a){if(Oe===null)return e;const o=Po(Oe),s=e.dirs||(e.dirs=[]);for(let i=0;i<a.length;i++){let[r,t,n,l=H]=a[i];r&&(T(r)&&(r={mounted:r,updated:r}),r.deep&&Ke(t),s.push({dir:r,instance:o,value:t,oldValue:void 0,arg:n,modifiers:l}))}return e}function ia(e,a,o,s){const i=e.dirs,r=a&&a.dirs;for(let t=0;t<i.length;t++){const n=i[t];r&&(n.oldValue=r[t].value);let l=n.dir[s];l&&($e(),xe(l,o,8,[e.el,n,e,a]),Je())}}const vt=Symbol("_vte"),Ui=e=>e.__isTeleport,Ve=Symbol("_leaveCb"),Qa=Symbol("_enterCb");function ht(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return Xi(()=>{e.isMounted=!0}),Qi(()=>{e.isUnmounting=!0}),e}const Me=[Function,Array],Vi={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Me,onEnter:Me,onAfterEnter:Me,onEnterCancelled:Me,onBeforeLeave:Me,onLeave:Me,onAfterLeave:Me,onLeaveCancelled:Me,onBeforeAppear:Me,onAppear:Me,onAfterAppear:Me,onAppearCancelled:Me},Hi=e=>{const a=e.subTree;return a.component?Hi(a.component):a},bt={name:"BaseTransition",props:Vi,setup(e,{slots:a}){const o=Ar(),s=ht();return()=>{const i=a.default&&Ji(a.default(),!0);if(!i||!i.length)return;const r=Ki(i),t=G(e),{mode:n}=t;if(s.isLeaving)return Lo(r);const l=Ns(r);if(!l)return Lo(r);let m=Zo(l,t,s,o,f=>m=f);l.type!==ve&&Fa(l,m);let c=o.subTree&&Ns(o.subTree);if(c&&c.type!==ve&&!la(c,l)&&Hi(o).type!==ve){let f=Zo(c,t,s,o);if(Fa(c,f),n==="out-in"&&l.type!==ve)return s.isLeaving=!0,f.afterLeave=()=>{s.isLeaving=!1,o.job.flags&8||o.update(),delete f.afterLeave,c=void 0},Lo(r);n==="in-out"&&l.type!==ve?f.delayLeave=(C,S,x)=>{const R=$i(s,c);R[String(c.key)]=c,C[Ve]=()=>{S(),C[Ve]=void 0,delete m.delayedLeave,c=void 0},m.delayedLeave=()=>{x(),delete m.delayedLeave,c=void 0}}:c=void 0}else c&&(c=void 0);return r}}};function Ki(e){let a=e[0];if(e.length>1){for(const o of e)if(o.type!==ve){a=o;break}}return a}const At=bt;function $i(e,a){const{leavingVNodes:o}=e;let s=o.get(a.type);return s||(s=Object.create(null),o.set(a.type,s)),s}function Zo(e,a,o,s,i){const{appear:r,mode:t,persisted:n=!1,onBeforeEnter:l,onEnter:m,onAfterEnter:c,onEnterCancelled:f,onBeforeLeave:C,onLeave:S,onAfterLeave:x,onLeaveCancelled:R,onBeforeAppear:oe,onAppear:y,onAfterAppear:w,onAppearCancelled:V}=a,P=String(e.key),K=$i(o,e),ie=(L,U)=>{L&&xe(L,s,9,U)},me=(L,U)=>{const Q=U[1];ie(L,U),z(L)?L.every(I=>I.length<=1)&&Q():L.length<=1&&Q()},be={mode:t,persisted:n,beforeEnter(L){let U=l;if(!o.isMounted)if(r)U=oe||l;else return;L[Ve]&&L[Ve](!0);const Q=K[P];Q&&la(e,Q)&&Q.el[Ve]&&Q.el[Ve](),ie(U,[L])},enter(L){let U=m,Q=c,I=f;if(!o.isMounted)if(r)U=y||m,Q=w||c,I=V||f;else return;let X=!1;const de=L[Qa]=Fe=>{X||(X=!0,Fe?ie(I,[L]):ie(Q,[L]),be.delayedLeave&&be.delayedLeave(),L[Qa]=void 0)};U?me(U,[L,de]):de()},leave(L,U){const Q=String(e.key);if(L[Qa]&&L[Qa](!0),o.isUnmounting)return U();ie(C,[L]);let I=!1;const X=L[Ve]=de=>{I||(I=!0,U(),de?ie(R,[L]):ie(x,[L]),L[Ve]=void 0,K[Q]===e&&delete K[Q])};K[Q]=e,S?me(S,[L,X]):X()},clone(L){const U=Zo(L,a,o,s,i);return i&&i(U),U}};return be}function Lo(e){if(So(e))return e=ea(e),e.children=null,e}function Ns(e){if(!So(e))return Ui(e.type)&&e.children?Ki(e.children):e;if(e.component)return e.component.subTree;const{shapeFlag:a,children:o}=e;if(o){if(a&16)return o[0];if(a&32&&T(o.default))return o.default()}}function Fa(e,a){e.shapeFlag&6&&e.component?(e.transition=a,Fa(e.component.subTree,a)):e.shapeFlag&128?(e.ssContent.transition=a.clone(e.ssContent),e.ssFallback.transition=a.clone(e.ssFallback)):e.transition=a}function Ji(e,a=!1,o){let s=[],i=0;for(let r=0;r<e.length;r++){let t=e[r];const n=o==null?t.key:String(o)+String(t.key!=null?t.key:r);t.type===Se?(t.patchFlag&128&&i++,s=s.concat(Ji(t.children,a,n))):(a||t.type!==ve)&&s.push(n!=null?ea(t,{key:n}):t)}if(i>1)for(let r=0;r<s.length;r++)s[r].patchFlag=-2;return s}function Wi(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}const lo=new WeakMap;function Ta(e,a,o,s,i=!1){if(z(e)){e.forEach((x,R)=>Ta(x,a&&(z(a)?a[R]:a),o,s,i));return}if(Ra(s)&&!i){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&Ta(e,a,o,s.component.subTree);return}const r=s.shapeFlag&4?Po(s.component):s.el,t=i?null:r,{i:n,r:l}=e,m=a&&a.r,c=n.refs===H?n.refs={}:n.refs,f=n.setupState,C=G(f),S=f===H?ui:x=>F(C,x);if(m!=null&&m!==l){if(Ts(a),ae(m))c[m]=null,S(m)&&(f[m]=null);else if(he(m)){m.value=null;const x=a;x.k&&(c[x.k]=null)}}if(T(l))Va(l,n,12,[t,c]);else{const x=ae(l),R=he(l);if(x||R){const oe=()=>{if(e.f){const y=x?S(l)?f[l]:c[l]:l.value;if(i)z(y)&&ts(y,r);else if(z(y))y.includes(r)||y.push(r);else if(x)c[l]=[r],S(l)&&(f[l]=c[l]);else{const w=[r];l.value=w,e.k&&(c[e.k]=w)}}else x?(c[l]=t,S(l)&&(f[l]=t)):R&&(l.value=t,e.k&&(c[e.k]=t))};if(t){const y=()=>{oe(),lo.delete(e)};y.id=-1,lo.set(e,y),_e(y,o)}else Ts(e),oe()}}}function Ts(e){const a=lo.get(e);a&&(a.flags|=8,lo.delete(e))}Co().requestIdleCallback;Co().cancelIdleCallback;const Ra=e=>!!e.type.__asyncLoader,So=e=>e.type.__isKeepAlive;function Ct(e,a){Zi(e,"a",a)}function Et(e,a){Zi(e,"da",a)}function Zi(e,a,o=ue){const s=e.__wdc||(e.__wdc=()=>{let i=o;for(;i;){if(i.isDeactivated)return;i=i.parent}return e()});if(Oo(a,s,o),o){let i=o.parent;for(;i&&i.parent;)So(i.parent.vnode)&&Dt(s,a,o,i),i=i.parent}}function Dt(e,a,o,s){const i=Oo(a,e,s,!0);Yi(()=>{ts(s[a],i)},o)}function Oo(e,a,o=ue,s=!1){if(o){const i=o[e]||(o[e]=[]),r=a.__weh||(a.__weh=(...t)=>{$e();const n=Ha(o),l=xe(a,o,e,t);return n(),Je(),l});return s?i.unshift(r):i.push(r),r}}const We=e=>(a,o=ue)=>{(!Ga||e==="sp")&&Oo(e,(...s)=>a(...s),o)},_t=We("bm"),Xi=We("m"),St=We("bu"),Ot=We("u"),Qi=We("bum"),Yi=We("um"),It=We("sp"),Mt=We("rtg"),Pt=We("rtc");function qt(e,a=ue){Oo("ec",e,a)}const zt="components";function co(e,a){return Nt(zt,e,!0,a)||e}const xt=Symbol.for("v-ndc");function Nt(e,a,o=!0,s=!1){const i=Oe||ue;if(i){const r=i.type;{const n=Dn(r,!1);if(n&&(n===a||n===Pe(a)||n===Ao(Pe(a))))return r}const t=Rs(i[e]||r[e],a)||Rs(i.appContext[e],a);return!t&&s?r:t}}function Rs(e,a){return e&&(e[a]||e[Pe(a)]||e[Ao(Pe(a))])}function Xo(e,a,o,s){let i;const r=o,t=z(e);if(t||ae(e)){const n=t&&Aa(e);let l=!1,m=!1;n&&(l=!ze(e),m=ma(e),e=Do(e)),i=new Array(e.length);for(let c=0,f=e.length;c<f;c++)i[c]=a(l?m?io(fe(e[c])):fe(e[c]):e[c],c,void 0,r)}else if(typeof e=="number"){i=new Array(e);for(let n=0;n<e;n++)i[n]=a(n+1,n,void 0,r)}else if(Z(e))if(e[Symbol.iterator])i=Array.from(e,(n,l)=>a(n,l,void 0,r));else{const n=Object.keys(e);i=new Array(n.length);for(let l=0,m=n.length;l<m;l++){const c=n[l];i[l]=a(e[c],c,l,r)}}else i=[];return i}const Qo=e=>e?Cr(e)?Po(e):Qo(e.parent):null,La=ne(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Qo(e.parent),$root:e=>Qo(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>ar(e),$forceUpdate:e=>e.f||(e.f=()=>{vs(e.update)}),$nextTick:e=>e.n||(e.n=pt.bind(e.proxy)),$watch:e=>en.bind(e)}),yo=(e,a)=>e!==H&&!e.__isScriptSetup&&F(e,a),Tt={get({_:e},a){if(a==="__v_skip")return!0;const{ctx:o,setupState:s,data:i,props:r,accessCache:t,type:n,appContext:l}=e;let m;if(a[0]!=="$"){const S=t[a];if(S!==void 0)switch(S){case 1:return s[a];case 2:return i[a];case 4:return o[a];case 3:return r[a]}else{if(yo(s,a))return t[a]=1,s[a];if(i!==H&&F(i,a))return t[a]=2,i[a];if((m=e.propsOptions[0])&&F(m,a))return t[a]=3,r[a];if(o!==H&&F(o,a))return t[a]=4,o[a];Yo&&(t[a]=0)}}const c=La[a];let f,C;if(c)return a==="$attrs"&&ce(e.attrs,"get",""),c(e);if((f=n.__cssModules)&&(f=f[a]))return f;if(o!==H&&F(o,a))return t[a]=4,o[a];if(C=l.config.globalProperties,F(C,a))return C[a]},set({_:e},a,o){const{data:s,setupState:i,ctx:r}=e;return yo(i,a)?(i[a]=o,!0):s!==H&&F(s,a)?(s[a]=o,!0):F(e.props,a)||a[0]==="$"&&a.slice(1)in e?!1:(r[a]=o,!0)},has({_:{data:e,setupState:a,accessCache:o,ctx:s,appContext:i,propsOptions:r,type:t}},n){let l,m;return!!(o[n]||e!==H&&n[0]!=="$"&&F(e,n)||yo(a,n)||(l=r[0])&&F(l,n)||F(s,n)||F(La,n)||F(i.config.globalProperties,n)||(m=t.__cssModules)&&m[n])},defineProperty(e,a,o){return o.get!=null?e._.accessCache[a]=0:F(o,"value")&&this.set(e,a,o.value,null),Reflect.defineProperty(e,a,o)}};function Ls(e){return z(e)?e.reduce((a,o)=>(a[o]=null,a),{}):e}let Yo=!0;function Rt(e){const a=ar(e),o=e.proxy,s=e.ctx;Yo=!1,a.beforeCreate&&ys(a.beforeCreate,e,"bc");const{data:i,computed:r,methods:t,watch:n,provide:l,inject:m,created:c,beforeMount:f,mounted:C,beforeUpdate:S,updated:x,activated:R,deactivated:oe,beforeDestroy:y,beforeUnmount:w,destroyed:V,unmounted:P,render:K,renderTracked:ie,renderTriggered:me,errorCaptured:be,serverPrefetch:L,expose:U,inheritAttrs:Q,components:I,directives:X,filters:de}=a;if(m&&Lt(m,s,null),t)for(const Y in t){const $=t[Y];T($)&&(s[Y]=$.bind(o))}if(i){const Y=i.call(o,o);Z(Y)&&(e.data=ps(Y))}if(Yo=!0,r)for(const Y in r){const $=r[Y],oa=T($)?$.bind(o,o):T($.get)?$.get.bind(o,o):we,$a=!T($)&&T($.set)?$.set.bind(o):we,sa=Sn({get:oa,set:$a});Object.defineProperty(s,Y,{enumerable:!0,configurable:!0,get:()=>sa.value,set:Ne=>sa.value=Ne})}if(n)for(const Y in n)er(n[Y],s,o,Y);if(l){const Y=T(l)?l.call(o):l;Reflect.ownKeys(Y).forEach($=>{kt($,Y[$])})}c&&ys(c,e,"c");function re(Y,$){z($)?$.forEach(oa=>Y(oa.bind(o))):$&&Y($.bind(o))}if(re(_t,f),re(Xi,C),re(St,S),re(Ot,x),re(Ct,R),re(Et,oe),re(qt,be),re(Pt,ie),re(Mt,me),re(Qi,w),re(Yi,P),re(It,L),z(U))if(U.length){const Y=e.exposed||(e.exposed={});U.forEach($=>{Object.defineProperty(Y,$,{get:()=>o[$],set:oa=>o[$]=oa,enumerable:!0})})}else e.exposed||(e.exposed={});K&&e.render===we&&(e.render=K),Q!=null&&(e.inheritAttrs=Q),I&&(e.components=I),X&&(e.directives=X),L&&Wi(e)}function Lt(e,a,o=we){z(e)&&(e=es(e));for(const s in e){const i=e[s];let r;Z(i)?"default"in i?r=eo(i.from||s,i.default,!0):r=eo(i.from||s):r=eo(i),he(r)?Object.defineProperty(a,s,{enumerable:!0,configurable:!0,get:()=>r.value,set:t=>r.value=t}):a[s]=r}}function ys(e,a,o){xe(z(e)?e.map(s=>s.bind(a.proxy)):e.bind(a.proxy),a,o)}function er(e,a,o,s){let i=s.includes(".")?fr(o,s):()=>o[s];if(ae(e)){const r=a[e];T(r)&&Bo(i,r)}else if(T(e))Bo(i,e.bind(o));else if(Z(e))if(z(e))e.forEach(r=>er(r,a,o,s));else{const r=T(e.handler)?e.handler.bind(o):a[e.handler];T(r)&&Bo(i,r,e)}}function ar(e){const a=e.type,{mixins:o,extends:s}=a,{mixins:i,optionsCache:r,config:{optionMergeStrategies:t}}=e.appContext,n=r.get(a);let l;return n?l=n:!i.length&&!o&&!s?l=a:(l={},i.length&&i.forEach(m=>uo(l,m,t,!0)),uo(l,a,t)),Z(a)&&r.set(a,l),l}function uo(e,a,o,s=!1){const{mixins:i,extends:r}=a;r&&uo(e,r,o,!0),i&&i.forEach(t=>uo(e,t,o,!0));for(const t in a)if(!(s&&t==="expose")){const n=yt[t]||o&&o[t];e[t]=n?n(e[t],a[t]):a[t]}return e}const yt={data:js,props:Bs,emits:Bs,methods:Pa,computed:Pa,beforeCreate:pe,created:pe,beforeMount:pe,mounted:pe,beforeUpdate:pe,updated:pe,beforeDestroy:pe,beforeUnmount:pe,destroyed:pe,unmounted:pe,activated:pe,deactivated:pe,errorCaptured:pe,serverPrefetch:pe,components:Pa,directives:Pa,watch:Bt,provide:js,inject:jt};function js(e,a){return a?e?function(){return ne(T(e)?e.call(this,this):e,T(a)?a.call(this,this):a)}:a:e}function jt(e,a){return Pa(es(e),es(a))}function es(e){if(z(e)){const a={};for(let o=0;o<e.length;o++)a[e[o]]=e[o];return a}return e}function pe(e,a){return e?[...new Set([].concat(e,a))]:a}function Pa(e,a){return e?ne(Object.create(null),e,a):a}function Bs(e,a){return e?z(e)&&z(a)?[...new Set([...e,...a])]:ne(Object.create(null),Ls(e),Ls(a??{})):a}function Bt(e,a){if(!e)return a;if(!a)return e;const o=ne(Object.create(null),e);for(const s in a)o[s]=pe(e[s],a[s]);return o}function or(){return{app:null,config:{isNativeTag:ui,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let wt=0;function Ft(e,a){return function(s,i=null){T(s)||(s=ne({},s)),i!=null&&!Z(i)&&(i=null);const r=or(),t=new WeakSet,n=[];let l=!1;const m=r.app={_uid:wt++,_component:s,_props:i,_container:null,_context:r,_instance:null,version:In,get config(){return r.config},set config(c){},use(c,...f){return t.has(c)||(c&&T(c.install)?(t.add(c),c.install(m,...f)):T(c)&&(t.add(c),c(m,...f))),m},mixin(c){return r.mixins.includes(c)||r.mixins.push(c),m},component(c,f){return f?(r.components[c]=f,m):r.components[c]},directive(c,f){return f?(r.directives[c]=f,m):r.directives[c]},mount(c,f,C){if(!l){const S=m._ceVNode||te(s,i);return S.appContext=r,C===!0?C="svg":C===!1&&(C=void 0),e(S,c,C),l=!0,m._container=c,c.__vue_app__=m,Po(S.component)}},onUnmount(c){n.push(c)},unmount(){l&&(xe(n,m._instance,16),e(null,m._container),delete m._container.__vue_app__)},provide(c,f){return r.provides[c]=f,m},runWithContext(c){const f=Ea;Ea=m;try{return c()}finally{Ea=f}}};return m}}let Ea=null;function kt(e,a){if(ue){let o=ue.provides;const s=ue.parent&&ue.parent.provides;s===o&&(o=ue.provides=Object.create(s)),o[e]=a}}function eo(e,a,o=!1){const s=Ar();if(s||Ea){let i=Ea?Ea._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(i&&e in i)return i[e];if(arguments.length>1)return o&&T(a)?a.call(s&&s.proxy):a}}const sr={},ir=()=>Object.create(sr),rr=e=>Object.getPrototypeOf(e)===sr;function Gt(e,a,o,s=!1){const i={},r=ir();e.propsDefaults=Object.create(null),tr(e,a,i,r);for(const t in e.propsOptions[0])t in i||(i[t]=void 0);o?e.props=s?i:it(i):e.type.props?e.props=i:e.props=r,e.attrs=r}function Ut(e,a,o,s){const{props:i,attrs:r,vnode:{patchFlag:t}}=e,n=G(i),[l]=e.propsOptions;let m=!1;if((s||t>0)&&!(t&16)){if(t&8){const c=e.vnode.dynamicProps;for(let f=0;f<c.length;f++){let C=c[f];if(Io(e.emitsOptions,C))continue;const S=a[C];if(l)if(F(r,C))S!==r[C]&&(r[C]=S,m=!0);else{const x=Pe(C);i[x]=as(l,n,x,S,e,!1)}else S!==r[C]&&(r[C]=S,m=!0)}}}else{tr(e,a,i,r)&&(m=!0);let c;for(const f in n)(!a||!F(a,f)&&((c=pa(f))===f||!F(a,c)))&&(l?o&&(o[f]!==void 0||o[c]!==void 0)&&(i[f]=as(l,n,f,void 0,e,!0)):delete i[f]);if(r!==n)for(const f in r)(!a||!F(a,f))&&(delete r[f],m=!0)}m&&He(e.attrs,"set","")}function tr(e,a,o,s){const[i,r]=e.propsOptions;let t=!1,n;if(a)for(let l in a){if(za(l))continue;const m=a[l];let c;i&&F(i,c=Pe(l))?!r||!r.includes(c)?o[c]=m:(n||(n={}))[c]=m:Io(e.emitsOptions,l)||(!(l in s)||m!==s[l])&&(s[l]=m,t=!0)}if(r){const l=G(o),m=n||H;for(let c=0;c<r.length;c++){const f=r[c];o[f]=as(i,l,f,m[f],e,!F(m,f))}}return t}function as(e,a,o,s,i,r){const t=e[o];if(t!=null){const n=F(t,"default");if(n&&s===void 0){const l=t.default;if(t.type!==Function&&!t.skipFactory&&T(l)){const{propsDefaults:m}=i;if(o in m)s=m[o];else{const c=Ha(i);s=m[o]=l.call(null,a),c()}}else s=l;i.ce&&i.ce._setProp(o,s)}t[0]&&(r&&!n?s=!1:t[1]&&(s===""||s===pa(o))&&(s=!0))}return s}const Vt=new WeakMap;function nr(e,a,o=!1){const s=o?Vt:a.propsCache,i=s.get(e);if(i)return i;const r=e.props,t={},n=[];let l=!1;if(!T(e)){const c=f=>{l=!0;const[C,S]=nr(f,a,!0);ne(t,C),S&&n.push(...S)};!o&&a.mixins.length&&a.mixins.forEach(c),e.extends&&c(e.extends),e.mixins&&e.mixins.forEach(c)}if(!r&&!l)return Z(e)&&s.set(e,ha),ha;if(z(r))for(let c=0;c<r.length;c++){const f=Pe(r[c]);ws(f)&&(t[f]=H)}else if(r)for(const c in r){const f=Pe(c);if(ws(f)){const C=r[c],S=t[f]=z(C)||T(C)?{type:C}:ne({},C),x=S.type;let R=!1,oe=!0;if(z(x))for(let y=0;y<x.length;++y){const w=x[y],V=T(w)&&w.name;if(V==="Boolean"){R=!0;break}else V==="String"&&(oe=!1)}else R=T(x)&&x.name==="Boolean";S[0]=R,S[1]=oe,(R||F(S,"default"))&&n.push(f)}}const m=[t,n];return Z(e)&&s.set(e,m),m}function ws(e){return e[0]!=="$"&&!za(e)}const hs=e=>e==="_"||e==="_ctx"||e==="$stable",bs=e=>z(e)?e.map(Be):[Be(e)],Ht=(e,a,o)=>{if(a._n)return a;const s=ki((...i)=>bs(a(...i)),o);return s._c=!1,s},dr=(e,a,o)=>{const s=e._ctx;for(const i in e){if(hs(i))continue;const r=e[i];if(T(r))a[i]=Ht(i,r,s);else if(r!=null){const t=bs(r);a[i]=()=>t}}},lr=(e,a)=>{const o=bs(a);e.slots.default=()=>o},cr=(e,a,o)=>{for(const s in a)(o||!hs(s))&&(e[s]=a[s])},Kt=(e,a,o)=>{const s=e.slots=ir();if(e.vnode.shapeFlag&32){const i=a._;i?(cr(s,a,o),o&&vi(s,"_",i,!0)):dr(a,s)}else a&&lr(e,a)},$t=(e,a,o)=>{const{vnode:s,slots:i}=e;let r=!0,t=H;if(s.shapeFlag&32){const n=a._;n?o&&n===1?r=!1:cr(i,a,o):(r=!a.$stable,dr(a,i)),t=a}else a&&(lr(e,a),t={default:1});if(r)for(const n in i)!hs(n)&&t[n]==null&&delete i[n]},_e=ln;function Jt(e){return Wt(e)}function Wt(e,a){const o=Co();o.__VUE__=!0;const{insert:s,remove:i,patchProp:r,createElement:t,createText:n,createComment:l,setText:m,setElementText:c,parentNode:f,nextSibling:C,setScopeId:S=we,insertStaticContent:x}=e,R=(d,u,g,b=null,v=null,h=null,_=void 0,D=null,E=!!u.dynamicChildren)=>{if(d===u)return;d&&!la(d,u)&&(b=Ja(d),Ne(d,v,h,!0),d=null),u.patchFlag===-2&&(E=!1,u.dynamicChildren=null);const{type:A,ref:q,shapeFlag:O}=u;switch(A){case Mo:oe(d,u,g,b);break;case ve:y(d,u,g,b);break;case ao:d==null&&w(u,g,b,_);break;case Se:I(d,u,g,b,v,h,_,D,E);break;default:O&1?K(d,u,g,b,v,h,_,D,E):O&6?X(d,u,g,b,v,h,_,D,E):(O&64||O&128)&&A.process(d,u,g,b,v,h,_,D,E,_a)}q!=null&&v?Ta(q,d&&d.ref,h,u||d,!u):q==null&&d&&d.ref!=null&&Ta(d.ref,null,h,d,!0)},oe=(d,u,g,b)=>{if(d==null)s(u.el=n(u.children),g,b);else{const v=u.el=d.el;u.children!==d.children&&m(v,u.children)}},y=(d,u,g,b)=>{d==null?s(u.el=l(u.children||""),g,b):u.el=d.el},w=(d,u,g,b)=>{[d.el,d.anchor]=x(d.children,u,g,b,d.el,d.anchor)},V=({el:d,anchor:u},g,b)=>{let v;for(;d&&d!==u;)v=C(d),s(d,g,b),d=v;s(u,g,b)},P=({el:d,anchor:u})=>{let g;for(;d&&d!==u;)g=C(d),i(d),d=g;i(u)},K=(d,u,g,b,v,h,_,D,E)=>{u.type==="svg"?_="svg":u.type==="math"&&(_="mathml"),d==null?ie(u,g,b,v,h,_,D,E):L(d,u,v,h,_,D,E)},ie=(d,u,g,b,v,h,_,D)=>{let E,A;const{props:q,shapeFlag:O,transition:M,dirs:N}=d;if(E=d.el=t(d.type,h,q&&q.is,q),O&8?c(E,d.children):O&16&&be(d.children,E,null,b,v,jo(d,h),_,D),N&&ia(d,null,b,"created"),me(E,d,d.scopeId,_,b),q){for(const J in q)J!=="value"&&!za(J)&&r(E,J,null,q[J],h,b);"value"in q&&r(E,"value",null,q.value,h),(A=q.onVnodeBeforeMount)&&ye(A,b,d)}N&&ia(d,null,b,"beforeMount");const B=Zt(v,M);B&&M.beforeEnter(E),s(E,u,g),((A=q&&q.onVnodeMounted)||B||N)&&_e(()=>{A&&ye(A,b,d),B&&M.enter(E),N&&ia(d,null,b,"mounted")},v)},me=(d,u,g,b,v)=>{if(g&&S(d,g),b)for(let h=0;h<b.length;h++)S(d,b[h]);if(v){let h=v.subTree;if(u===h||vr(h.type)&&(h.ssContent===u||h.ssFallback===u)){const _=v.vnode;me(d,_,_.scopeId,_.slotScopeIds,v.parent)}}},be=(d,u,g,b,v,h,_,D,E=0)=>{for(let A=E;A<d.length;A++){const q=d[A]=D?Qe(d[A]):Be(d[A]);R(null,q,u,g,b,v,h,_,D)}},L=(d,u,g,b,v,h,_)=>{const D=u.el=d.el;let{patchFlag:E,dynamicChildren:A,dirs:q}=u;E|=d.patchFlag&16;const O=d.props||H,M=u.props||H;let N;if(g&&ra(g,!1),(N=M.onVnodeBeforeUpdate)&&ye(N,g,u,d),q&&ia(u,d,g,"beforeUpdate"),g&&ra(g,!0),(O.innerHTML&&M.innerHTML==null||O.textContent&&M.textContent==null)&&c(D,""),A?U(d.dynamicChildren,A,D,g,b,jo(u,v),h):_||$(d,u,D,null,g,b,jo(u,v),h,!1),E>0){if(E&16)Q(D,O,M,g,v);else if(E&2&&O.class!==M.class&&r(D,"class",null,M.class,v),E&4&&r(D,"style",O.style,M.style,v),E&8){const B=u.dynamicProps;for(let J=0;J<B.length;J++){const k=B[J],Ae=O[k],Ce=M[k];(Ce!==Ae||k==="value")&&r(D,k,Ae,Ce,v,g)}}E&1&&d.children!==u.children&&c(D,u.children)}else!_&&A==null&&Q(D,O,M,g,v);((N=M.onVnodeUpdated)||q)&&_e(()=>{N&&ye(N,g,u,d),q&&ia(u,d,g,"updated")},b)},U=(d,u,g,b,v,h,_)=>{for(let D=0;D<u.length;D++){const E=d[D],A=u[D],q=E.el&&(E.type===Se||!la(E,A)||E.shapeFlag&198)?f(E.el):g;R(E,A,q,null,b,v,h,_,!0)}},Q=(d,u,g,b,v)=>{if(u!==g){if(u!==H)for(const h in u)!za(h)&&!(h in g)&&r(d,h,u[h],null,v,b);for(const h in g){if(za(h))continue;const _=g[h],D=u[h];_!==D&&h!=="value"&&r(d,h,D,_,v,b)}"value"in g&&r(d,"value",u.value,g.value,v)}},I=(d,u,g,b,v,h,_,D,E)=>{const A=u.el=d?d.el:n(""),q=u.anchor=d?d.anchor:n("");let{patchFlag:O,dynamicChildren:M,slotScopeIds:N}=u;N&&(D=D?D.concat(N):N),d==null?(s(A,g,b),s(q,g,b),be(u.children||[],g,q,v,h,_,D,E)):O>0&&O&64&&M&&d.dynamicChildren?(U(d.dynamicChildren,M,g,v,h,_,D),(u.key!=null||v&&u===v.subTree)&&ur(d,u,!0)):$(d,u,g,q,v,h,_,D,E)},X=(d,u,g,b,v,h,_,D,E)=>{u.slotScopeIds=D,d==null?u.shapeFlag&512?v.ctx.activate(u,g,b,_,E):de(u,g,b,v,h,_,E):Fe(d,u,E)},de=(d,u,g,b,v,h,_)=>{const D=d.component=hn(d,b,v);if(So(d)&&(D.ctx.renderer=_a),bn(D,!1,_),D.asyncDep){if(v&&v.registerDep(D,re,_),!d.el){const E=D.subTree=te(ve);y(null,E,u,g),d.placeholder=E.el}}else re(D,d,u,g,v,h,_)},Fe=(d,u,g)=>{const b=u.component=d.component;if(nn(d,u,g))if(b.asyncDep&&!b.asyncResolved){Y(b,u,g);return}else b.next=u,b.update();else u.el=d.el,b.vnode=u},re=(d,u,g,b,v,h,_)=>{const D=()=>{if(d.isMounted){let{next:O,bu:M,u:N,parent:B,vnode:J}=d;{const Re=mr(d);if(Re){O&&(O.el=J.el,Y(d,O,_)),Re.asyncDep.then(()=>{d.isUnmounted||D()});return}}let k=O,Ae;ra(d,!1),O?(O.el=J.el,Y(d,O,_)):O=J,M&&Ya(M),(Ae=O.props&&O.props.onVnodeBeforeUpdate)&&ye(Ae,B,O,J),ra(d,!0);const Ce=ks(d),Te=d.subTree;d.subTree=Ce,R(Te,Ce,f(Te.el),Ja(Te),d,v,h),O.el=Ce.el,k===null&&dn(d,Ce.el),N&&_e(N,v),(Ae=O.props&&O.props.onVnodeUpdated)&&_e(()=>ye(Ae,B,O,J),v)}else{let O;const{el:M,props:N}=u,{bm:B,m:J,parent:k,root:Ae,type:Ce}=d,Te=Ra(u);ra(d,!1),B&&Ya(B),!Te&&(O=N&&N.onVnodeBeforeMount)&&ye(O,k,u),ra(d,!0);{Ae.ce&&Ae.ce._def.shadowRoot!==!1&&Ae.ce._injectChildStyle(Ce);const Re=d.subTree=ks(d);R(null,Re,g,b,d,v,h),u.el=Re.el}if(J&&_e(J,v),!Te&&(O=N&&N.onVnodeMounted)){const Re=u;_e(()=>ye(O,k,Re),v)}(u.shapeFlag&256||k&&Ra(k.vnode)&&k.vnode.shapeFlag&256)&&d.a&&_e(d.a,v),d.isMounted=!0,u=g=b=null}};d.scope.on();const E=d.effect=new Ci(D);d.scope.off();const A=d.update=E.run.bind(E),q=d.job=E.runIfDirty.bind(E);q.i=d,q.id=d.uid,E.scheduler=()=>vs(q),ra(d,!0),A()},Y=(d,u,g)=>{u.component=d;const b=d.vnode.props;d.vnode=u,d.next=null,Ut(d,u.props,b,g),$t(d,u.children,g),$e(),xs(d),Je()},$=(d,u,g,b,v,h,_,D,E=!1)=>{const A=d&&d.children,q=d?d.shapeFlag:0,O=u.children,{patchFlag:M,shapeFlag:N}=u;if(M>0){if(M&128){$a(A,O,g,b,v,h,_,D,E);return}else if(M&256){oa(A,O,g,b,v,h,_,D,E);return}}N&8?(q&16&&Da(A,v,h),O!==A&&c(g,O)):q&16?N&16?$a(A,O,g,b,v,h,_,D,E):Da(A,v,h,!0):(q&8&&c(g,""),N&16&&be(O,g,b,v,h,_,D,E))},oa=(d,u,g,b,v,h,_,D,E)=>{d=d||ha,u=u||ha;const A=d.length,q=u.length,O=Math.min(A,q);let M;for(M=0;M<O;M++){const N=u[M]=E?Qe(u[M]):Be(u[M]);R(d[M],N,g,null,v,h,_,D,E)}A>q?Da(d,v,h,!0,!1,O):be(u,g,b,v,h,_,D,E,O)},$a=(d,u,g,b,v,h,_,D,E)=>{let A=0;const q=u.length;let O=d.length-1,M=q-1;for(;A<=O&&A<=M;){const N=d[A],B=u[A]=E?Qe(u[A]):Be(u[A]);if(la(N,B))R(N,B,g,null,v,h,_,D,E);else break;A++}for(;A<=O&&A<=M;){const N=d[O],B=u[M]=E?Qe(u[M]):Be(u[M]);if(la(N,B))R(N,B,g,null,v,h,_,D,E);else break;O--,M--}if(A>O){if(A<=M){const N=M+1,B=N<q?u[N].el:b;for(;A<=M;)R(null,u[A]=E?Qe(u[A]):Be(u[A]),g,B,v,h,_,D,E),A++}}else if(A>M)for(;A<=O;)Ne(d[A],v,h,!0),A++;else{const N=A,B=A,J=new Map;for(A=B;A<=M;A++){const De=u[A]=E?Qe(u[A]):Be(u[A]);De.key!=null&&J.set(De.key,A)}let k,Ae=0;const Ce=M-B+1;let Te=!1,Re=0;const Sa=new Array(Ce);for(A=0;A<Ce;A++)Sa[A]=0;for(A=N;A<=O;A++){const De=d[A];if(Ae>=Ce){Ne(De,v,h,!0);continue}let Le;if(De.key!=null)Le=J.get(De.key);else for(k=B;k<=M;k++)if(Sa[k-B]===0&&la(De,u[k])){Le=k;break}Le===void 0?Ne(De,v,h,!0):(Sa[Le-B]=A+1,Le>=Re?Re=Le:Te=!0,R(De,u[Le],g,null,v,h,_,D,E),Ae++)}const Os=Te?Xt(Sa):ha;for(k=Os.length-1,A=Ce-1;A>=0;A--){const De=B+A,Le=u[De],Is=u[De+1],Ms=De+1<q?Is.el||Is.placeholder:b;Sa[A]===0?R(null,Le,g,Ms,v,h,_,D,E):Te&&(k<0||A!==Os[k]?sa(Le,g,Ms,2):k--)}}},sa=(d,u,g,b,v=null)=>{const{el:h,type:_,transition:D,children:E,shapeFlag:A}=d;if(A&6){sa(d.component.subTree,u,g,b);return}if(A&128){d.suspense.move(u,g,b);return}if(A&64){_.move(d,u,g,_a);return}if(_===Se){s(h,u,g);for(let O=0;O<E.length;O++)sa(E[O],u,g,b);s(d.anchor,u,g);return}if(_===ao){V(d,u,g);return}if(b!==2&&A&1&&D)if(b===0)D.beforeEnter(h),s(h,u,g),_e(()=>D.enter(h),v);else{const{leave:O,delayLeave:M,afterLeave:N}=D,B=()=>{d.ctx.isUnmounted?i(h):s(h,u,g)},J=()=>{h._isLeaving&&h[Ve](!0),O(h,()=>{B(),N&&N()})};M?M(h,B,J):J()}else s(h,u,g)},Ne=(d,u,g,b=!1,v=!1)=>{const{type:h,props:_,ref:D,children:E,dynamicChildren:A,shapeFlag:q,patchFlag:O,dirs:M,cacheIndex:N}=d;if(O===-2&&(v=!1),D!=null&&($e(),Ta(D,null,g,d,!0),Je()),N!=null&&(u.renderCache[N]=void 0),q&256){u.ctx.deactivate(d);return}const B=q&1&&M,J=!Ra(d);let k;if(J&&(k=_&&_.onVnodeBeforeUnmount)&&ye(k,u,d),q&6)Ir(d.component,g,b);else{if(q&128){d.suspense.unmount(g,b);return}B&&ia(d,null,u,"beforeUnmount"),q&64?d.type.remove(d,u,g,_a,b):A&&!A.hasOnce&&(h!==Se||O>0&&O&64)?Da(A,u,g,!1,!0):(h===Se&&O&384||!v&&q&16)&&Da(E,u,g),b&&_s(d)}(J&&(k=_&&_.onVnodeUnmounted)||B)&&_e(()=>{k&&ye(k,u,d),B&&ia(d,null,u,"unmounted")},g)},_s=d=>{const{type:u,el:g,anchor:b,transition:v}=d;if(u===Se){Or(g,b);return}if(u===ao){P(d);return}const h=()=>{i(g),v&&!v.persisted&&v.afterLeave&&v.afterLeave()};if(d.shapeFlag&1&&v&&!v.persisted){const{leave:_,delayLeave:D}=v,E=()=>_(g,h);D?D(d.el,h,E):E()}else h()},Or=(d,u)=>{let g;for(;d!==u;)g=C(d),i(d),d=g;i(u)},Ir=(d,u,g)=>{const{bum:b,scope:v,job:h,subTree:_,um:D,m:E,a:A}=d;Fs(E),Fs(A),b&&Ya(b),v.stop(),h&&(h.flags|=8,Ne(_,d,u,g)),D&&_e(D,u),_e(()=>{d.isUnmounted=!0},u)},Da=(d,u,g,b=!1,v=!1,h=0)=>{for(let _=h;_<d.length;_++)Ne(d[_],u,g,b,v)},Ja=d=>{if(d.shapeFlag&6)return Ja(d.component.subTree);if(d.shapeFlag&128)return d.suspense.next();const u=C(d.anchor||d.el),g=u&&u[vt];return g?C(g):u};let qo=!1;const Ss=(d,u,g)=>{d==null?u._vnode&&Ne(u._vnode,null,null,!0):R(u._vnode||null,d,u,null,null,null,g),u._vnode=d,qo||(qo=!0,xs(),Bi(),qo=!1)},_a={p:R,um:Ne,m:sa,r:_s,mt:de,mc:be,pc:$,pbc:U,n:Ja,o:e};return{render:Ss,hydrate:void 0,createApp:Ft(Ss)}}function jo({type:e,props:a},o){return o==="svg"&&e==="foreignObject"||o==="mathml"&&e==="annotation-xml"&&a&&a.encoding&&a.encoding.includes("html")?void 0:o}function ra({effect:e,job:a},o){o?(e.flags|=32,a.flags|=4):(e.flags&=-33,a.flags&=-5)}function Zt(e,a){return(!e||e&&!e.pendingBranch)&&a&&!a.persisted}function ur(e,a,o=!1){const s=e.children,i=a.children;if(z(s)&&z(i))for(let r=0;r<s.length;r++){const t=s[r];let n=i[r];n.shapeFlag&1&&!n.dynamicChildren&&((n.patchFlag<=0||n.patchFlag===32)&&(n=i[r]=Qe(i[r]),n.el=t.el),!o&&n.patchFlag!==-2&&ur(t,n)),n.type===Mo&&n.patchFlag!==-1&&(n.el=t.el),n.type===ve&&!n.el&&(n.el=t.el)}}function Xt(e){const a=e.slice(),o=[0];let s,i,r,t,n;const l=e.length;for(s=0;s<l;s++){const m=e[s];if(m!==0){if(i=o[o.length-1],e[i]<m){a[s]=i,o.push(s);continue}for(r=0,t=o.length-1;r<t;)n=r+t>>1,e[o[n]]<m?r=n+1:t=n;m<e[o[r]]&&(r>0&&(a[s]=o[r-1]),o[r]=s)}}for(r=o.length,t=o[r-1];r-- >0;)o[r]=t,t=a[t];return o}function mr(e){const a=e.subTree.component;if(a)return a.asyncDep&&!a.asyncResolved?a:mr(a)}function Fs(e){if(e)for(let a=0;a<e.length;a++)e[a].flags|=8}const Qt=Symbol.for("v-scx"),Yt=()=>eo(Qt);function Bo(e,a,o){return pr(e,a,o)}function pr(e,a,o=H){const{immediate:s,deep:i,flush:r,once:t}=o,n=ne({},o),l=a&&s||!a&&r!=="post";let m;if(Ga){if(r==="sync"){const S=Yt();m=S.__watcherHandles||(S.__watcherHandles=[])}else if(!l){const S=()=>{};return S.stop=we,S.resume=we,S.pause=we,S}}const c=ue;n.call=(S,x,R)=>xe(S,c,x,R);let f=!1;r==="post"?n.scheduler=S=>{_e(S,c&&c.suspense)}:r!=="sync"&&(f=!0,n.scheduler=(S,x)=>{x?S():vs(S)}),n.augmentJob=S=>{a&&(S.flags|=4),f&&(S.flags|=2,c&&(S.id=c.uid,S.i=c))};const C=ut(e,a,n);return Ga&&(m?m.push(C):l&&C()),C}function en(e,a,o){const s=this.proxy,i=ae(e)?e.includes(".")?fr(s,e):()=>s[e]:e.bind(s,s);let r;T(a)?r=a:(r=a.handler,o=a);const t=Ha(this),n=pr(i,r.bind(s),o);return t(),n}function fr(e,a){const o=a.split(".");return()=>{let s=e;for(let i=0;i<o.length&&s;i++)s=s[o[i]];return s}}const an=(e,a)=>a==="modelValue"||a==="model-value"?e.modelModifiers:e[`${a}Modifiers`]||e[`${Pe(a)}Modifiers`]||e[`${pa(a)}Modifiers`];function on(e,a,...o){if(e.isUnmounted)return;const s=e.vnode.props||H;let i=o;const r=a.startsWith("update:"),t=r&&an(s,a.slice(7));t&&(t.trim&&(i=o.map(c=>ae(c)?c.trim():c)),t.number&&(i=o.map(Vo)));let n,l=s[n=zo(a)]||s[n=zo(Pe(a))];!l&&r&&(l=s[n=zo(pa(a))]),l&&xe(l,e,6,i);const m=s[n+"Once"];if(m){if(!e.emitted)e.emitted={};else if(e.emitted[n])return;e.emitted[n]=!0,xe(m,e,6,i)}}const sn=new WeakMap;function gr(e,a,o=!1){const s=o?sn:a.emitsCache,i=s.get(e);if(i!==void 0)return i;const r=e.emits;let t={},n=!1;if(!T(e)){const l=m=>{const c=gr(m,a,!0);c&&(n=!0,ne(t,c))};!o&&a.mixins.length&&a.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!r&&!n?(Z(e)&&s.set(e,null),null):(z(r)?r.forEach(l=>t[l]=null):ne(t,r),Z(e)&&s.set(e,t),t)}function Io(e,a){return!e||!vo(a)?!1:(a=a.slice(2).replace(/Once$/,""),F(e,a[0].toLowerCase()+a.slice(1))||F(e,pa(a))||F(e,a))}function ks(e){const{type:a,vnode:o,proxy:s,withProxy:i,propsOptions:[r],slots:t,attrs:n,emit:l,render:m,renderCache:c,props:f,data:C,setupState:S,ctx:x,inheritAttrs:R}=e,oe=no(e);let y,w;try{if(o.shapeFlag&4){const P=i||s,K=P;y=Be(m.call(K,P,c,f,S,C,x)),w=n}else{const P=a;y=Be(P.length>1?P(f,{attrs:n,slots:t,emit:l}):P(f,null)),w=a.props?n:rn(n)}}catch(P){ya.length=0,_o(P,e,1),y=te(ve)}let V=y;if(w&&R!==!1){const P=Object.keys(w),{shapeFlag:K}=V;P.length&&K&7&&(r&&P.some(rs)&&(w=tn(w,r)),V=ea(V,w,!1,!0))}return o.dirs&&(V=ea(V,null,!1,!0),V.dirs=V.dirs?V.dirs.concat(o.dirs):o.dirs),o.transition&&Fa(V,o.transition),y=V,no(oe),y}const rn=e=>{let a;for(const o in e)(o==="class"||o==="style"||vo(o))&&((a||(a={}))[o]=e[o]);return a},tn=(e,a)=>{const o={};for(const s in e)(!rs(s)||!(s.slice(9)in a))&&(o[s]=e[s]);return o};function nn(e,a,o){const{props:s,children:i,component:r}=e,{props:t,children:n,patchFlag:l}=a,m=r.emitsOptions;if(a.dirs||a.transition)return!0;if(o&&l>=0){if(l&1024)return!0;if(l&16)return s?Gs(s,t,m):!!t;if(l&8){const c=a.dynamicProps;for(let f=0;f<c.length;f++){const C=c[f];if(t[C]!==s[C]&&!Io(m,C))return!0}}}else return(i||n)&&(!n||!n.$stable)?!0:s===t?!1:s?t?Gs(s,t,m):!0:!!t;return!1}function Gs(e,a,o){const s=Object.keys(a);if(s.length!==Object.keys(e).length)return!0;for(let i=0;i<s.length;i++){const r=s[i];if(a[r]!==e[r]&&!Io(o,r))return!0}return!1}function dn({vnode:e,parent:a},o){for(;a;){const s=a.subTree;if(s.suspense&&s.suspense.activeBranch===e&&(s.el=e.el),s===e)(e=a.vnode).el=o,a=a.parent;else break}}const vr=e=>e.__isSuspense;function ln(e,a){a&&a.pendingBranch?z(e)?a.effects.push(...e):a.effects.push(e):gt(e)}const Se=Symbol.for("v-fgt"),Mo=Symbol.for("v-txt"),ve=Symbol.for("v-cmt"),ao=Symbol.for("v-stc"),ya=[];let Ie=null;function ee(e=!1){ya.push(Ie=e?null:[])}function cn(){ya.pop(),Ie=ya[ya.length-1]||null}let ka=1;function mo(e,a=!1){ka+=e,e<0&&Ie&&a&&(Ie.hasOnce=!0)}function hr(e){return e.dynamicChildren=ka>0?Ie||ha:null,cn(),ka>0&&Ie&&Ie.push(e),e}function se(e,a,o,s,i,r){return hr(j(e,a,o,s,i,r,!0))}function As(e,a,o,s,i){return hr(te(e,a,o,s,i,!0))}function po(e){return e?e.__v_isVNode===!0:!1}function la(e,a){return e.type===a.type&&e.key===a.key}const br=({key:e})=>e??null,oo=({ref:e,ref_key:a,ref_for:o})=>(typeof e=="number"&&(e=""+e),e!=null?ae(e)||he(e)||T(e)?{i:Oe,r:e,k:a,f:!!o}:e:null);function j(e,a=null,o=null,s=0,i=null,r=e===Se?0:1,t=!1,n=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:a,key:a&&br(a),ref:a&&oo(a),scopeId:Fi,slotScopeIds:null,children:o,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:r,patchFlag:s,dynamicProps:i,dynamicChildren:null,appContext:null,ctx:Oe};return n?(Cs(l,o),r&128&&e.normalize(l)):o&&(l.shapeFlag|=ae(o)?8:16),ka>0&&!t&&Ie&&(l.patchFlag>0||r&6)&&l.patchFlag!==32&&Ie.push(l),l}const te=un;function un(e,a=null,o=null,s=0,i=null,r=!1){if((!e||e===xt)&&(e=ve),po(e)){const n=ea(e,a,!0);return o&&Cs(n,o),ka>0&&!r&&Ie&&(n.shapeFlag&6?Ie[Ie.indexOf(e)]=n:Ie.push(n)),n.patchFlag=-2,n}if(_n(e)&&(e=e.__vccOpts),a){a=mn(a);let{class:n,style:l}=a;n&&!ae(n)&&(a.class=Eo(n)),Z(l)&&(gs(l)&&!z(l)&&(l=ne({},l)),a.style=ds(l))}const t=ae(e)?1:vr(e)?128:Ui(e)?64:Z(e)?4:T(e)?2:0;return j(e,a,o,s,i,t,r,!0)}function mn(e){return e?gs(e)||rr(e)?ne({},e):e:null}function ea(e,a,o=!1,s=!1){const{props:i,ref:r,patchFlag:t,children:n,transition:l}=e,m=a?fn(i||{},a):i,c={__v_isVNode:!0,__v_skip:!0,type:e.type,props:m,key:m&&br(m),ref:a&&a.ref?o&&r?z(r)?r.concat(oo(a)):[r,oo(a)]:oo(a):r,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:n,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:a&&e.type!==Se?t===-1?16:t|16:t,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:l,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&ea(e.ssContent),ssFallback:e.ssFallback&&ea(e.ssFallback),placeholder:e.placeholder,el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return l&&s&&Fa(c,l.clone(c)),c}function qa(e=" ",a=0){return te(Mo,null,e,a)}function pn(e,a){const o=te(ao,null,e);return o.staticCount=a,o}function Ye(e="",a=!1){return a?(ee(),As(ve,null,e)):te(ve,null,e)}function Be(e){return e==null||typeof e=="boolean"?te(ve):z(e)?te(Se,null,e.slice()):po(e)?Qe(e):te(Mo,null,String(e))}function Qe(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:ea(e)}function Cs(e,a){let o=0;const{shapeFlag:s}=e;if(a==null)a=null;else if(z(a))o=16;else if(typeof a=="object")if(s&65){const i=a.default;i&&(i._c&&(i._d=!1),Cs(e,i()),i._c&&(i._d=!0));return}else{o=32;const i=a._;!i&&!rr(a)?a._ctx=Oe:i===3&&Oe&&(Oe.slots._===1?a._=1:(a._=2,e.patchFlag|=1024))}else T(a)?(a={default:a,_ctx:Oe},o=32):(a=String(a),s&64?(o=16,a=[qa(a)]):o=8);e.children=a,e.shapeFlag|=o}function fn(...e){const a={};for(let o=0;o<e.length;o++){const s=e[o];for(const i in s)if(i==="class")a.class!==s.class&&(a.class=Eo([a.class,s.class]));else if(i==="style")a.style=ds([a.style,s.style]);else if(vo(i)){const r=a[i],t=s[i];t&&r!==t&&!(z(r)&&r.includes(t))&&(a[i]=r?[].concat(r,t):t)}else i!==""&&(a[i]=s[i])}return a}function ye(e,a,o,s=null){xe(e,a,7,[o,s])}const gn=or();let vn=0;function hn(e,a,o){const s=e.type,i=(a?a.appContext:e.appContext)||gn,r={uid:vn++,vnode:e,type:s,parent:a,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new Br(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:a?a.provides:Object.create(i.provides),ids:a?a.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:nr(s,i),emitsOptions:gr(s,i),emit:null,emitted:null,propsDefaults:H,inheritAttrs:s.inheritAttrs,ctx:H,data:H,props:H,attrs:H,slots:H,refs:H,setupState:H,setupContext:null,suspense:o,suspenseId:o?o.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return r.ctx={_:r},r.root=a?a.root:r,r.emit=on.bind(null,r),e.ce&&e.ce(r),r}let ue=null;const Ar=()=>ue||Oe;let fo,os;{const e=Co(),a=(o,s)=>{let i;return(i=e[o])||(i=e[o]=[]),i.push(s),r=>{i.length>1?i.forEach(t=>t(r)):i[0](r)}};fo=a("__VUE_INSTANCE_SETTERS__",o=>ue=o),os=a("__VUE_SSR_SETTERS__",o=>Ga=o)}const Ha=e=>{const a=ue;return fo(e),e.scope.on(),()=>{e.scope.off(),fo(a)}},Us=()=>{ue&&ue.scope.off(),fo(null)};function Cr(e){return e.vnode.shapeFlag&4}let Ga=!1;function bn(e,a=!1,o=!1){a&&os(a);const{props:s,children:i}=e.vnode,r=Cr(e);Gt(e,s,r,a),Kt(e,i,o||a);const t=r?An(e,a):void 0;return a&&os(!1),t}function An(e,a){const o=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,Tt);const{setup:s}=o;if(s){$e();const i=e.setupContext=s.length>1?En(e):null,r=Ha(e),t=Va(s,e,0,[e.props,i]),n=pi(t);if(Je(),r(),(n||e.sp)&&!Ra(e)&&Wi(e),n){if(t.then(Us,Us),a)return t.then(l=>{Vs(e,l)}).catch(l=>{_o(l,e,0)});e.asyncDep=t}else Vs(e,t)}else Er(e)}function Vs(e,a,o){T(a)?e.type.__ssrInlineRender?e.ssrRender=a:e.render=a:Z(a)&&(e.setupState=Li(a)),Er(e)}function Er(e,a,o){const s=e.type;e.render||(e.render=s.render||we);{const i=Ha(e);$e();try{Rt(e)}finally{Je(),i()}}}const Cn={get(e,a){return ce(e,"get",""),e[a]}};function En(e){const a=o=>{e.exposed=o||{}};return{attrs:new Proxy(e.attrs,Cn),slots:e.slots,emit:e.emit,expose:a}}function Po(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(Li(rt(e.exposed)),{get(a,o){if(o in a)return a[o];if(o in La)return La[o](e)},has(a,o){return o in a||o in La}})):e.proxy}function Dn(e,a=!0){return T(e)?e.displayName||e.name:e.name||a&&e.__name}function _n(e){return T(e)&&"__vccOpts"in e}const Sn=(e,a)=>lt(e,a,Ga);function On(e,a,o){try{mo(-1);const s=arguments.length;return s===2?Z(a)&&!z(a)?po(a)?te(e,null,[a]):te(e,a):te(e,null,a):(s>3?o=Array.prototype.slice.call(arguments,2):s===3&&po(o)&&(o=[o]),te(e,a,o))}finally{mo(1)}}const In="3.5.22";let ss;const Hs=typeof window<"u"&&window.trustedTypes;if(Hs)try{ss=Hs.createPolicy("vue",{createHTML:e=>e})}catch{}const Dr=ss?e=>ss.createHTML(e):e=>e,Mn="http://www.w3.org/2000/svg",Pn="http://www.w3.org/1998/Math/MathML",Ue=typeof document<"u"?document:null,Ks=Ue&&Ue.createElement("template"),qn={insert:(e,a,o)=>{a.insertBefore(e,o||null)},remove:e=>{const a=e.parentNode;a&&a.removeChild(e)},createElement:(e,a,o,s)=>{const i=a==="svg"?Ue.createElementNS(Mn,e):a==="mathml"?Ue.createElementNS(Pn,e):o?Ue.createElement(e,{is:o}):Ue.createElement(e);return e==="select"&&s&&s.multiple!=null&&i.setAttribute("multiple",s.multiple),i},createText:e=>Ue.createTextNode(e),createComment:e=>Ue.createComment(e),setText:(e,a)=>{e.nodeValue=a},setElementText:(e,a)=>{e.textContent=a},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Ue.querySelector(e),setScopeId(e,a){e.setAttribute(a,"")},insertStaticContent(e,a,o,s,i,r){const t=o?o.previousSibling:a.lastChild;if(i&&(i===r||i.nextSibling))for(;a.insertBefore(i.cloneNode(!0),o),!(i===r||!(i=i.nextSibling)););else{Ks.innerHTML=Dr(s==="svg"?`<svg>${e}</svg>`:s==="mathml"?`<math>${e}</math>`:e);const n=Ks.content;if(s==="svg"||s==="mathml"){const l=n.firstChild;for(;l.firstChild;)n.appendChild(l.firstChild);n.removeChild(l)}a.insertBefore(n,o)}return[t?t.nextSibling:a.firstChild,o?o.previousSibling:a.lastChild]}},Ze="transition",Ia="animation",Ua=Symbol("_vtc"),_r={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},zn=ne({},Vi,_r),xn=e=>(e.displayName="Transition",e.props=zn,e),Nn=xn((e,{slots:a})=>On(At,Tn(e),a)),ta=(e,a=[])=>{z(e)?e.forEach(o=>o(...a)):e&&e(...a)},$s=e=>e?z(e)?e.some(a=>a.length>1):e.length>1:!1;function Tn(e){const a={};for(const I in e)I in _r||(a[I]=e[I]);if(e.css===!1)return a;const{name:o="v",type:s,duration:i,enterFromClass:r=`${o}-enter-from`,enterActiveClass:t=`${o}-enter-active`,enterToClass:n=`${o}-enter-to`,appearFromClass:l=r,appearActiveClass:m=t,appearToClass:c=n,leaveFromClass:f=`${o}-leave-from`,leaveActiveClass:C=`${o}-leave-active`,leaveToClass:S=`${o}-leave-to`}=e,x=Rn(i),R=x&&x[0],oe=x&&x[1],{onBeforeEnter:y,onEnter:w,onEnterCancelled:V,onLeave:P,onLeaveCancelled:K,onBeforeAppear:ie=y,onAppear:me=w,onAppearCancelled:be=V}=a,L=(I,X,de,Fe)=>{I._enterCancelled=Fe,na(I,X?c:n),na(I,X?m:t),de&&de()},U=(I,X)=>{I._isLeaving=!1,na(I,f),na(I,S),na(I,C),X&&X()},Q=I=>(X,de)=>{const Fe=I?me:w,re=()=>L(X,I,de);ta(Fe,[X,re]),Js(()=>{na(X,I?l:r),Ge(X,I?c:n),$s(Fe)||Ws(X,s,R,re)})};return ne(a,{onBeforeEnter(I){ta(y,[I]),Ge(I,r),Ge(I,t)},onBeforeAppear(I){ta(ie,[I]),Ge(I,l),Ge(I,m)},onEnter:Q(!1),onAppear:Q(!0),onLeave(I,X){I._isLeaving=!0;const de=()=>U(I,X);Ge(I,f),I._enterCancelled?(Ge(I,C),Qs(I)):(Qs(I),Ge(I,C)),Js(()=>{I._isLeaving&&(na(I,f),Ge(I,S),$s(P)||Ws(I,s,oe,de))}),ta(P,[I,de])},onEnterCancelled(I){L(I,!1,void 0,!0),ta(V,[I])},onAppearCancelled(I){L(I,!0,void 0,!0),ta(be,[I])},onLeaveCancelled(I){U(I),ta(K,[I])}})}function Rn(e){if(e==null)return null;if(Z(e))return[wo(e.enter),wo(e.leave)];{const a=wo(e);return[a,a]}}function wo(e){return xr(e)}function Ge(e,a){a.split(/\s+/).forEach(o=>o&&e.classList.add(o)),(e[Ua]||(e[Ua]=new Set)).add(a)}function na(e,a){a.split(/\s+/).forEach(s=>s&&e.classList.remove(s));const o=e[Ua];o&&(o.delete(a),o.size||(e[Ua]=void 0))}function Js(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let Ln=0;function Ws(e,a,o,s){const i=e._endId=++Ln,r=()=>{i===e._endId&&s()};if(o!=null)return setTimeout(r,o);const{type:t,timeout:n,propCount:l}=yn(e,a);if(!t)return s();const m=t+"end";let c=0;const f=()=>{e.removeEventListener(m,C),r()},C=S=>{S.target===e&&++c>=l&&f()};setTimeout(()=>{c<l&&f()},n+1),e.addEventListener(m,C)}function yn(e,a){const o=window.getComputedStyle(e),s=x=>(o[x]||"").split(", "),i=s(`${Ze}Delay`),r=s(`${Ze}Duration`),t=Zs(i,r),n=s(`${Ia}Delay`),l=s(`${Ia}Duration`),m=Zs(n,l);let c=null,f=0,C=0;a===Ze?t>0&&(c=Ze,f=t,C=r.length):a===Ia?m>0&&(c=Ia,f=m,C=l.length):(f=Math.max(t,m),c=f>0?t>m?Ze:Ia:null,C=c?c===Ze?r.length:l.length:0);const S=c===Ze&&/\b(?:transform|all)(?:,|$)/.test(s(`${Ze}Property`).toString());return{type:c,timeout:f,propCount:C,hasTransform:S}}function Zs(e,a){for(;e.length<a.length;)e=e.concat(e);return Math.max(...a.map((o,s)=>Xs(o)+Xs(e[s])))}function Xs(e){return e==="auto"?0:Number(e.slice(0,-1).replace(",","."))*1e3}function Qs(e){return(e?e.ownerDocument:document).body.offsetHeight}function jn(e,a,o){const s=e[Ua];s&&(a=(a?[a,...s]:[...s]).join(" ")),a==null?e.removeAttribute("class"):o?e.setAttribute("class",a):e.className=a}const go=Symbol("_vod"),Sr=Symbol("_vsh"),Bn={name:"show",beforeMount(e,{value:a},{transition:o}){e[go]=e.style.display==="none"?"":e.style.display,o&&a?o.beforeEnter(e):Ma(e,a)},mounted(e,{value:a},{transition:o}){o&&a&&o.enter(e)},updated(e,{value:a,oldValue:o},{transition:s}){!a!=!o&&(s?a?(s.beforeEnter(e),Ma(e,!0),s.enter(e)):s.leave(e,()=>{Ma(e,!1)}):Ma(e,a))},beforeUnmount(e,{value:a}){Ma(e,a)}};function Ma(e,a){e.style.display=a?e[go]:"none",e[Sr]=!a}const wn=Symbol(""),Fn=/(?:^|;)\s*display\s*:/;function kn(e,a,o){const s=e.style,i=ae(o);let r=!1;if(o&&!i){if(a)if(ae(a))for(const t of a.split(";")){const n=t.slice(0,t.indexOf(":")).trim();o[n]==null&&so(s,n,"")}else for(const t in a)o[t]==null&&so(s,t,"");for(const t in o)t==="display"&&(r=!0),so(s,t,o[t])}else if(i){if(a!==o){const t=s[wn];t&&(o+=";"+t),s.cssText=o,r=Fn.test(o)}}else a&&e.removeAttribute("style");go in e&&(e[go]=r?s.display:"",e[Sr]&&(s.display="none"))}const Ys=/\s*!important$/;function so(e,a,o){if(z(o))o.forEach(s=>so(e,a,s));else if(o==null&&(o=""),a.startsWith("--"))e.setProperty(a,o);else{const s=Gn(e,a);Ys.test(o)?e.setProperty(pa(s),o.replace(Ys,""),"important"):e[s]=o}}const ei=["Webkit","Moz","ms"],Fo={};function Gn(e,a){const o=Fo[a];if(o)return o;let s=Pe(a);if(s!=="filter"&&s in e)return Fo[a]=s;s=Ao(s);for(let i=0;i<ei.length;i++){const r=ei[i]+s;if(r in e)return Fo[a]=r}return a}const ai="http://www.w3.org/1999/xlink";function oi(e,a,o,s,i,r=jr(a)){s&&a.startsWith("xlink:")?o==null?e.removeAttributeNS(ai,a.slice(6,a.length)):e.setAttributeNS(ai,a,o):o==null||r&&!hi(o)?e.removeAttribute(a):e.setAttribute(a,r?"":aa(o)?String(o):o)}function si(e,a,o,s,i){if(a==="innerHTML"||a==="textContent"){o!=null&&(e[a]=a==="innerHTML"?Dr(o):o);return}const r=e.tagName;if(a==="value"&&r!=="PROGRESS"&&!r.includes("-")){const n=r==="OPTION"?e.getAttribute("value")||"":e.value,l=o==null?e.type==="checkbox"?"on":"":String(o);(n!==l||!("_value"in e))&&(e.value=l),o==null&&e.removeAttribute(a),e._value=o;return}let t=!1;if(o===""||o==null){const n=typeof e[a];n==="boolean"?o=hi(o):o==null&&n==="string"?(o="",t=!0):n==="number"&&(o=0,t=!0)}try{e[a]=o}catch{}t&&e.removeAttribute(i||a)}function va(e,a,o,s){e.addEventListener(a,o,s)}function Un(e,a,o,s){e.removeEventListener(a,o,s)}const ii=Symbol("_vei");function Vn(e,a,o,s,i=null){const r=e[ii]||(e[ii]={}),t=r[a];if(s&&t)t.value=s;else{const[n,l]=Hn(a);if(s){const m=r[a]=Jn(s,i);va(e,n,m,l)}else t&&(Un(e,n,t,l),r[a]=void 0)}}const ri=/(?:Once|Passive|Capture)$/;function Hn(e){let a;if(ri.test(e)){a={};let s;for(;s=e.match(ri);)e=e.slice(0,e.length-s[0].length),a[s[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):pa(e.slice(2)),a]}let ko=0;const Kn=Promise.resolve(),$n=()=>ko||(Kn.then(()=>ko=0),ko=Date.now());function Jn(e,a){const o=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=o.attached)return;xe(Wn(s,o.value),a,5,[s])};return o.value=e,o.attached=$n(),o}function Wn(e,a){if(z(a)){const o=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{o.call(e),e._stopped=!0},a.map(s=>i=>!i._stopped&&s&&s(i))}else return a}const ti=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,Zn=(e,a,o,s,i,r)=>{const t=i==="svg";a==="class"?jn(e,s,t):a==="style"?kn(e,o,s):vo(a)?rs(a)||Vn(e,a,o,s,r):(a[0]==="."?(a=a.slice(1),!0):a[0]==="^"?(a=a.slice(1),!1):Xn(e,a,s,t))?(si(e,a,s),!e.tagName.includes("-")&&(a==="value"||a==="checked"||a==="selected")&&oi(e,a,s,t,r,a!=="value")):e._isVueCE&&(/[A-Z]/.test(a)||!ae(s))?si(e,Pe(a),s,r,a):(a==="true-value"?e._trueValue=s:a==="false-value"&&(e._falseValue=s),oi(e,a,s,t))};function Xn(e,a,o,s){if(s)return!!(a==="innerHTML"||a==="textContent"||a in e&&ti(a)&&T(o));if(a==="spellcheck"||a==="draggable"||a==="translate"||a==="autocorrect"||a==="form"||a==="list"&&e.tagName==="INPUT"||a==="type"&&e.tagName==="TEXTAREA")return!1;if(a==="width"||a==="height"){const i=e.tagName;if(i==="IMG"||i==="VIDEO"||i==="CANVAS"||i==="SOURCE")return!1}return ti(a)&&ae(o)?!1:a in e}const ni=e=>{const a=e.props["onUpdate:modelValue"]||!1;return z(a)?o=>Ya(a,o):a};function Qn(e){e.target.composing=!0}function di(e){const a=e.target;a.composing&&(a.composing=!1,a.dispatchEvent(new Event("input")))}const Go=Symbol("_assign"),Yn={created(e,{modifiers:{lazy:a,trim:o,number:s}},i){e[Go]=ni(i);const r=s||i.props&&i.props.type==="number";va(e,a?"change":"input",t=>{if(t.target.composing)return;let n=e.value;o&&(n=n.trim()),r&&(n=Vo(n)),e[Go](n)}),o&&va(e,"change",()=>{e.value=e.value.trim()}),a||(va(e,"compositionstart",Qn),va(e,"compositionend",di),va(e,"change",di))},mounted(e,{value:a}){e.value=a??""},beforeUpdate(e,{value:a,oldValue:o,modifiers:{lazy:s,trim:i,number:r}},t){if(e[Go]=ni(t),e.composing)return;const n=(r||e.type==="number")&&!/^0\d/.test(e.value)?Vo(e.value):e.value,l=a??"";n!==l&&(document.activeElement===e&&e.type!=="range"&&(s&&a===o||i&&e.value.trim()===l)||(e.value=l))}},ed=ne({patchProp:Zn},qn);let li;function ad(){return li||(li=Jt(ed))}const od=((...e)=>{const a=ad().createApp(...e),{mount:o}=a;return a.mount=s=>{const i=id(s);if(!i)return;const r=a._component;!T(r)&&!r.render&&!r.template&&(r.template=i.innerHTML),i.nodeType===1&&(i.textContent="");const t=o(i,!1,sd(i));return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),t},a});function sd(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function id(e){return ae(e)?document.querySelector(e):e}const rd="/tcc-bcc-2025/logo-unesp.svg",td="/tcc-bcc-2025/logo-fc.jpg",nd="/tcc-bcc-2025/logo-dco.gif",dd="/tcc-bcc-2025/logo-bcc.png",ld="/tcc-bcc-2025/logo-bsi.png",Ka=(e,a)=>{const o=e.__vccOpts||e;for(const[s,i]of a)o[s]=i;return o},cd={props:["titulo","subtitulo"]},ud={class:"header-bg"},md={class:"header-content"},pd={class:"text-center"};function fd(e,a,o,s,i,r){return ee(),se("header",ud,[j("div",md,[j("div",pd,[j("h1",null,le(o.titulo),1),j("p",null,le(o.subtitulo),1)]),a[0]||(a[0]=pn('<div class="logos-bottom" data-v-6901c242><img src="'+rd+'" alt="UNESP - Universidade Estadual Paulista" class="logo-unesp" data-v-6901c242><img src="'+td+'" alt="Faculdade de Cincias" class="logo-faculdade" data-v-6901c242><img src="'+nd+'" alt="DCO - Departamento de Computao" class="logo-dco" data-v-6901c242><img src="'+dd+'" alt="BCC - Bacharelado em Cincia da Computao" class="logo-curso" data-v-6901c242><img src="'+ld+'" alt="BSI - Bacharelado em Sistemas de Informao" class="logo-curso" data-v-6901c242></div>',1))])])}const gd=Ka(cd,[["render",fd],["__scopeId","data-v-6901c242"]]),vd={name:"TccLink",props:{link:{type:Object,required:!0,validator(e){return e.label!==void 0}}},computed:{mensagemIndisponivel(){return"Arquivo ser disponibilizado aps a apresentao do TCC"}}},hd={class:"tcc-link-wrapper"},bd=["href","aria-label"],Ad={class:"link-text"},Cd=["title"],Ed={class:"link-text"};function Dd(e,a,o,s,i,r){return ee(),se("div",hd,[o.link.url?(ee(),se("a",{key:0,href:o.link.url,target:"_blank",class:"tcc-link","aria-label":`${o.link.label} do trabalho`},[j("span",Ad,le(o.link.label),1)],8,bd)):(ee(),se("button",{key:1,class:"tcc-link tcc-link-disabled",disabled:"",title:r.mensagemIndisponivel},[j("span",Ed,le(o.link.label),1),a[0]||(a[0]=j("span",{class:"lock-icon"},"",-1))],8,Cd))])}const _d=Ka(vd,[["render",Dd],["__scopeId","data-v-04fe568d"]]),Sd={name:"TccItem",components:{TccLink:_d},props:{tcc:{type:Object,required:!0},isOpen:{type:Boolean,default:!1}},computed:{hasIndisponivel(){return this.tcc.links&&this.tcc.links.some(e=>!e.url)}},methods:{toggle(){this.$emit("toggle")},formatarData(e){return new Date(e).toLocaleDateString("pt-BR",{year:"numeric",month:"long",day:"numeric"})},getCursoCompleto(e){return{BCC:"Bacharelado em Cincia da Computao",BSI:"Bacharelado em Sistemas de Informao"}[e]||e}}},Od={class:"tcc-item"},Id={class:"tcc-content"},Md={class:"tcc-info"},Pd={class:"info-row"},qd={class:"info-row"},zd={class:"info-row"},xd={key:0,class:"info-row"},Nd={class:"tcc-description"},Td={key:0,class:"keywords"},Rd={class:"keywords-list"},Ld={key:1,class:"tcc-links"},yd={class:"links-grid"},jd={key:0,class:"info-message"};function Bd(e,a,o,s,i,r){const t=co("TccLink");return ee(),se("div",Od,[j("div",{class:"tcc-header",onClick:a[0]||(a[0]=(...n)=>r.toggle&&r.toggle(...n))},[j("h2",null,le(o.tcc.titulo),1),j("span",{class:Eo(["toggle-icon",{rotated:o.isOpen}])},"",2)]),te(Nn,{name:"slide-fade"},{default:ki(()=>[Gi(j("div",Id,[j("div",Md,[j("div",Pd,[a[1]||(a[1]=j("strong",null,"Curso:",-1)),qa(" "+le(r.getCursoCompleto(o.tcc.curso)),1)]),j("div",qd,[a[2]||(a[2]=j("strong",null,"Autor:",-1)),qa(" "+le(o.tcc.autor),1)]),j("div",zd,[a[3]||(a[3]=j("strong",null,"Orientador:",-1)),qa(" "+le(o.tcc.orientador),1)]),o.tcc.dataDefesa?(ee(),se("div",xd,[a[4]||(a[4]=j("strong",null,"Data de Defesa:",-1)),qa(" "+le(r.formatarData(o.tcc.dataDefesa)),1)])):Ye("",!0)]),j("div",Nd,[j("p",null,le(o.tcc.descricao),1)]),o.tcc.palavrasChave&&o.tcc.palavrasChave.length?(ee(),se("div",Td,[a[5]||(a[5]=j("strong",null,"Palavras-chave:",-1)),j("div",Rd,[(ee(!0),se(Se,null,Xo(o.tcc.palavrasChave,n=>(ee(),se("span",{key:n,class:"keyword-tag"},le(n),1))),128))])])):Ye("",!0),o.tcc.links&&o.tcc.links.length?(ee(),se("div",Ld,[a[7]||(a[7]=j("strong",null,"Recursos disponveis:",-1)),j("div",yd,[(ee(!0),se(Se,null,Xo(o.tcc.links,n=>(ee(),As(t,{key:n.label,link:n},null,8,["link"]))),128))]),r.hasIndisponivel?(ee(),se("div",jd,[...a[6]||(a[6]=[j("span",null,"Os arquivos sero disponibilizados aps a apresentao do TCC",-1)])])):Ye("",!0)])):Ye("",!0)],512),[[Bn,o.isOpen]])]),_:1})])}const wd=Ka(Sd,[["render",Bd],["__scopeId","data-v-1b57329a"]]),Fd="/tcc-bcc-2025";function kd(e){return`${Fd}${e}`}const ci={monografias:"/files/monografias/",apresentacoes:"/files/apresentacoes/"};function p(e,a){const o=e==="monografia"?ci.monografias:ci.apresentacoes;return kd(`${o}${a}`)}const Es=[{id:202501,titulo:"Anlise de acidente de trnsito em Bauru-SP utilizando cincia de dados",autor:"Bruno Shinji Ito",orientador:"Dr Higor Amario de Souza",curso:"BCC",descricao:"Os acidentes de trnsito representam um grande problema social e econmico no ambiente urbano, no sendo diferente no municpio de Bauru. Compreender os fatores e perfis de vtimas que so mais suscetveis s fatalidades pode auxiliar no direcionamento de recursos a fim de mitigar a ocorrncia de mais bitos. O seguinte trabalho busca realizar a anlise da ocorrncia dos sinistros em Bauru utilizando as metodologias e tcnicas de Cincia de Dados. Para o estudo foram usados dados pblicos de sinistros e vtimas de Infosiga do perodo de 20192025. Para previso foram testados os algoritmos de rvore de Deciso e XGBoost, realizando comparao no potencial de previso de cada modelo, alm da realizao da Anlise Exploratria de Dados e utilizao de DBSCAN. Os modelos apresentaram capacidade de predio satisfatrias, em especial o modelo de XGBoost com a tcnica de Grid Search. Tcnicas de DBSCAN apontam hotspots as principais vias da cidade e as rodovias ao redor da cidade como maior causadoras de vtimas no fatais e fatais, respectivamente.",palavrasChave:["Acidente de trnsito","Aprendizado de mquina","Cincia de dados","XGBoost","DBSCAN","Bauru"],dataDefesa:"2025-11-12",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202502,titulo:"Modelos de aprendizado de mquina baseados em kernel para anlise de sobrevivncia",autor:"Christian Laurence Almeida Barry",orientador:["Prof. Dr. Joo Paulo Papa","Danilo Samuel Jodas"],curso:"BCC",descricao:`A anlise de sobrevivncia  um ramo da estatstica essencial para a anlise de dados de tempo at o evento, porm, mtodos tradicionais tm dificuldade com dados complexos e no-lineares. Nesse paradigma, os modelos de aprendizado de mquina
surgiram como solues consolidadas para melhorar a anlise de sobrevivncia. No
entanto, tais mtodos exigem cuidadosa otimizao de hiperparmetros, um processo
computacionalmente intensivo que dificulta implementaes prticas. Esse trabalho
enfrenta essas limitaes ao propor trs novos estimadores baseados em kernels
desenvolvidos a partir da integrao do estimador de Beran com dois algoritmos no-
paramtricos do aprendizado de mquina: uma variao no-paramtrica do algoritmo
de  vizinhos mais prximos (NN) e o NN-supervised Optimum-Path Forest (OPF-
NN). Ambos os mtodos aprendem automaticamente o nmero timo de vizinhos
ao longo de suas execues, no caso do OPF-NN, at um nmero mximo definido
manualmente, evitando a maior parte do ajuste paramtrico. Atravs de uma avaliao
abrangente em trs conjuntos de amostras, um de Downhole Safety Valves empregadas
em poos de petrleo, outro de pacientes sendo tratados para insuficincia cardaca e, o
terceiro, de pacientes passando por tratamento para cncer de prstata, foi constatado
que os modelos desenvolvidos se aproximam ou superam a capacidade preditiva de
modelos tradicionais dependentes de hiperparmetros, caracterizando ferramentas
robustas para anlise de sobrevivncia que lidam efetivamente com distribuies
complexas e no-lineares sem requerer calibrao especfica para cada conjunto de
dados.
`,palavrasChave:["Estimador de Beran","Anlise de Sobrevivncia","Anlise de Confiabilidade","Confiabilidade para Engenharia","Hiperparmetros","Aprendizado de Mquina"],dataDefesa:"2025-11-10",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202503,titulo:"Construo e traduo de datasets multimodais na sade: um estudo para casos de covid-19",autor:"Daniel Hideki Rocha Kanashiro",orientador:["Dr. Joo Paulo Papa","Dr. Gabriel Lino Garcia"],curso:"BCC",descricao:"A covid-19  uma doena de fcil transmisso e capaz de deixar sequelas em seus infectados. Com o devido tratamento e diagnstico precoce, as chances de sequelas e sintomas graves caem. Algumas estratgias so utilizadas para a celeridade da deteco, dentre elas, modelos de Aprendizado de Mquina treinados para avaliar unicamente imagem de raio-X, por exemplo, e realizar o diagnstico baseado na imagem. J os Grandes Modelos de Linguagem Multimodais so capazes de compreender dados de modalidades diferentes conjuntamente, como imagem e texto. Neste trabalho, prope-se avaliar o uso de multimodalidade para diagnstico de covid-19 e a averiguao do impacto que a multimodalidade causa no resultado obtido. Para isso, foi traduzido um dataset multimodal de covid-19 e avaliado o desempenho de dois modelos foram treinados neste dataset.",palavrasChave:["Multimodal","covid-19","VLM","Aprendizado de Mquina"],dataDefesa:"2025-11-11",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202504,titulo:"Aprendizado de mquina aplicado  quantificao do ndice de proliferao em osteossarcomas caninos",autor:"Eduardo Alvaro Monteiro",orientador:"Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"O osteossarcoma canino  uma das neoplasias sseas mais agressivas na espcie, cujo prognstico  frequentemente avaliado pelo ndice de proliferao celular atravs do marcador imuno-histoqumico Ki-67. A obteno deste ndice depende da contagem manual de clulas em lminas histopatolgicas, um processo tradicionalmente laborioso, repetitivo e sujeito a elevada variabilidade inter e intraobservador. O advento da patologia digital permitiu o desenvolvimento de ferramentas computacionais para superar essas limitaes. Neste contexto, o presente trabalho tem como objetivo propor e validar uma rotina computacional para a segmentao e contagem automatizada de clulas em proliferao e clulas saudveis em imagens histolgicas, visando a obteno do ndice de proliferao celulaar. A metodologia proposta explora duas abordagens distintas: o desenvolvimento de uma pipeline baseada em tcnicas clssicas de processamento de imagens, e, para fins comparativos, o desenvolvimento de um modelo de aprendizado profundo baseado em Redes Neurais Convolucionais. Para viabilizar o estudo, foi criada uma base de dados de lminas digitalizadas e anotadas por patologistas especialistas.",palavrasChave:["Osteossarcoma Canino","Aprendizado de Mquina","ndice de Proliferao","Ki-67","Processamento de Imagens","Patologia Digital","Segmentao"],dataDefesa:"2025-11-14",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202505,titulo:"Avaliao da viabilidade de Spiking Neural Networks em dispositivos mveis para diagnstico de cncer de pele",autor:"Fbio Halben Guerra Leal",orientador:"Dr. Leandro Aparecido Passos Junior",curso:"BCC",descricao:`Este trabalho investiga a viabilidade de Spiking Neural Networks (SNNs) em disposi-
tivos mveis para apoio ao diagnstico de cncer de pele, comparando-as com uma
arquitetura convolucional convencional (CNN) em condies controladas. Utilizou-se
um conjunto de dados derivado da ISIC, disponvel no Kaggle, estratificado em treino
(5.000 benignas e 4.605 malignas) e teste (500/500), com pr-processamento padroni-
zado (redimensionamento para 224224, converso para tons de cinza e normalizao
em [0,1]). A CNN, inspirada na AlexNet, foi treinada por 20 pocas com seleo do
melhor ponto via F1-macro, seu desempenho no teste atingiu acurcia de 90,6%, com
preciso e recall prximos de 0,9, e teve o gasto energtico medido com o Zeus. A
SNN espelhou a arquitetura da CNN, substituindo ativaes por camadas LIF ( = 0, 8)
ao longo de 10 time steps e treinada com surrogate gradients, no teste, obteve 89,3%
de acurcia e F1=0,8997 ( 1, 3 p.p. abaixo da CNN).Quanto  energia, registrou-se na CNN um gasto de  25.300 J durante o treinamento
e  111 J durante a fase de testes. A SNN no foi medida no hardware convencional,
pois seus ganhos se manifestam sobretudo em hardware neuromrfico, no qual a
literatura sugere economia de 68 frente  CNN. Em sntese, os resultados indicam
que SNNs so tecnicamente viveis quando a restrio energtica  crtica e h acesso
a hardware neuromrfico, embora persista um pequeno decrscimo de acurcia e
desafios de engenharia.

`,palavrasChave:["Spiking Neural Networks","Convolutional Neural Networks","Redes Neurais Artificiais","diagnstico mdico","cncer de pele","dispositivos mveis","eficincia energtica"],dataDefesa:"2025-11-11",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202506,titulo:"Investigao de estratgias de aprendizado contnuo para deteco de objetos de trfego urbano",autor:"Gabriel Cardoso Franco",orientador:"Dr. Andr Luis Debiasso Rossi",curso:"BCC",descricao:"Com o avano das Redes Neurais Convolucionais (CNNs), multiplicaram-se as aplicaes em modelos de linguagem, viso computacional e anlise de vdeos. Apesar desse progresso, o esquecimento catastrfico continua como um problema que dificulta o aprendizado contnuo e, na prtica, leva ao retreinamento do zero sempre que novas tarefas, classes ou domnios so introduzidos. Essa estratgia  cara e ineficiente, principalmente quando j existem mtodos capazes de mitigar tal efeito no paradigma de aprendizado contnuo. Neste trabalho,  analisado o impacto do uso de tcnicas de aprendizado contnuo no treinamento de CNNs para deteco de objetos no contexto de trfego urbano",palavrasChave:["aprendizado contnuo","esquecimento catastrfico","deteco de objetos","redes neurais convolucionais","aprendizado profundo","trfego urbano"],dataDefesa:"2025-11-14",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202507,titulo:"Aplicao de aprendizado de mquina e equilbrio de Nash no jogo de pquer",autor:"Gabriel Jooji Yamashiro",orientador:"Dr. Leandro Aparecido Passos Junior",curso:"BCC",descricao:"O pquer Heads-Up No-Limit Texas Holdem, por ser um jogo de informao imperfeita, apresenta um desafio complexo para a inteligncia artificial devido  sua vasta combinatria, alm de elementos como blefe e adaptao ao oponente. Este trabalho prope um agente de IA que integra o algoritmo Counterfactual Regret Minimization (CFR) para aproximar o Equilbrio de Nash aliado a tcnicas de aprendizado de mquina para abstraes de cartas e aes. As abstraes foram realizadas por agrupamento de dados usando o K-Means, baseado em distribuies de equidade, gerando 169 grupos no pr-flop, 50 no flop, 100 no turn e 200 no river. Um dataset do tamanho de 1 milho de mos foi treinado de forma offline, com treinamentos separados para pr-flop e ps-flop. O agente foi avaliado contra o Slumbot em cerca de 10.000 mos, registrando perdas de -41.47 Big Blind a cada 100 mos (BB/100) (Dataset de 250.000 mos), -32.125 BB/100 (Dataset de 500.000 mos), -47.025 BB/100 (Dataset de 750.000 mos) e -47.19 BB/100 (Dataset de 1.000.000 mos). Apesar da no linearidade dos resultados, possivelmente devido  alta varincia no pquer, a estratgia CFR superou consistentemente heursticas predefinidas, exibindo perdas menores em todos os testes. A implementao demonstrou viabilidade em hardware modesto, contribuindo para avanos em jogos de informao imperfeita e teoria dos jogos.",palavrasChave:["Pquer","Inteligncia Artificial","CFR","Equilbrio de Nash","Abstrao","Agrupamento de dados"],dataDefesa:"2025-11-11",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202508,titulo:"Utilizao de algoritmos biologicamente plausveis no auxlio de diagnstico de infeces fngicas e neoplasias pulmonares em exames de raio-X",autor:"Giuliano Gonzales",orientador:"Dr. Leandro Aparecido Passos Junior",curso:"BCC",descricao:"Este trabalho investiga a aplicao de algoritmos biologicamente plausveis, com nfase em Redes Neurais de Picos (SNNs, do ingls Spike Neural Networks), no auxlio ao diagnstico de infeces fngicas e neoplasias pulmonares em imagens de raio-X. O estudo compara o desempenho e a eficincia energtica de diferentes arquiteturas de redes neurais, incluindo Redes Neurais Artificiais, Redes Neurais Convolucionais, e SNNs, utilizando subconjuntos do banco de dados NIH Chest X-rays. As redes foram avaliadas em tarefas de classificao multiclasse (Normal, Infeco e Neoplasia) e binria (Normal vs. Infeco), a partir de mtricas de acurcia, preciso, recall e F1-score, alm do consumo energtico medido com a ferramenta Carbontracker. Os resultados indicam que a verso convolucional da SNN apresenta desempenho competitivo em acurcia (at 79%) e F1-score (em torno de 60%), enquanto a SNN no convolucional destaca-se pela elevada eficincia energtica, com esparcidade superior a 90% em determinadas camadas e consumo significativamente inferior ao de arquiteturas convencionais. Conclui-se que os modelos de redes neurais que utilizam picos representam uma alternativa promissora para aplicaes mdicas em contextos com restries computacionais e energticas, conciliando sustentabilidade e viabilidade diagnstica.",palavrasChave:["Redes neurais de picos","diagnstico por imagem","eficincia energtica","aprendizado de mquina","doenas pulmonares"],dataDefesa:"2025-11-13",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202509,titulo:"Colhendo insights: anlise de dados na produo de cana-de-acar",autor:"Guilherme Lima Zanin",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:`A cana-de-acar ocupa posio central na economia brasileira, consolidando o pas como o maior produtor mundial dessa cultura. Apesar de sua relevncia, a produtividade ainda enfrenta entraves relacionados ao manejo nutricional do solo, principalmente pela ausncia de controle preciso sobre as quantidades ideais de nutrientes necessrios ao desenvolvimento da lavoura. Essa falta de preciso faz com que muitos produtores deixem de alcanar o potencial produtivo de suas reas, resultando em menor rentabilidade e uso ineficiente de insumos. Nesse cenrio, a
cincia de dados surge como um recurso estratgico para apoiar a gesto agrcola, permitindo identificar padres ocultos, analisar correlaes entre nutrientes e fornecer recomendaes mais assertivas para o manejo da fertilizao. Este trabalho tem como objetivo aplicar tcnicas de anlise de dados para estudar as relaes entre os nutrientes presentes no solo e a produtividade da cana-de-acar. A pesquisa concentrou-se na coleta, organizao e tratamento de dados nutricionais, seguida de anlises estatsticas e exploratrias. Em seguida, foram desenvolvidos e avaliados modelos preditivos supervisionados, com destaque para a regresso, visando estimar a influncia de nutrientes especficos e oferecer insights que apoiem prticas de fertilizao
mais eficientes. Os resultados esperados incluem a definio mais precisa das quantidades de nutrientes necessrias,  maximizao da produtividade agrcola, a reduo de desperdcios e a promoo de prticas mais sustentveis. Ao integrar cincia de dados ao manejo nutricional da cana-de-acar, este estudo busca oferecer subsdios tcnicos que auxiliem a tomada de deciso dos produtores rurais, fomentem a agricultura de preciso e impulsionam a competitividade do setor sucroenergtico no Brasil.
`,palavrasChave:["Cincia de Dados","Cana-de-Acar","Nutrientes do Solo","Modelos Preditivos","Agricultura de Preciso"],dataDefesa:"2025-11-13",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202510,titulo:"Utilizando cincia de dados para identificar melhorias na infraestrutura urbana para pedestres",autor:"Gustavo Ribeiro Montes",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O presente trabalho utiliza tcnicas da Cincia de Dados para analisar padres de mobilidade urbana sustentvel, com nfase nos deslocamentos realizados a p na cidade de So Paulo, visando apoiar a formulao de polticas pblicas mais efetivas. A partir das bases abertas da Pesquisa Origem e Destino (OD) 2023 e do portal GeoSampa, foram aplicadas tcnicas de anlise estatstica descritiva e anlise exploratria de dados espaciais (AEDE) para identificar padres de mobilidade e relaes entre caractersticas socioeconmicas, distribuio territorial e infraestrutura urbana. As anlises revelaram disparidades na distribuio das viagens a p entre diferentes regies e grupos populacionais, destacando a influncia de fatores econmicos, educacionais e estruturais na escolha pelo deslocamento pedestre. Alm disso, as anlises geoespaciais permitiram mapear zonas com elevada concentrao de pedestres, indicando reas prioritrias para intervenes pblicas. Os resultados destacam a relevncia da mobilidade ativa para o desenvolvimento urbano sustentvel e evidenciam como abordagens baseadas em dados podem auxiliar decises mais eficazes no planejamento de cidades mais acessveis e inclusivas.",palavrasChave:["Cincia de Dados","Mobilidade Ativa","Pedestres","Polticas Pblicas"],dataDefesa:"2025-11-12",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202511,titulo:"Explorando algoritmos de compresso de dados: teoria, implementao e desempenho",autor:"GUSTAVO YUJII SILVA KADOOKA",orientador:"Profa. Dra. Andra Carla Gonalves Vianna",curso:"BCC",descricao:"Este trabalho apresenta um estudo terico e prtico sobre algoritmos clssicos de compresso de dados sem perdas  Huffman, LZ77, LZW e GZIP , explorando seus fundamentos, implementaes e desempenho. A pesquisa visa compreender o comportamento desses algoritmos em diferentes tipos de dados (texto, imagem e udio), analisando sua eficincia quanto  taxa de compresso e ao tempo de execuo. As implementaes foram desenvolvidas em C++, com suporte a arquivos nos formatos .txt, .bmp e .wav, e integradas a uma interface grfica construda com a biblioteca GTK, permitindo ao usurio selecionar o algoritmo e o arquivo de entrada de forma interativa. Para a anlise comparativa, foram utilizados scripts em Python para processamento estatstico e gerao de grficos. Os resultados demonstram que no existe um algoritmo universalmente superior: cada mtodo apresenta vantagens especficas conforme as caractersticas do arquivo. Assim, a escolha do algoritmo mais adequado depende do tipo de dado e do contexto de uso. O trabalho contribui com uma ferramenta prtica e um recurso educacional que facilita o entendimento da compresso de dados e de seus princpios tericos.",palavrasChave:["Compresso de dados","Algoritmos de compresso","Huffman","LZ77","LZW","GZIP","C++","Python","GTK"],dataDefesa:"2025-11-12",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202512,titulo:"Adaptao do envenenamento Nightshade para arquivos de udio",autor:"Henrique Trivelato de Angelo",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Este trabalho propre uma adaptao do envenenamento Nightshade para expandir sua atuao no campo dos udios.  proposta a substituio do modelo CLIP pelo modelo CLAP para a criao aleatria de uma amostra de treinamento de udios envenenados, a troca do modelo de difuso TTI Stable Diffusion pelo StyleTTS 2, um modelo de difuso TTS, com a finalidade de gerar udios ncoras, o passo a passo para que o envenenamento direcionado ocorra no espectograma de log-mel de um udio e, por fim, a adoo do mtodo de Griffin-Lim para retornar os espectogramas envenenados  sua forma de onda correspondente. Utiliza-se o Command Speech para a elaborao de ataques direcionados no StyleTTS 2. Os resultados obtidos pela aplicao de um questionrio online mostram que a adaptao no  capaz de efetuar um ataque direcionado e furtivo, pelo contrrio, o fine-tuning do StyleTTS 2 com amostras de treinamento com 5 minutos de udios envenenados torna o modelo capaz apenas de produzir udios incompreensveis ao custo de ser facilmente identificado por avaliao humana, visto que o algoritmo de Griffin-Lim exacerba as perturbaes adversariais j inseridas no espectrogram.",palavrasChave:["udio","Envenenamento","Texto para fala","Nightshade","Espectograma de Log-Mel","CLAP","Griffim-Lin"],dataDefesa:"2025-11-13",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202513,titulo:"Aplicao de dados geoespaciais na anlise de risco e suporte  contratao de seguro agrcola",autor:"Joo Lucas Cardoso Criveli",orientador:"Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"A agricultura , e por muito tempo ser, um meio primordial para que o ser humano consiga produzir insumos, fornecer alimentos e dar uso ao solo que habita. Dada essa importncia, o setor agrcola busca diversos meios para garantir sua produo esperada, sendo um deles o seguro agrcola - modalidade de proteo financeira que estabelece acordos entre produtores rurais e seguradoras para garantir cobertura de ao menos parte da produo agrcola em caso de sinistros. Para viabilizar esses acordos, surge a figura da corretora de seguros, que conecta o produtor rural s seguradoras, e, neste processo, assume uma tarefa desafiadora: a avaliao de riscos para subsidiar a tomada de deciso das seguradoras. So diversos os fatores que o corretor deve analisar antes de enviar seu parecer, desde riscos que a localizao da propriedade do produtor pode oferecer at as pendncias fiscais que o interessado pelo seguro pode vir a ter. O processo torna-se particularmente desafiador quando cada verificao deve ser realizada em plataformas distintas e descentralizadas: websites governamentais, sistemas de anlise de portarias, softwares especializados e bases de dados diversas. Com o propsito de otimizar e centralizar o processo de anlise de risco, este projeto teve como objetivo desenvolver uma aplicao web que unifica todas as verificaes necessrias em uma nica plataforma. O desenvolvimento contou com o suporte de uma corretora de seguros parceira, que auxiliou revelando a rotina operacional, destacando dificuldades nos processos requeridos em uma anlise de risco e providenciando dados para o treinamento de modelos de inteligncia artificial. Ao final do desenvolvimento, esses objetivos foram atendidos e a ferramenta conseguiu reduzir para menos de 20 segundos o tempo necessrio para se ter uma anlise de risco completa. Esta otimizao no apenas tornou o trabalho das corretoras mais eficiente e preciso, mas tambm contribuiu para facilitar o acesso dos produtores rurais ao seguro agrcola, promovendo maior segurana e sustentabilidade no setor.",palavrasChave:["Seguro Agrcola","Anlise de risco","Inteligncia Artificial","Banco de dados espacial","Aplicao Web"],dataDefesa:"2025-11-12",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202514,titulo:"Reduo de rudo em imagens via geometria fractal",autor:"Leonardo Koosuke Azuma",orientador:"Dra. Tatiana Miguel Rodrigues",curso:"BCC",descricao:"O objetivo deste estudo  realizar de reduo de rudo em imagens via Geometria Fractal atravs de uma modificao na etapa de identificao dos blocos mais semelhantes em uma imagem, substituindo a mtrica original, o Erro Mdio Quadrtico (MSE), pelo ndice de Similaridade Estrutural (SSIM), e comparar os resultados obtidos com o algoritmo original e com o mtodo Block Matching and 3D Filtering (BM3D). Para isso, foram realizados experimentos com diferentes tipos e intensidades de rudo aplicados a diversas imagens, e para quantificar a qualidade das imagens restauradas foram utilizadas as mtricas MSE, PSNR e SSIM. Os resultados demonstram que a substituio do MSE pelo SSIM no melhora o desempenho do algoritmo fractal, apresentando, em alguns casos, leve perda de qualidade na restaurao das imagens. O algoritmo BM3D apresentou desempenho superior em quase todos os testes, confirmando sua robustez e eficincia. No entanto, conclui-se que o mtodo fractal ainda possui potencial, especialmente se forem exploradas formas mais eficazes de obteno do Sistema de Funes Iteradas (IFS).",palavrasChave:["Reduo de rudo","Geometria Fractal","IFS"],dataDefesa:"2025-11-17",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202515,titulo:"Aplicao de ferramentas de inteligncia artificial na animao de componentes em um jogo 2D voltado  sade mental",autor:"Luana Rodrigues da Silva e Lima",orientador:"Dra. Juliana da Costa Feitosa",curso:"BCC",descricao:"A sade mental  extremamente importante para todos, porm frequentemente recebe respostas inadequadas e  representada por meio de estigmas em mdias como jogos digitais. Paralelamente, a aplicao de Inteligncia Artificial (IA), especificamente na animao 2D, permanece pouco explorado. O presente trabalho visa abordar esses dois temas a partir do desenvolvimento de um prottipo de jogo srio 2D que explora temas relacionados a sade mental de forma responsvel, e da anlise comparativa de ferramentas de IA para auxiliar no processo de criao de animaes 2D pixel art para o jogo. A anlise revelou que nenhuma ferramenta individual gerou animaes perfeitas sem edio manual. Ferramentas generalistas avanadas (e.g., Gemini Pro, Vidu) mostraram alta consistncia, mas tambm apresentaram dificuldades com especificidades do 2D e da pixel art, enquanto ferramentas especializadas (e.g., Pixel Lab, Pixie.haus) aderiram melhor ao estilo, porm com menor desenvolvimento geral ou flexibilidade. Os resultados mostraram que a IA funciona melhor como ferramenta auxiliar para o animador, sendo crucial a integrao de editores robustos para ajustes da animao criada.",palavrasChave:["Inteligncia Artificial","Animao 2D","Jogos Srios","desenvolvimento de jogos"],dataDefesa:"2025-11-13",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202516,titulo:"Tutor de IA conversacional para o aprendizado de ingls",autor:"Luis Felipe Muniz de Angelo",orientador:"Dr. Joo Paulo Papa",curso:"BCC",descricao:"Este trabalho apresenta o desenvolvimento de um tutor de inteligncia artificial conversacional para o aprendizado de ingls, focado em falantes de portugus. O projeto aborda as limitaes das abordagens puramente neurais no ensino , que carecem de preciso e personalizao, bem como o alto custo e latncia da arquitetura multiagente tradicional. A soluo proposta  uma arquitetura composta por um pipeline  de processamento em camadas implementado em LangGraph para anlise gramatical, e um agente central unificado (AFM) que adota o paradigma Chain-of-Agents (CoA). Este agente simula internamente a colaborao de mltiplos agentes com diferentes papis a fim de estabelecer raciocnios complexos com eficincia. O sistema integra tanto ferramentas simblicas como o LanguageTool para validao gramatical determinstica, quanto neurais para anlise semntica, sendo implementado como um aplicativo mvel cliente usando React Native, e servidor em FastAPI. A eficincia da arquitetura foi validada frente os pilares do framework OAgents e como resultado o trabalho entrega uma ferramenta pedaggica de baixa latncia e com menor custo do que a abordagem multiagente tradicional, sendo capaz de oferecer correes instantneas, proporcionando um ambiente seguro para a prtica conversacional.",palavrasChave:["Inteligncia artificial","Ensino de lnguas","Processamento de linguagem natural","Arquitetura de agentes","Tutor de IA"],dataDefesa:"2025-11-10",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202517,titulo:"Anlise comparativa de Arduinos na implementao de sistemas embarcados para monitoramento de tremores na doena de Parkinson",autor:"Manuele Sabatini Christfalo",orientador:"Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"A Doena de Parkinson (DP)  uma afeco neurodegenerativa crnica e progressiva do sistema nervoso central, que impacta significativamente a funo motora. O monitoramento de seus sintomas, em especial os tremores,  fundamental para o manejo clnico, porm frequentemente se baseia em avaliaes subjetivas. Este trabalho prope uma reviso bibliogrfica de solues quantitativas por meio do desenvolvimento e anlise comparativa de dois sistemas embarcados vestveis, projetados visando a coleta e anlise de dados de tremores. O estudo confronta duas abordagens de hardware: um bracelete utilizando a placa Arduino Nano 33 BLE Sense Rev 2, que possui uma unidade de medio inercial (IMU) integrada, e um segundo prottipo baseado no Arduino UNO, complementado por sensores externos. As plataformas so avaliadas sob mltiplos critrios, incluindo preciso dos sensores, eficincia computacional, consumo energtico, usabilidade, escalabilidade e custo-benefcio. Ainda no estudo, desenvolve-se uma arquitetura Long Short-Term Memory (LSTM) otimizada para a identificao de padres nas sries temporais possivelmente coletadas pelos Arduinos. A anlise final visa determinar a configurao de hardware mais adequada para o contexto biomdico da doena de parkison, contribuindo para o avano de tecnologias assistivas de baixo custo e alta preciso no acompanhamento de doenas neurodegenerativas.",palavrasChave:["Doena de Parkinson","monitoramento de Tremores","sistemas embarcados","Arduino","redes neurais recorrentes"],dataDefesa:"2025-11-12",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202518,titulo:"Anlise de perfil dos colaboradores de projetos de cdigo aberto em plataformas de repositrios de software",autor:"Alberto Azevedo Martinez",orientador:"Prof Dr Higor Amrio de Souza",curso:"BCC",descricao:`Projetos de cdigo aberto fazem parte importante do ecossistema de programas, com representantes performando
  entre opes viveis no mercado, porm no possuem tantas pesquisas tendo enfoque especfico em sua formao, ou sua comunidade.
  Essa pesquisa foi realizada com o objetivo de encontrar o perfil de colaboradores de projeto de cdigo aberto e enriquecer as
  anlises disponveis para esses projetos, auxiliando assim os mantenedores desses projetos a tomarem melhores decises e aes
  pelo bem da comunidade. Utiliza-se minerao de repositrios para conseguir os dados dos colaboradores de um grupo de projetos
  especfico, sendo feito tratamento e diferentes anlises grficas dos dados posteriormente. Observando os resultados obtidos 
  definido o perfil dos colaboradores de projeto de cdigo aberto, como tendo enfoque em regies com maior escolaridade, suas contas
  possuindo por volta de dez a quinze anos, com 85% ainda estando em atividade e no possuindo uma idade de conta com valor
  desproporcional de contribuies.`,palavrasChave:["Repositrios","Minerao","Anlise","Grfico","Mapa"],dataDefesa:"2025-11-12",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202301,titulo:"Identificao biomtrica de pessoas por meio do reconhecimento facial utilizando Vision Transformers",autor:"Arthur Francisco Ramos",orientador:"Dr Aparecido Nilceu Marana",curso:"BCC",descricao:"A biometria se tornou uma das formas mais seguras na tarefa de reconhecimento de indivduos, sendo o reconhecimento facial um dos problemas clssicos na rea da viso computacional. Proposto pela primeira vez h 50 anos, os sistemas de reconhecimento automtico de rostos passaram por diversas mudanas ao longo do tempo, desde algoritmos tradicionais at o uso de aprendizado de mquina profundo, com destaque nas redes neurais convolucionais, que hoje predominam as pesquisas na rea. Visando novas alternativas de mtodos para a tarefa de reconhecimento facial, este trabalho props avaliar o desempenho de uma arquitetura baseada em transformadores e autoateno com foco em imagens, o Vision Transformer, em ambientes controlados e no controlados, alm do desenvolvimento de uma aplicao completa para analisar o funcionamento do modelo de forma prtica. Para atingir tal objetivo, a metodologia aplicada consiste no uso de tcnicas de deteco e alinhamento facial, para aperfeioar o treinamento e validao do modelo de reconhecimento, em conjunto com mtodos de anlise comuns a sistemas de identificao e verificao, a fim de mensurar o desempenho da arquitetura proposta na resoluo do problema de reconhecimento facial. Os resultados demonstraram que o Vision Transformer  capaz de desempenhar a funo de reconhecimento com eficcia, todavia apresentando algumas limitaes em ambientes com maior instabilidade de iluminao e variaes de expresses faciais, principalmente devido ao tamanho limitado das bases de dados de imagens utilizadas, mas no prejudicando a experincia do usurio e a confiabilidade do aplicativo desenvolvido.",palavrasChave:["Biometria","Reconhecimento Facial","Vision Transformer"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","arthur_ramos_2023.pdf")},{label:"Apresentao",url:p("apresentacao","arthur_ramos_apresentacao_2023.pdf")}]},{id:202302,titulo:"Abordagem de aprendizado profundo para classificao de Parkinson por meio de sinais de voz",autor:"Andre Luiz da Silva Junior",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"A doena de Parkinson  um distrbio neurolgico progressivo que afeta o crebro. O desenvolvimento de sistemas especializados capazes de diagnosticar automaticamente e com alta preciso estgios iniciais da Doena de Parkinon com base em sinais de fala representaria uma contribuio importante para o setor de sade. Para isso, foram analisados modelos de machining learning como a regresso logistica, support vector machine, K-Neightbors, Random Forest, Decion Tree, Naive Bayes e XGBoost, alm disso foi utilizado tcnicas de deep learning como a Rede Neural Convolucional e a Rede Neural Recorrente. Essas abordagens foram aplicadas a trs conjuntos de dados com caracteristicas prprias para um mais amplo estudo dos casos. Dois desses conjuntos de dados foram analisados com o uso de machining learning, e um com a utilizao de deep learning com sries temporais, aps o treino o modelo com o melhor desempenho foi selecionado. Os resultados revelaram que o modelo de teve um desempenho melhor nos dois conjunto de dados que utilizaram machining learning foi a Regresso Linear, e no deep learning foi a Rede Neural Convolucional. Os resultados obtidos revelaram uma acurcia de classificao de 92.31% e 86.84% para os dois conjuntos de dados, o que evidencia a capacidade de obter resultados excelentes mesmo com um conjunto limitado de dados. Alm disso, foram observadas precises de 91.43% e 86.72%, recalls de 100.00% e 97.37%, e F1-Scores de 95.52% e 91.74%. Esses valores corroboram a qualidade dos resultados alcanados. Por sua vez, a Rede Neural Convolucional apresentou uma acurcia de classificao de 86.69%, preciso de 86.83%, recall de 88.20% e F1-Score de 87.51%, mesmo com um nmero reduzido de pocas de treinamento. Isso evidencia a eficcia desse modelo como uma alternativa valiosa para a classificao. Esses resultados indicam que as classificaes tero um papel significativo no avano do setor mdico.  importante ressaltar a relevncia de uma anlise cuidadosa na escolha do modelo a ser utilizado, pois diferentes conjuntos de dados podem apresentar resultados mais favorveis em modelos distintos.",palavrasChave:["Parkinson","Sinais de Voz","Classificao"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","andre_junior_2023.pdf")},{label:"Apresentao",url:p("apresentacao","andre_junior_apresentacao_2023.pdf")}]},{id:202303,titulo:"Auxlio ao diagnstico de doena neurodegenerativa utilizando expresses faciais",autor:"Arissa Yoshida",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"O diagnstico precoce da Esclerose Lateral Amiotrfica (ELA)  fundamental para a determinao do incio dos tratamentos, auxiliando tanto no aumento da expectativa de vida quanto na melhora da qualidade de seus pacientes. A anlise de movimentos faciais fornece informaes importantes para o reconhecimento dos sintomas iniciais da ELA; entretanto, detectar esses sinais no  uma tarefa fcil. Com o advento da viso computacional e dos modelos de aprendizado de mquina, mtodos computacionais de auxlio a diagnstico de doenas neurodegenerativas por meio de vdeos vm se tornando uma realidade, gerando diferentes abordagens para deteco dos biomarcadores da ELA. Por utilizarem mtodos interpretativos, grande parte dos estudos acabam por no explorar a dimenso temporal durante o processo de classificao. Este trabalho prope introduzir modelos sequenciais de Redes Neurais Recorrentes (Recurrent Neural Network - RNN) em dados sequenciais (vdeos) de tal forma que seja investigada a relevncia da dinmica temporal das unidades de ao (Action Units - AUs) na identificao da ELA. Concluindo com o desenvolvimento de uma ferramenta de auxlio ao diagnstico por computador (computer-aided diagnosis, CAD).",palavrasChave:["Esclerose Lateral Amiotrfica","Expresses Faciais","Redes Neurais Recorrentes","Doena Neurodegenerativa"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","arissa_yoshida_2023.pdf")},{label:"Apresentao",url:p("apresentacao","arissa_yoshida_apresentacao_2023.pdf")}]},{id:202304,titulo:"IMPLEMENTAO DO DEVOPS PARA GERENCIAMENTO DE RISCOS DE SEGURANA NA NUVEM",autor:"Artur Kyung Min Lee",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"A conjuntura do mundo da tecnologia nos ltimos anos permitiu com que a computao em nuvem progredisse de forma exponencial por ter diversos benefcios como a velocidade, a escalabilidade, o custo, a disponibilidade e outros. Porm, assim como novas tecnologias de nuvem foram surgindo, ameaas cibernticas tambm foram aumentando. Hoje, tornou-se necessrio que todo ambiente em 	extit{cloud} tenha ferramentas que sejam capazes de manter a integridade, confiabilidade e disponibilidade das aplicaes nesse ambiente. Entende-se que uma das principais funes das ferramentas de segurana  de detectar falhas ou aes suspeitas que devem ser bloqueadas em prol da proteo da aplicao. Por conta disso,  vital que as tecnologias de segurana sejam implementadas com um estudo prvio para que possam incorporar-se ao fluxo da aplicao sem anular os principais benefcios da nuvem. Esse trabalho prope integrar ferramentas de segurana de maneira que as mesmas no interfiram de negativamente no fluxo da aplicao. Seguindo as melhores prticas do DevOps, ser criado uma aplicao/programa na nuvem (AWS) que tenha fluxo de integrao e entrega contnuas onde sero integradas as ferramentas responsveis por trazer segurana e visibilidade ao ambiente.",palavrasChave:["DevOps","Segurana na Nuvem","Gerenciamento de Riscos"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","artur_lee_2023.pdf")},{label:"Apresentao",url:p("apresentacao","artur_lee_apresentacao_2023.pdf")}]},{id:202305,titulo:"CRIAO DE UM MAPEADOR OBJETO-GRAFO PARA OTIMIZAO E SIMPLIFICAO NO GERENCIAMENTO DE BANCOS DE DADOS BASEADOS EM GRAFOS EM AMBIENTES DE BIG DATA: UMA ANLISE COMPARATIVA COM MAPEADORES OBJETO-RELACIONAL E OUTROS BANCOS DE DADOS",autor:"Cassiano Henrique A Rodrigues",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"O trabalho visou criar um mapeador objeto-grafo (OGM) para melhorar a manipulao e recuperao de dados em ambientes de big data. Em cenrios de grande amplitude de da- dos,  crucial escolher solues eficientes, uma vez que a complexidade desses ambientes pode impactar negativamente o desempenho. Portanto introduziu-se uma camada de abstrao por meio dos OGMs para simplificar a interao com bancos de dados baseados em grafos. O projeto concentrou-se na estruturao, implementao e avaliao do mapeador. Testes exaustivos foram realizados para capturar mtricas e indicadores, demonstrando a eficin- cia do mapeador em otimizar a manipulao e recuperao de dados, proporcionando uma experincia simplificada para os desenvolvedores e validando sua capacidade de aprimorar a eficcia na manipulao de dados e fornecer uma interface intuitiva para o desenvolvi- mento de aplicaes.",palavrasChave:["Mapeador Objeto-Grafo","Big Data","Bancos de Dados em Grafos","Objeto-Relacional","Otimizao","Simplificao"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","cassiano_rodrigues_2023.pdf")},{label:"Apresentao",url:p("apresentacao","cassiano_rodrigues_apresentacao_2023.pdf")}]},{id:202306,titulo:"ANLISE DO IMPACTO DA SEGURANA VIRIA NA MOBILIDADE ATIVA",autor:"Danilo Alves Siqueira",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O presente trabalho tem como proposta aplicar tcnicas de cincia de dados com python para analisar e visualizar dados tabulares e geolocalizados com o objetivo de entender o impacto do cenrio atual da segurana viria sobre a mobilidade ativa na cidade de So Paulo. As anlises buscam entender o panorama referente a quantidade de acidentes envolvendo ciclistas e pedestres, a distribuio desses, alm de caractersticas dos acidentes e acidentados. Visa-se tambm entender a influncia da segurana das infraestruturas ciclovirias sobre os acidentes e o gasto gerado ao sistema de sade pblico para atendimento das vtimas.",palavrasChave:["Segurana Viria","Mobilidade Ativa","Cincia de Dados","Python","Acidentes"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","danilo_siqueira_2023.pdf")},{label:"Apresentao",url:p("apresentacao","danilo_siqueira_apresentacao_2023.pdf")}]},{id:202307,titulo:"ESTUDO SOBRE FRAUDES DIGITAIS E O DESENVOLVIMENTO DE APLICATIVO PARA SMARTPHONES ANDROID E IOS PARA USO EM PALESTRAS DE SENSIBILIZAO E ESCLARECIMENTO",autor:"Gabriel Carvalho Polido",orientador:"Prof. Assoc. Eduardo Martins Morgado",curso:"BCC",descricao:"Golpes e fraudes digitais so uma ameaa em constante evoluo, principalmente quando utilizam trs estratgias de ataque: Phishing, Spoofing e Engenharia Social. Durante a pesquisa, foi destacada a natureza sofisticada dessas ameaas, que visam enganar os usurios e obter acesso a informaes confidenciais. O estudo forneceu uma anlise aprofundada de cada estratgia, explorando exemplos de casos e tcnicas de mitigao. Alm disso, foram estudadas as estratgias de ataque que so utilizadas atualmente para que seja possvel enfrentar com xito essas ameaas. tais estratgias de ataque tem o intuito de roubar informaes e recursos, visando posteriormente utilizar tais informaes para aplicar golpes e fraudes elaboradas na vtima. Assim sendo, foi enfatizada a importncia da conscientizao e da educao como estratgias cruciais para proteger indivduos e organizaes contra essas ameaas digitais em um ambiente cada vez mais interconectado, dependente da tecnologia e em constante evoluo. Foi desenvolvido um aplicativo informtico que incentiva as pessoas a tomarem medidas mais proativas para combater eficazmente os golpes e fraudes digitais, garantindo um ambiente ciberntico mais seguro.",palavrasChave:["Fraudes Digitais","Golpes Digitais","Phishing","Spoofing","Engenharia Social","Segurana da Informao"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","gabriel_polido_2023.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_polido_apresentacao_2023.pdf")}]},{id:202308,titulo:"APLICATIVO GAMIFICADO PARA ORGANIZAO DE TAREFAS E ROTINAS ACADMICAS",autor:"Gabriel Henrique Garcia Ticianeli",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"O ingresso na faculdade  um momento de mudanas drsticas no estilo de vida dos estudantes. Ele marca uma transio onde o aluno deve se adaptar a novas responsabilidades que muitas vezes causam uma sobrecarga de trabalho. Esse aumento na demanda pode ser esmagador para aqueles que esto despreparados. Dessa forma, manejar o pouco tempo disponvel de maneira efetiva torna-se essencial para o sucesso acadmico. Como soluo para o problema mencionado, o trabalho objetivou desenvolver um aplicativo mobile gamificado para organizao de tarefas e rotinas, chamado de Guilda dos Universitrios. Gamificao  a utilizao de elementos de design de jogos em aplicaes que no so jogos puros, visando aumentar a interatividade e o engajamento do usurio. Utilizando esta estratgia, o sistema foi projetado para fornecer uma maneira mais envolvente e motivadora de gerenciar a carga de trabalho acadmica e criar bons hbitos. Por ser o sistema operacional mais usado pelos smartphones, foi escolhido o Android como plataforma para o programa, e a construo do trabalho foi feita na Unity Engine. O aplicativo resultante possui as funes de cadastrar tarefas (tanto nicas quanto repetveis), contabilizar hbitos dirios e formar grupos de usurios para compartilharem dos mesmos afazeres. As ferramentas so complementadas por mecnicas de progresso e recompensas, e os grupos possuem uma tabela de classificao para estimular a competitividade. Os resultados obtidos de uma comparao deste projeto com outros disponveis no mercado de aplicativos mostra que existem poucas opes para organizao de tarefas que aplicam a gamificao, e dentre estes, no h a presena de sistemas cooperativos entre os usurios.",palavrasChave:["Aplicativo Gamificado","Organizao de Tarefas","Rotinas Acadmicas","Gamificao","Unity"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","gabriel_ticianeli_2023.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_ticianeli_apresentacao_2023.pdf")}]},{id:202309,titulo:"QUALIDADE DE SOFTWARE: ANLISE DE DESEMPENHO DE FERRAMENTAS DE AUTOMAO EM TESTES E2E",autor:"Geovanna Carolina F V T Brandao",orientador:"Prof. Dr Kleber Rocha de Oliveira",curso:"BCC",descricao:"O presente trabalho tem como tema a anlise de desempenho de ferramentas de automao de testes de ponta-a-ponta. Onde o objetivo  abordar esse estudo de caso a partir do modelo ISSO 25010, aliado aos critrios ortogonais de classificao da abordagem de localizao de objetos em tela. Ademais,  realizada uma anlise do parecer da indstria de tecnologia em relao a essa categoria de testes. A escolha deste tema  impulsionada pela crescente complexidade dos sistemas de software, a necessidade da reduo de custos e aumento da dependncia social na tecnologia da informao.",palavrasChave:["Qualidade de Software","Testes E2E","Automao de Testes","Desempenho de Ferramentas"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","geovanna_brandao_2023.pdf")},{label:"Apresentao",url:p("apresentacao","geovanna_brandao_apresentacao_2023.pdf")}]},{id:202310,titulo:"USO DE APRENDIZADO DE MQUINA PARA DETECO DE ATAQUES DDOS",autor:"Gustavo Amaral Duarte Rego",orientador:"Prof. Dr. Kelton Augusto P da Costa",curso:"BCC",descricao:"A Segurana Ciberntica  um tema que possui muita relevncia nos dias atuais, uma vez que a sociedade depende cada vez mais do mundo digital e de suas ferramentas. Ataques nesse meio so comuns de diversas formas, mas um dos mais ameaadores para um servio  o Distributed Denial of Service, ou, Ataque de negao de servio distribudo, que tem por objetivo esgotar recursos do host. Aprendizado de Mquina pode ser definido como uma ramificao da inteligncia artificial, que foca no uso de dados e algoritmos para imitar a forma como humanos aprendem. Por ser altamente eficiente no reconhecimento de padres,  possvel utilizar algoritmos desse tipo para auxiliar no reconhecimento de ataques cibernticos. Nesse trabalho so abordados estudos e implementaes sobre o uso desses algoritmos para verificar sua acurcia e viabilidade utilizando conjuntos de dados de trfego de rede",palavrasChave:["Aprendizado de Mquina","Deteco de Ataques","DDoS","Segurana Ciberntica"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","gustavo_rego_2023.pdf")},{label:"Apresentao",url:p("apresentacao","gustavo_rego_apresentacao_2023.pdf")}]},{id:202311,titulo:"USO DE APRENDIZADO DE MQUINA PARA DETECO DE FACES FALSAS GERADAS POR INTELIGNCIA ARTIFICIAL",autor:"Joo Pedro Vieira Rodrigues",orientador:"Prof. Dr. Kelton Augusto P da Costa",curso:"BCC",descricao:"O avano no campo da inteligncia artificial, especialmente na rea de aprendizado profundo, possibilitou a criao de rostos humanos por meio de modelos de redes neurais, como a Generative Adversarial Network (GAN). Entretanto, esse avano levantou preocupaes significativas em relao  segurana, especialmente nos contextos de biometria e autenticao digital. Diante desse problema, este trabalho concentra-se na aplicao de uma tcnica especfica de aprendizado de mquina conhecida como Capsule Neural Network (CapsNet). Esta abordagem se mostrou promissora para o processamento de imagens e ser comparada a outras tcnicas, como Local Binary Pattern, Res-Net e Gram-Net. A anlise detalhada desses mtodos permitir uma compreenso mais aprofundada de suas capacidades e limitaes, contribuindo para o desenvolvimento de sistemas mais seguros e eficazes no contexto da inteligncia artificial e suas aplicaes prticas. A avaliao crtica dessas tcnicas  essencial para aprimorar a segurana e a autenticidade em sistemas que dependem de reconhecimento facial e autenticao digital.",palavrasChave:["Aprendizado de Mquina","Deteco de Faces Falsas","Inteligncia Artificial","Capsule Neural Network","Generative Adversarial Network"],dataDefesa:"2023-10-01",links:[{label:"Monografia",url:p("monografia","joao_rodrigues_2023.pdf")},{label:"Apresentao",url:p("apresentacao","joao_rodrigues_apresentacao_2023.pdf")}]},{id:202312,titulo:"APLICAO DE SOLID EM UM SISTEMA WEB PARA INTERMEDIAO DE COMPRA E VENDA DE COMIDA NA UNESP",autor:"Julio Cesar Benelli Varella",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"A venda de alimentos por estudantes universitrios tem se mostrado uma prtica recorrente e vital para a manuteno financeira e suporte de projetos acadmicos. Diante das dificuldades enfrentadas pelos estudantes para sustentar-se durante o curso, somado  necessidade de financiamento para projetos de extenso, o desenvolvimento de um sistema unificado para a comercializao de alimentos emerge como uma soluo estratgica. Este trabalho prope a criao de um sistema Web para facilitar e otimizar a venda de alimentos no campus da UNESP-Bauru, fornecendo um ponto de encontro virtual entre compradores e vendedores. Alm disso, o sistema  desenvolvido com nfase em prticas de codificao limpa e padres de projeto, utilizando princpios SOLID e o padro MVC para assegurar um cdigo organizado, manutenvel e expansvel. A escolha do framework Symfony e do Bootstrap proporciona a funcionalidade e responsividade necessrias ao sistema. A disponibilizao do cdigo como open-source refora a inteno de contribuir para a comunidade acadmica, permitindo evoluo contnua do projeto. Este trabalho, portanto, no s atende uma necessidade prtica, mas tambm promove a manutenibilidade, a extensibilidade do sistema e a prtica colaborativa dentro do ambiente universitrio.",palavrasChave:["Sistema Web","Compra e Venda de Comida","UNESP","SOLID","MVC","Symfony","Bootstrap"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","julio_varella_2023.pdf")},{label:"Apresentao",url:p("apresentacao","julio_varella_apresentacao_2023.pdf")}]},{id:202313,titulo:"DETECO DE FAKE NEWS EM PORTUGUS UTILIZANDO INFERNCIA DE LINGUAGEM NATURAL",autor:"Larissa Mayumi Barela Hondo",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"Com o advento da Internet,  possvel obter informaes a partir de quaisquer fontes sobre eventos ao redor do mundo, inclusive informaes imprecisas e at mesmo falsas, sendo estas chamadas de fake news. A divulgao e a proliferao de fake news podem causar prejuzos e danos serssimos para as pessoas e para a sociedade de modo geral, salientando a extrema importncia de sua identificao. Isso pode ser feito com o uso do Processamento de Linguagem Natural, que abrange tcnicas computacionais para a anlise automtica e  representao de linguagens antropolgicas. Por exemplo, a deteco de fake news pode ser feita com a Inferncia de Linguagem Natural, uma sub-rea do Processamento de Linguagem Natural focada na verificao da implicao ou contradio em um par de sentenas, que pode ser utilizada neste contexto considerando notcias j confirmadas como sendo verdadeiras como a premissa e uma notcia suspeita como a hiptese, dessa forma, caso haja contradio entre a hiptese e a premissa, a notcia suspeita  considerada falsa, caso contrrio, ela  rotulada como verdadeira. Visto isso, o objetivo deste trabalho  propor um mtodo de deteco automtica de fake news para a lngua portuguesa utilizando a Inferncia de Linguagem Natural. Como no h uma base de dados em portugus que utilize a Inferncia de Linguagem Natural para esta aplicao,  possvel traduzir dados j existentes para este idioma, em vista disso, neste trabalho utilizou-se a base de dados em ingls denominada FNID-FakeNewsNet. Com base nos resultados obtidos para o conjunto de teste, observa-se um desempenho melhor quando a premissa  utilizada junto  hiptese. Alm disso, de modo geral,  possvel observar que os resultados no foram afetados significativamente pela traduo dos dados em ingls para o portugus.",palavrasChave:["Fake News","Inferncia de Linguagem Natural","Processamento de Linguagem Natural","Deteco Automtica","FNID","FakeNewsNet"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","larissa_hondo_2023.pdf")},{label:"Apresentao",url:p("apresentacao","larissa_hondo_apresentacao_2023.pdf")}]},{id:202314,titulo:"CONSTRUO DE UM MDULO QUNTICO PARA O CLASSIFICADOR BASEADO EM FLORESTA DE CAMINHOS TIMOS",autor:"Maria Anglica Krger Miranda",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"O interesse pela computao quntica tem experimentado um aumento constante, impulsionado principalmente pelas recentes inovaes tecnolgicas anunciadas por empresas renomadas, como a IBM e a Google. Essas inovaes tm o potencial de solucionar desafios significativos em diversos setores, como financeiro, mdico, fsico, farmacutico, qumico, entre outros. Esse potencial advm da capacidade da computao quntica de resolver problemas que eram anteriormente considerados inviveis. Concomitantemente a esse crescimento, o campo do aprendizado de mquina tem se destacado como uma ferramenta computacional crucial para o desenvolvimento de novas solues e tecnologias. Desta forma, o trabalho tem por interesse implementar e avaliar um mdulo quntico para o classificador baseado em floresta de caminhos timos para explorar a abordagem hbrida do aprendizado de mquina quntico. Os experimentos conduzidos revelaram desafios a serem superado, no entanto, a implementao demonstrou ser promissora devido  sua viabilidade, alm de representar o primeiro estudo sobre a aplicao da computao quntica neste classificador em especfico.",palavrasChave:["Computao Quntica","Aprendizado de Mquina Quntico","Floresta de Caminhos timos","Classificador Quntico"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","maria_miranda_2023.pdf")},{label:"Apresentao",url:p("apresentacao","maria_miranda_apresentacao_2023.pdf")}]},{id:202315,titulo:"DESENVOLVIMENTO DE UMA APLICAO INTEGRADA PARA GERENCIAMENTO DE PROJETOS E RECURSOS PARA PROGRAMADORES",autor:"Matheus dos Santos Ribeiro Silva",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"A rea de Desenvolvimento de Software experimentou um crescimento exponencial nas ltimas dcadas, impulsionando uma revoluo tecnolgica que tem tido um impacto significativo na vida cotidiana de bilhes de pessoas. Esse avano se traduz em benefcios notveis em setores como Educao, Medicina, Engenharia, Matemtica, Indstria, entre outros. Em consonncia com a crescente demanda, houve um aumento substancial na quantidade de profissionais de desenvolvimento de software. No contexto da programao no Brasil, modalidades de emprego mais flexveis, a exemplo o trabalho como pessoa jurdica, oferece vantagens atrativas, como salrios superiores e benefcios fiscais. No entanto, a gesto de projetos em diversas empresas, em mltiplos projetos e com uma variedade de tecnologias pode ser desafiadora, resultando na disperso da ateno dos programadores, o que prejudica sua eficincia e desempenho. Com o advento e a disseminao do acesso s Inteligncias Artificiais Generativas (IAG) para um pblico mais amplo, observou-se a integrao de servios e conjuntos de software com Inteligncia Artificial (IA), unificando funcionalidades e dados para melhorar a eficincia e o desempenho dos usurios. Grandes empresas, como Microsoft e Google, buscam cada vez mais integrar seus diversos servios e ambientes de trabalho com IAs, como o ChatGPT da OpenAI ou o Bart da Google, com o objetivo de disponibilizar produtos teis para seus usurios e otimizar seus lucros por meio da melhoria contnua de suas ferramentas. Nesse contexto, este projeto prope a criao de uma dashboard integrada que utiliza uma Application Programing Interface (API) do ChatGPT e do Google Workspace. Essa plataforma visa centralizar o gerenciamento de cdigos e anotaes em projetos de desenvolvimento, com o propsito de aprimorar a eficincia e a produtividade dos desenvolvedores de software.",palavrasChave:["Gerenciamento de Projetos","Desenvolvimento de Software","Inteligncia Artificial Generativa","ChatGPT","Google Workspace","Dashboard Integrada"],dataDefesa:"2023-11-03",links:[{label:"Monografia",url:p("monografia","matheus_silva_2023.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_silva_apresentacao_2023.pdf")}]},{id:202316,titulo:"DETECO DE IMAGENS DEEPFAKE: UM ESTUDO COMPARATIVO",autor:"Miguel Cesar Correa",orientador:"Prof. Dr. Leandro A Passos Junior",curso:"BCC",descricao:"Com o avano acelerado da inteligncia artificial, os deepfakes - vdeos ou imagens manipulados de maneira convincente - emergiram como uma preocupao significativa na era digital. Essas falsificaes hiper-realistas tm o potencial de enganar indivduos, disseminar desinformao e comprometer a autenticidade da informao, representando uma ameaa real  segurana digital e  integridade informativa. Este trabalho aborda a necessidade de desenvolver mtodos eficazes para a deteco de deepfakes, uma ferramenta essencial na luta contra a desinformao, apresentando os conceitos fundamentais da rea. Este trabalho comparou trs mtodos estado-da-arte de deteco de imagens falsas, apresentando resultados satisfatrios, com o mtodo que emprega medidas contra o sobre-ajuste tendo o melhor desempenho.",palavrasChave:["Deepfake","Deteco de Imagens Falsas","Inteligncia Artificial","Segurana Digital","Desinformao"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","miguel_correa_2023.pdf")},{label:"Apresentao",url:p("apresentacao","miguel_correa_apresentacao_2023.pdf")}]},{id:202317,titulo:"ANLISE DE DADOS DA SADE PARA MELHORIAS EM POLTICAS PBLICAS",autor:"Nathan Del Grande Souza",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O campo da sade pblica enfrenta desafios complexos. Questes de desigualdade na distribuio de mdicos e alto deslocamento de pacientes para internaes tm implicaes profundas na eficincia e equidade do SUS (Sistema nico de Sade). Este trabalho tem como objetivo investigar esses desafios crticos por meio de anlises geoespaciais, grficas e correlacionais. Visa-se avaliar a distribuio de mdicos, o deslocamento de pacientes e a possvel relao entre esses fatores. Alm disso, busca-se fornecer uma base slida para melhorar as polticas pblicas de sade no estado de So Paulo. O estudo empregou anlises geoespaciais para mapear a distribuio de mdicos, grficos de disperso para explorar relaes entre variveis-chave, como renda per capita e deslocamento de pacientes, e anlises correlacionais com o mtodo de Pearson para quantificar essas relaes. As anlises revelaram disparidades significativas na distribuio de mdicos e desafios relacionados ao deslocamento de pacientes. Correlaes importantes foram identificadas, mas a complexidade das variveis sugere que h fatores adicionais a serem considerados.",palavrasChave:["Sade Pblica","Anlise de Dados","Polticas Pblicas","Desigualdade na Sade","Geoespacial"],dataDefesa:"2023-11-16",links:[{label:"Monografia",url:p("monografia","nathan_souza_2023.pdf")},{label:"Apresentao",url:p("apresentacao","nathan_souza_apresentacao_2023.pdf")}]},{id:202318,titulo:"DIAGNSTICO AUTOMTICO DE AVC PS-TRAUMA COM BASE NA FACE DE PACIENTES UTILIZANDO REDES NEURAIS EM GRAFOS",autor:"Ncolas Barbosa Gomes",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"O acidente vascular cerebral (AVC) pode causar danos significativos aos neurnios, resultando em vrias sequelas que afetam negativamente a capacidade do paciente de realizar atividades dirias essenciais, como mastigar, engolir e se comunicar verbalmente. Portanto,  importante que pacientes com essas dificuldades passem por um processo de tratamento e sejam monitorados durante sua execuo para avaliar a melhora de sua condio de sade. O uso de ferramentas computadorizadas e algoritmos que podem detectar rapidamente e de maneira acessvel tais sequelas  til para auxiliar na recuperao do paciente. Devido  morte das clulas internas do crebro, um AVC frequentemente leva  paralisia facial, resultando em assimetria entre os dois lados do rosto. Esta monografia se concentra na anlise desta assimetria usando um mtodo de aprendizado profundo sem aplicar clculos de caractersticas manuais, introduzindo o modelo Facial Point Graphs (FPG), uma abordagem inovadora que se destaca na aprendizagem de informaes geomtricas e no tratamento eficaz de variaes, alm do escopo dos clculos manuais. O FPG permite que o modelo detecte de forma eficaz os distrbios orofaciais causados por um AVC, a partir de imagens do paciente. A abordagem proposta atingiu acurcias superiores a 90% no conjunto de dados Toronto Neuroface, apontando para avanos substanciais neste domnio.",palavrasChave:["Acidente Vascular Cerebral","Redes Neurais em Grafos","Diagnstico Automtico","Assimetria Facial","Facial Point Graphs"],dataDefesa:"2023-11-16",links:[{label:"Monografia",url:p("monografia","nicolas_gomes_2023.pdf")},{label:"Apresentao",url:p("apresentacao","nicolas_gomes_apresentacao_2023.pdf")}]},{id:202319,titulo:"DESENVOLVIMENTO DE UMA APLICAO PARA ANLISE DE DESEMPENHO DE GRANDES MODELOS DE LINGUAGEM",autor:"Nicole Barbosa Gomes",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"A linguagem  uma necessidade humana desde sua origem. Com mtodos mais rudimentares ou mais rebuscados, o ser humano encontra maneiras de se comunicar. A partir do surgimento dos computadores e das mudanas proporcionadas por eles, um novo desafio tambm chegou: descobrir como gerar conversaes com as mquinas. Os estudos a esse respeito levaram a invenes importantes que provocaram ideias antes consideradas impossveis. A rea de aprendizado de mquina foi responsvel pela maior parte desses avanos e, graas ao ramo, modelos de redes neurais artificiais foram cada vez mais explorados. Como um dos resultados, os large language models, caracterizados por serem compostos por essas redes, apresentaram resultados admirveis ao produzir textos muito parecidos com os escritos por humanos. O sucesso desses modelos despertou o interesse de empresas que passaram a desenvolver suas prprias verses. A partir disso, cresce a demanda por entender quais deles so mais apropriados para certas aplicaes, e outras questes de desempenho. Com esse propsito, o projeto buscou desenvolver um site que pudesse reunir large language models a fim de que gerassem respostas baseadas em instrues do usurio. Alm disso, a aplicao deveria ser capaz de receber feedbacks sobre o melhor texto para uma instruo especfica e, dessa maneira, possibilitar anlises dos dados coletados para descobrir os pontos fracos e fortes de cada modelo. No final do desenvolvimento, esses objetivos foram atingidos e o site se tornou uma ferramenta intuitiva, para atender a um grande pblico, e proveitosa para captura de informaes relevantes e estudo dos retornos recebidos.",palavrasChave:["Grandes Modelos de Linguagem","Aprendizado de Mquina","Redes Neurais Artificiais","Anlise de Desempenho","Processamento de Linguagem Natural"],dataDefesa:"2023-11-16",links:[{label:"Monografia",url:p("monografia","nicole_gomes_2023.pdf")},{label:"Apresentao",url:p("apresentacao","nicole_gomes_apresentacao_2023.pdf")}]},{id:202320,titulo:"RECONHECIMENTO DE MARCHA HUMANA UTILIZANDO POSES 3D ESTIMADAS DE MLTIPLAS POSES 2D",autor:"Pedro Luiz Cason Caldato",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"O reconhecimento biomtrico de indivduos  um campo de estudo amplamente explorado nos dias atuais, impulsionado pelos avanos recentes na computao e pela necessidade premente de reforar a segurana em diversas configuraes, incluindo vigilncia e processos de autenticao em aplicativos como bancos e gerenciamento de documentos. Dentre as diversas abordagens biomtricas desenvolvidas, destacam-se o reconhecimento facial, anlise de impresses digitais, leitura da ris e reconhecimento de voz. No entanto, esses mtodos geralmente exigem interao direta com os indivduos, equipamentos especializados (no caso do reconhecimento de impresses digitais) ou imagens de alta resoluo (no caso do reconhecimento facial ou de ris). Em situaes que demandam reconhecimento biomtrico indireto, a anlise da marcha se mostra valiosa. Essa abordagem envolve a avaliao do padro de caminhada de um indivduo, bem como a anlise de medidas relacionadas ao comprimento dos membros, como braos e pernas, a fim de identificar a pessoa comparando-a com um banco de dados existente. Este projeto tem como objetivo estabelecer uma abordagem de reconhecimento biomtrico com base na marcha, utilizando representaes tridimensionais de poses humanas extradas de mltiplas imagens bidimensionais. Uma das vantagens notveis dessa abordagem  sua maior resistncia a ocluses, juntamente com um aumento na preciso do reconhecimento da marcha, alcanado por meio da incorporao de um conjunto mais abrangente de dados correlacionados provenientes de diferentes fontes de cmeras. O mtodo proposto faz uso de uma Rede Neural Convolucional (CNN) para calcular um vetor descritivo por meio da agregao temporal das poses tridimensionais estimadas a partir de mltiplas imagens bidimensionais. A eficcia desse mtodo foi avaliada usando as bases de dados CASIA GAIT-A e CASIA GAIT-B, resultando em taxas de preciso de 90,00% e 86,10%, respectivamente.",palavrasChave:["marca humana","biometria","poses 3D","redes neurais convolucionais","reconhecimento de padres","poses 2D"],dataDefesa:"2023-11-14",links:[{label:"Monografia",url:p("monografia","pedro_caldato_2023.pdf")},{label:"Apresentao",url:p("apresentacao","pedro_caldato_apresentacao_2023.pdf")}]},{id:202321,titulo:"Anlise do desempenho de honeypots e algoritmos de Machine Learning em tarefas de deteco de intruso",autor:"Renato Leite Camilo",orientador:"Prof. Dr. Kelton Augusto P da Costa",curso:"BCC",descricao:"A cibersegurana  uma rea de grande interesse na computao. A capacidade de detectar e lidar com invasores em ambientes digitais  uma preocupao para muitas pessoas e empresas. Em contrapartida, os mecanismos que proporcionam essa capacidade nem sempre so totalmente confiveis, falhando em algumas ocasies e causando prejuzos inimaginveis para seus usurios. Como resoluo para esse problema, muito se prope o uso de machine learning. Esse projeto emprega dois algoritmos de clustering: K-Means e DBSCAN. O objetivo  analisar seu impacto quando usados em conjuntos com outros classificadores baseados em trs algoritmos de aprendizado de mquina: Support Vector Machines, Multilayer Perceptron e K-Nearest Neighbors. Alm disso,  empregado o conceito de honeypots para analisar sua usabilidade como receptculo de informaes a respeito de ataques para providenciar dados aos modelos preditivos. Tudo que chega a um honeypot  considerando um ataque e esse tipo de informao pode ser aproveitado por modelos de aprendizado de mquina.",palavrasChave:["Cibersegurana","Ciberataques","Honeypots","Machine Learning","Clustering"],dataDefesa:"2023-12-01",links:[{label:"Monografia",url:p("monografia","renato_camilo_2023.pdf")},{label:"Apresentao",url:p("apresentacao","renato_camilo_apresentacao_2023.pdf")}]},{id:202322,titulo:"MINERAO DE REPOSITRIOS PARA ANLISE DE CICLOS DE SOFTWARE",autor:"Ronaldo Rubens Gesse Junior",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"Em um cenrio tecnolgico em constante evoluo, a anlise para escolha dos componentes e tecnologias de forma assertiva desempenha um papel crucial no sucesso de qualquer projeto de software. Frameworks e bibliotecas so componentes essenciais que oferecem funcionalidades ao cdigo e agilizam o processo de desenvolvimento, auxiliando times a entregar um resultado de forma mais eficiente ao usurio final. A minerao de repositrios surgiu como uma forma valiosa de obter informaes sobre os cdigos-fonte desses softwares, possibilitando anlises que visualizem seus ciclos de vida e entendam seu estado atual. Neste trabalho foram analisados 85 softwares com mtricas de tendncias e correlaes para os seguintes dados: nmero de commits e autores dos seus respectivos repositrios de cdigo e nvel do interesse relativo, com base nos dados do Google Trends para medir engajamento dos desenvolvedores. A partir disso foi possvel analisar os resultados e entender se determinado projeto  realmente vivel em seu estado atual de vida, se ele ainda  constantemente atualizado, tem as manutenes devidas e  procurado pela comunidade. Portanto, a aplicao da minerao de repositrios representa um passo importante em direo a um desenvolvimento mais informado e eficaz, alinhado com as necessidades do mercado.",palavrasChave:["Minerao de repositrios","Frameworks","Bibliotecas","Cincia de dados","Tendncias de software","Anlise de ciclos de software","Correlao de dados","Anlise"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","ronaldo_gesse_2023.pdf")},{label:"Apresentao",url:p("apresentacao","ronaldo_gesse_apresentacao_2023.pdf")}]},{id:202323,titulo:"ESTUDO DA EFICCIA DE MODELOS DE ESTIMATIVA DE IRRADIAO SOLAR NA REGIO DO CENTRO DE SO PAULO",autor:"Virgilio Santinho Tagliavini",orientador:"Prof. Assoc. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"A irradiao solar incidente na superfcie terrestre  uma varivel importante em diversas aplicaes cientficas e comerciais assim a capacidade de estimar e prever a irradiao solar global  necessria em diversos cenrios, por isso existem diversos modelos para a estimar mas nenhum modelo  efetivo para toda a superfcie terrestre. Assim, este trabalho tem como objetivo avaliar o desempenho de trs modelos numricos para estimar a irradiao solar diria para a regio do centro do estado de So Paulo. Para isso foram utilizados dados meteorolgicos de sete cidades do centro do estado de So Paulo disponibilizados pelo INMET para executar e registrar os resultados dos modelos estudados, ento seus resultados foram comparados com os dados reais registrados utilizando medidas estatsticas e estocsticas. Os resultados inicialmente obtidos indicaram que apenas o modelo de Hargreaves e Samani  efetivo em estimar a irradiao solar incidente na regio porque os resultados dos demais modelos apresentaram baixos ndices de concordncia com os dados reais. Para aumentar a preciso dos modelos estudados foi adicionado um coeficiente de ajuste para cada cidade e modelo, isso resultou em estimativas adequadas em todos os modelos, com altos valores nas medidas de avaliao utilizadas, mas o modelo de Hargreaves e Samani permaneceu como o modelo de maior preciso para todas as cidades estudadas, com exceo de Barra Bonita onde  o segundo modelo mais preciso. Assim, estes modelos so apropriados para a estimativa da irradiao solar na regio do centro do estado de So Paulo.",palavrasChave:["Irradiao Solar","Modelos Numricos","Estimativa","Centro de So Paulo","Avaliao de Desempenho"],dataDefesa:"2023-11-01",links:[{label:"Monografia",url:p("monografia","virgilio_tagliavini_2023.pdf")},{label:"Apresentao",url:p("apresentacao","virgilio_tagliavini_apresentacao_2023.pdf")}]},{id:202201,titulo:"INVESTIGAO DE TCNICAS DE OTIMIZAO PARA ALGORITMOS DE APRENDIZAGEM DE MQUINA",autor:"Andr Librio de Barros Ferraz",orientador:"Prof. Dr. Joo Paulo Papa",curso:"BCC",descricao:"Tendo em vista as inovaes tecnolgicas da ltima dcada, este trabalho busca, por meio de tcnicas como vetorizao utilizando AVX-512 e arcabouos computacionais para arquiteturas paralelas como o Galois, modificar algoritmos de aprendizado de mquina baseados em grafos, neste caso em particular, o OPF (OptimumPath Forest) com a finalidade de melhorar o seu tempo de execuo.Resultados apresentam ganhos significativos com o uso da tecnologia AVX-512, particularmente nas configuraes com 1 thread de at 26,84% se comparado a verso com uso de AVX2 e 112,83% se comparado a verso no vetorizada.Quanto ao Galois, fora realizado um estudo inicial que avaliou o desempenho do MST (Minimum Spanning Tree) e os resultados preliminares apontam um speedup de at 6x com o dataset Epinions. No futuro, esperase complementar a implementao do Galois para outros algoritmos de grafos baseados no OPF.",palavrasChave:["Computao de alto desempenho","Redes neurais","Informtica"],dataDefesa:"2022-07-01",links:[{label:"Monografia",url:p("monografia","andre_liborio_2022.pdf")},{label:"Apresentao",url:p("apresentacao","andre_liborio_apresentacao_2022.pdf")}]},{id:202202,titulo:"SISTEMA PARA GERENCIAMENTO DE DESPENSA COM UTILIZAO DE DATA VISUALIZATION",autor:"Karen Aya Murakawa",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"Com a gerao e o armazenamento de crescentes volumes de dados, tm-se destacado a aplicao de conceitos e tcnicas provenientes de diferentes reas do conhecimento com o propsito de auxiliar na anlise e na compreenso de tais elementos, os quais tm adquirido relevncia estratgica nos mais diversos contextos. Considerando-se o potencial da visualizao de dados no apoio  anlise e  transmisso de informaes de maneira precisa e simples, assim como os desafios existentes em relao  gesto de estoques de alimentos tanto nos ambientes residencial como corporativo, este trabalho teve como propsito o desenvolvimento de um prottipo de um aplicativo mvel voltado para o gerenciamento de despensas, com foco residencial, em que fosse possvel, atravs da consulta a representaes visuais dos dados, o acompanhamento e a avaliao de aes efetuadas com relao  aquisio, uso ou consumo, e descarte de alimentos, buscando-se subsidiar futuras tomadas de decises. Para o desenvolvimento do sistema, foram utilizadas como principais tecnologias, dentre outras, os frameworks Ionic e Angular, e a biblioteca Chart.js.",palavrasChave:["Gerenciamento de estoques de alimentos","Visualizao de dados","Aplicativo mvel"],dataDefesa:"2022-08-03",links:[{label:"Monografia",url:p("monografia","karen_aya_2022.pdf")},{label:"Apresentao",url:p("apresentacao","karen_aya_apresentacao_2022.pdf")}]},{id:202203,titulo:"AUXLIO AO DIAGNSTICO DE ELA E AVC ATRAVS DE EXPRESSO FACIAL",autor:"Leonardo Silva de Oliveira",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"O presente trabalho foca em verificar a possibilidade do auxlio ao diagnstico de pessoas que possuem ou no doenas neurolgicas atravs do estudo das expresses faciais. O trabalho utiliza a ferramenta de extrao de Action Units (py-feat) para extrair informaes de alguns vdeos, para serem analisados onde nesses vdeos voluntrios realizaram algumas tarefas de fala ou movimento olhando para a cmera. Atravs desses actions units extrados, uma anlise exploratria foi feita dos dados extrados e alguns testes de predio de classificao de algoritmos especficos de aprendizado de mquina para classificar quais dos pacientes possuam ou no algum tipo de doena. Por fim, o trabalho apresenta a concluso com base nos resultados que apresentaram pontuaes altas para tarefas e algoritmos especficos e depois alguns possveis trabalhos futuros.",palavrasChave:["Aprendizado Artificial","Reconhecimento Facial","Diagnstico de doenas neurolgicas","Actions Units","Inteligncia Artificial","Cincia de Dados"],dataDefesa:"2022-07-01",links:[{label:"Monografia",url:p("monografia","leonardo_silva_2022.pdf")},{label:"Apresentao",url:p("apresentacao","leonardo_silva_apresentacao_2022.pdf")}]},{id:202204,titulo:"RESOLUO DO PROBLEMA DE ESCALONAMENTO DE ENFERMEIROS EM HOSPITAL UTILIZANDO SIMULATED ANNEALING",autor:"Lucas Henrique Russo do Nascimento",orientador:"Prof. Dr. Andra Carla Gonalves Vianna",curso:"BCC",descricao:"O Problema de Escalonamento de Enfermeiros se baseia em definir em quais dias e turnos cada enfermeiro trabalhar respeitando a demanda do hospital. Geralmente, nas instituies hospitalares, essa escala  definida manualmente por uma pessoa responsvel a cada ms. Como a quantidade de combinaes possveis  muito grande, encontrar uma escala adequada pode levar muito tempo, alm de demandar muita experincia da pessoa encarregada. Este trabalho prope a resoluo do problema utilizando a metaheurstica Simulated Annealing para determinar uma soluo do Problema de Escalonamento de Enfermeiros. Os resultados so apresentados de forma a avaliar a qualidade da soluo obtida. Foram feitos diversos testes computacionais comprovando a viabilidade da metaheurstica proposta.",palavrasChave:["Problema de Escalonamento de Enfermeiros","Metaheursticas","Simulated Annealing","Otimizao Matemtica"],dataDefesa:"2022-08-01",links:[{label:"Monografia",url:p("monografia","lucas_henrique_2022.pdf")},{label:"Apresentao",url:p("apresentacao","lucas_henrique_apresentacao_2022.pdf")}]},{id:202205,titulo:"DETECO DE ESTEGANOGRAFIA EM IMAGENS UTILIZANDO APRENDIZADO DE MQUINA",autor:"Matheus Esquinelato Polachini",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Esteganografia em imagens se refere ao processo de incorporao de uma mesagem secreta em um arquivo de imagem sem causar mudana visual perceptvel a quem tenha acesso a essa imagem. Devido ao contnuo desenolvimento de novas tcnicas de esteganografia, h a necessidade de desenvolvimento de novas formas de deteco dessas tcnicas. Este trabalho buscou investigar a eficincia do uso de aprendizado de mquina na deteco das tcnicas de esteganografia LSB, PVD e JSteg em imagens utilizando a tcnica de aprendizado de mquina Support Vector Machine e caractersticas por mtricas de qualidade da imagem.",palavrasChave:["Esteganografia","Aprendizado de Mquina","Sistemas de Segurana","Support Vector Machine"],dataDefesa:"2022-08-03",links:[{label:"Monografia",url:p("monografia","matheus_esquinelato_2022.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_esquinelato_apresentacao_2022.pdf")}]},{id:202206,titulo:"FERRAMENTA DE COLETA E ANLISE DE DADOS DE LICITAES PBLICAS",autor:"Matheus Yuichi Yamashiro",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"O mundo conectado atual vm causando grandes mudanas no dia-a-dia das pessoas. Uma delas  a quantidade de informaes consumidas e produzidas. Isso vm crescendo de maneira to alarmante que j no  mais possvel analisar essas informaes de maneira manual.  necessrio automatiz-las. Contudo, a maneira que as pessoas pensam e se comunicam, seja pessoalmente ou por meios informatizados (pela internet),  fundamentalmente diferente da maneira que os computadores o fazem. Assim,  necessrio gerar mtodos e interfaces para que os computadores, capazes de processar um volume de dados muito maior que os humanos, entendam e utilizem os dados gerados pelas pessoas. A rea de pesquisa de Processamento de Linguagem Natural (PLN)  justamente isso, desenvolver tcnicas para que os computadores processem dados textuais gerados por- humanos-para-humanos de maneira automtica. Neste trabalho, foi realizado um estudo sobre esta rea de pesquisa, algumas tcnicas implementadas e aplicadas em dados de licitaes pblicas da Prefeitura de Bauru, e desenvolvida uma interface web para a visualizao dos resultados obtidos.",palavrasChave:["Processamento de Linguagem Natural","Desenvolvimento web","Licitaes Pblicas"],dataDefesa:"2022-08-01",links:[{label:"Monografia",url:p("monografia","matheus_yuichi_2022.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_yuichi_apresentacao_2022.pdf")}]},{id:202207,titulo:"CRIPTOWATCHER: ROB DE INVESTIMENTO EM CRIPTOMOEDAS UTLIZANDO ALGORITMO DE ARBITRAGEM TRIANGULAR",autor:"Maurcio Sugimoto Polloni",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"Por possurem alta volatilidade, criptomoedas, como Bitcoin, Ethereum, Dogecoin em um curto espao de tempo e em alta frequncia, tem expressiva variao de preos. O processo de negociaes, envolvendo o atos de compra ou venda destas criptomoedas, denominado trade, pode se mostrar ineficiente e inseguro se executado de forma manual. Neste cenrio, foi produzido um rob de investimentos para executar estas negociaes de forma automtica, ininterrupta e que conseguisse acompanhar a volatilidade das criptomoedas. Este rob foi desenvolvido utilizando a linguagem de programao Python e alocado na plataforma de computao em nuvem AWS. Nele foi implementado o algoritmo de arbitragem triangular, com objetivo de ganho tanto na alta, quanto na baixa. Como resultado foi feito um prottipo para monitorar os preos e executar aes de trade atravs da API da corretora de investimentos em criptomoedas Binance.",palavrasChave:["Criptomoedas","Algoritmo de Arbitragem","Arbitragem Triangular","Licitaes Pblicas"],dataDefesa:"2022-07-01",links:[{label:"Monografia",url:p("monografia","mauricio_sugimoto_2022.pdf")},{label:"Apresentao",url:p("apresentacao","mauricio_sugimoto_apresentacao_2022.pdf")}]},{id:202208,titulo:"SEGURANA EM WEB3 : VULNERABILIDADES EM CARTEIRAS DIGITAIS BASEADAS EM NAVEGADORES",autor:"Caio Castilho Donato Regal",orientador:"Prof. Me. Luiz Felipe de Camargo",curso:"BCC",descricao:"A aplicao de carteira de criptomoedas mais utilizada da rede Ethereum, Metamask, possui uma brecha que pode ser manipulada para ter acesso no permitido a uma conta.  apresentada essa falha, assim como  feito uma apresentao sobre os processos envolvidos com a chave privada e a chave publica utilizadas pela Blockchain, como elas so geradas e armazenadas pela aplicao de navegadores Metamask, alm de expor mtodos de criptografia como a criptografia de curva elptica e a criptografia assimtrica. So propostas mudanas na aplicao para reparar esse problema de segurana, como o uso do endereo MAC do computador para ser usado na criptografia, apesar de conseguir fazer uma prova do conceito o resultado no  o suficiente para ser implementado na aplicao real.",palavrasChave:["Ethereum","Metamask","Navegadores","Sandbox","Segurana da informao","Criptografia","Criptografia de curva elptica"],dataDefesa:"2023-01-30",links:[{label:"Monografia",url:p("monografia","caio_castilho_2022.pdf")}]},{id:202209,titulo:"MDULO DE RECONHECIMENTO DE GESTOS PARA AMBIENTES DE REALIDADE AUMENTADA",autor:"Davi Augusto Neves Leite",orientador:"Prof. Dr. Antonio Carlos Sementille",curso:"BCC",descricao:"A Realidade Aumentada pode ser definida como a rea responsvel por enriquecer o mundo real por meio da combinao de objetos gerados por computador. Por conta disso, a Realidade Aumentada possui grande potencial para ser aplicada nas mais diversas reas, como Educao, Medicina, Marketing e rea Industrial, uma vez que beneficia qualquer tarefa que necessite de acesso a uma informao que no teria normalmente. Contudo, a dificuldade na utilizao da interatividade natural nas solues recentes de Head-Mounted Displays voltadas para smartphones tem sido um dos principais obstculos para a acessibilidade e popularizao da Realidade Aumentada. Desta forma, era de interesse do projeto estruturar, implementar e avaliar um mdulo reconhecedor de gestos de mo para ambientes de Realidade Aumentada. Os experimentos propostos consistiam na realizao de aes diretas e indiretas do usurio, com relao aos objetos virtuais, em diferentes cenrios da Realidade Aumentada, baseados em tarefas. Os resultados obtidos mostraram a viabilidade do mdulo em aplicaes de Realidade Aumentada com o uso de Head-Mounted Displays Video See-Through baseados em smartphones para tarefas em que a preciso no  um requisito fundamental.",palavrasChave:["Realidade Aumentada","Interao por Gestos de Mo","Head-Mounted Displays","MediaPipe Hands","Vuforia"],dataDefesa:"2023-01-19",links:[{label:"Monografia",url:p("monografia","davi_augusto_2022.pdf")}]},{id:202210,titulo:"APLICAO DE TCNICAS DE ENSEMBLE LEARNING NA DETECO ESTTICA E DINMICA DE MALWARES",autor:"Denis Henrique dos Santos",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Com o constante aumento do uso de tecnologia no dia a dia a importncia da segurana da informao cresce drasticamente, levando  existncia de malwares ser uma ameaa ao funcionamento de sistemas e dados importantes, requisitando formas de combat-los. Modelos de ensemble learning so modelos de aprendizado de mquina que utilizam vrios algoritmos para chegar a resultados de um determinado problema. Este trabalho prope um sistema de deteco de malware utilizando modelos ensemble learning dos tipos bagging, boosting e stacking, usando o conjunto de dados Malevis para anlise esttica e o conjunto de dados Top-1000 PE Imports para anlise dinmica. Os modelos foram treinados e os resultados foram comparados com outro sistema de deteco de malware. Os resultados obtidos foram satisfatrios, especialmente os da anlise dinmica, com modelos do tipo bagging e stacking mostrando maior desempenho em ambos os cenrios, enquanto que os modelos do tipo boosting apresentaram maior dificuldade em chegar a resultados mais eficazes com os conjuntos de dados usados.",palavrasChave:["Malware","Aprendizado de mquina","Ensemble learning"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","denis_henrique_2022.pdf")}]},{id:202211,titulo:"JOGO SRIO PARA SIMULAO E CONSCIENTIZAO DE PROBLEMAS RELACIONADOS  MOBILIDADE URBANA",autor:"Eduardo Antonio Comero Stecca Almeida",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"Conforme a criao e o aperfeioamento de novas tecnologias, dispositivos mveis capazes de executar softwares que demandam muito poder computacional atingiram grande destaque na nossa sociedade, atuando hoje em reas fundamentais da nossa economia, como: transporte, alimentao e hospedagem. Pode-se, tambm, utilizar tais dispositivos para melhorar a qualidade de vida, a educao e o acesso  informao. Uma das maneiras de facilitar tais processos  a utilizao de jogos srios no compartilhamento de informaes sobre problemas de difcil compreenso. O trabalho aqui apresentado, trata-se de um jogo srio desenvolvido para simular e expor alguns dos muitos problemas de acessibilidade urbana. O jogo: WheelChair Simulator , utiliza ferramentas atuais de desenvolvimento de jogos multiplataformas, como tambm aplica conceitos de imerso, simulao e experincia do usurio. Voltado para adolescentes e jovens adultos que possuem acesso a um dispositivo mvel, com objetivo de melhorar a compreenso e a incluso social. Utilizando uma rea pouco explorada da Computao na divulgao de tais problemas e incentivar mais pesquisas nessa rea de estudo no ramo de tecnologia da informao.",palavrasChave:["Jogos Srios","Acessibilidade Urbana","Simulao, Dispositivos Mveis"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","eduardo_antonio_2022.pdf")}]},{id:202212,titulo:"INTELIGNCIA ARTIFICIAL EXPLICVEL COM LIME E SHAP APLICADA  REDE NEURAL CONVOLUCIONAL",autor:"Fabricio Steinle Amoroso",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"Modelos de inteligncia artificial esto presentes na vida cotidiana nos mais diversos contextos, como sistemas mdicos para auxlio na deteco de doenas e motores de busca, estando, por vezes, presentes at de maneira transparente aos usurios como no caso de algoritmos de recomendao de produtos. Ao passo que a adoo de IA cresce, a complexidade dos sistemas de inteligncia artificial tambm aumenta, tornando mais desafiadora a tarefa de compreender como foi obtido determinado resultado. Refere-se a estes modelos complexos como caixa-preta, devido  sua dificuldade de interpretao. Inteligncia artificial explicvel pode ser utilizada para compreender como os modelos complexos, como redes neurais convolucionais, que so amplamente aplicados, chegam a seus resultados.  proposto neste projeto de concluso de curso, implementar tcnicas de inteligncia artificial explicvel utilizando duas das ferramentas mais populares neste contexto: LIME e SHAP, ambas aplicadas a um modelo de rede neural convolucional utilizado para classificar imagens de exames mdicos de escrita, pertencentes a um grupo de indivduos saudveis e outro grupo de pacientes de Parkinson. Atravs dos resultados obtidos foi possvel obter explicaes sobre o modelo descrito que podem ser interpretadas por seres humanos.",palavrasChave:["Inteligncia Artificial Explicvel","LIME","Parkinson","Rede Neural Convolucional","SHAP"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","fabricio_steinle_2022.pdf")}]},{id:202213,titulo:"TRABALHANTE : REDE SOCIAL PARA FACILITAR TURNOVER EM TRABALHOS ROTATIVOS",autor:"Felipe Kroitor Cara Modena",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"O turnover  uma medida usada para avaliar a rotatividade de funcionrios em uma empresa, ou seja, o nmero de funcionrios que deixam a empresa em um determinado perodo de tempo.  considerado um indicador importante da sade e da cultura organizacional de uma empresa, pois pode indicar problemas como falta de satisfao no trabalho, baixa remunerao ou falta de oportunidades de crescimento. A proposta apresentada  de desenvolver uma rede social, onde os usurios podem criar perfis, se conectar com outros profissionais e compartilhar suas experincias de trabalho. Os usurios tambm podem avaliar as empresas e funcionrios com os quais trabalharam, informando o nvel de satisfao no trabalho, a remunerao e o nvel de oportunidades de crescimento oferecidas. Com essas informaes, o software cria uma base de dados completa e atualizada sobre as empresas e funcionrios avaliados, permitindo que outros profissionais vejam as avaliaes e tomem decises informadas sobre suas carreiras. Alm disso, as empresas tambm podem acessar o software e ver as avaliaes de seus funcionrios, o que as ajuda a entender melhor os pontos fortes e fracos de sua cultura organizacional e a tomar medidas para melhorar a satisfao no trabalho de seus funcionrios.",palavrasChave:["rotatividade profissional","software","empresas","inteligncia de negcios","contratao","rede social","recomendao profissional","inovao"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","felipe_kroitor_2022.pdf")}]},{id:202214,titulo:"SOFTWARE PARA GESTO DE INVENTRIO DE CRDITO DE CARBONO VISANDO A COMPENSAO DA EMISSO DE GASES DE EFEITO ESTUFA",autor:"Gabriel Dadamos Rossetto",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"A reduo das emisses de gases com efeito de estufa  fundamental na luta contra as alteraes climticas, uma vez que estas as emisses contribuem para o aquecimento global e tm uma srie de impactos negativos no meio ambiente e na sade humana. Os crditos de carbono so uma ferramenta importante para alcanar redues de emisses, pois fornecem um incentivo financeiro para que as empresas reduzam suas emisses, permitindo-lhes venderem crditos por cada tonelada de dixido de carbono que reduzem ou removem da atmosfera. Ao usar crditos de carbono para recompensar pelas redues de emisses, governos e empresas podem encorajar o desenvolvimento e implementao de tecnologias e prticas limpas, assim ajudando a reduzir o nvel geral de emisses de gases do efeito estufa. Este projeto de software visa ajudar as empresas a rastrear e controlar suas emisses de gases do efeito estufa, a fim de cumprir os requisitos regulamentares e reduzir o seu impacto ambiental. Usando o mtodo de linha de base, o software calcula o saldo de crditos de carbono aos quais uma empresa tem direito com base em suas redues de emisses. Alm disso, o software gera relatrios sobre o desempenho da empresa referente as emisses que podem ser submetidas aos rgos reguladores. Ao fornecer uma interface fcil de usar para o rastreamento e gerao de relatrios de emisses, este software visa facilitar com que empresas possam demonstrar seu compromisso com a sustentabilidade e cumprir suas metas de reduo de emisses.",palavrasChave:["Crdito de Carbono","Gas do Efeito Estufa","Aquecimento Global","Sustentabilidade"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","gabriel_dadamos_2022.pdf")}]},{id:202215,titulo:"USO DA COMPUTAO GRFICA PARA ENSINO DE ASTRONOMIA: DESENVOLVIMENTO DE UM SOFTWARE EDUCACIONAL UTILIZANDO UNITY",autor:"Gabriel Francisco Sahm Gallo",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"Com o passar do tempo, percebeu-se que os alunos esto cada vez mais tecnolgicos, porm o modo de ensinar e as ferramentas utilizadas pelos docentes no esto acompanhando essa mudana, principalmente na rea de Astronomia. Durante o ensino de Astronomia, alguns temas so explicados de modo que o aluno consiga entender, porm nos assuntos complexo, tais como a comparao de tamanho dos planetas no  possvel ter um total entendimento. Para resolver tal problema, este trabalho apresenta um software educativo que tem o objetivo de simular o Sistema Solar para auxiliar os docentes  explicarem e apresentarem conceitos de Astronomia, tais como as escalas, velocidades, movimentos e rbitas dos objetos celestiais.",palavrasChave:["Astronomia","Ensino","Softwares educativos","Simulador"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","gabriel_francisco_2022.pdf")}]},{id:202216,titulo:"UMA APLICAO WEB PARA ANLISE COMPARATIVA DE META-HEURISTICAS DE OTIMIZAO",autor:"Giovani Candido",orientador:"Prof. Dr. Joo Paulo Papa",curso:"BCC",descricao:"Nas ltimas dcadas, a demanda por uma melhor administrao de recursos como tempo e dinheiro tem crescido na sociedade, fazendo com que problemas de otimizao sejam cada vez mais estudados por reas como pesquisa operacional e cincia da computao. No entanto, as tcnicas tradicionais de otimizao no so eficientes para lidar com os problemas desafiadores encontrados no mundo real. Nesse cenrio, as meta-heursticas se apresentam como uma alternativa interessante, uma vez que so capazes de encontrar solues satisfatrias para inmeros problemas. Logo, faz-se necessrio o desenvolvimento de uma ferramenta que traga as mais populares entre essas abundantes tcnicas, acompanhadas de distintos problemas artificiais de teste que traduzam suas performances, viabilizando a rpida realizao de anlises comparativas. Neste trabalho, estudou-se as meta-heursticas e as funes de teste mais empregadas na literatura, visando a criao de um ambiente web. Dentre as funcionalidades dessa aplicao, pode-se citar o ajuste de parmetros de execuo, a apresentao do progresso das tarefas em tempo real, a persistncia dos dados de execuo, a apresentao dos resultados juntamente com dados estatsticos e a produo de grficos de convergncia.",palavrasChave:["Aplicao Web","Anlise Comparativa","Meta-heursticas","Funes de Teste","Otimizao Matemtica"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","giovani_candido_2022.pdf")}]},{id:202217,titulo:"APLICAO DE ALGORITMO GENTICO PARA ROTEIRIZAO E CARREGAMENTO DE VECULO",autor:"Giulia Rossatto Rocha",orientador:"Prof. Dr. Mrcia A Zanoli Meira e Silva",curso:"BCC",descricao:"A globalizao  responsvel pelo surgimento de um maior nmero de clientes exigentes quanto  prazos e qualidade de entrega de mercadorias. Nesse sentido, a capacidade em atender s necessidades dos clientes, com qualidade e com baixo custo despendido  uma urgncia no contexto de concorrncia entre empresas de transporte, distribuio e coleta. A logstica e a gesto apresentam-se como estratgias para realizar a organizao e planejamento dos recursos empresariais de forma a maximizar a execuo de pedidos. No entanto, no mbito da gesto de transportes h dificuldades no planejamento e roteirizao dos veculos envolvidos de modo a determinar o melhor percurso, com menor gasto de tempo e recursos operacionais. O presente trabalho teve por objetivo a construo de um software capaz de realizar a roteirizao de um veculo que percorra a menor distncia possvel entre as localidades pr-definidas por um usurio, considerando uma possvel limitao de carga do veculo e uma cidade inicial que servir como depsito. Foram utilizados Algoritmos Genticos que so meta-heursticas baseadas no conceito de evoluo dos seres vivos e no processo de seleo natural, visto que o Problema de Roteirizao de Veculos Capacitados (PRVC) e que o Problema do Caixeiro Viajante (PCV) so chamados de problemas NP-difcil e, portanto, no so capazes de gerar uma soluo tima em tempo computacional vivel com algoritmos polinomiais ou tcnicas tradicionais da pesquisa operacional. O software desenvolvido consiste em uma aplicao web, desenvolvida em Python, com a utilizao do micro framework Flask e do framework Bootstrap para estilizao das pginas. Finalmente, o algoritmo desenvolvido foi submetido a diversos testes, alterando alguns parmetros como o processo de seleo, cruzamento e mutao. Verificou-se que o algoritmo gentico se apresenta como uma tima alternativa para a soluo do problema, pois permite a utilizao de variedades de parmetros, apresentando timos resultados em um tempo positivo. Por fim, verificou-se que o operador de mutao SM no apresentou bons resultados para obteno da menor distncia possvel, enquanto os operadores que se destacaram foram os operadores de cruzamento OX e PMX e os operadores de mutao EM, SIM e DM, tanto em questo de tempo quanto em melhor soluo obtida.",palavrasChave:["Meta-heurstica","Algoritmo Gentico","Roteamento de veculos"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","giulia_rossatto_2022.pdf")}]},{id:202218,titulo:"SISTEMA DE GERENCIAMENTO DE UMA FAZENDA",autor:"Guilherme Vieira Siena Martins",orientador:"Prof. Dr. Andra Carla Gonalves Vianna",curso:"BCC",descricao:"O agronegcio  um dos principais setores da economia brasileira, chegando a compor 27,4% do PIB nacional em 2021, porm mesmo com essa grande quantidade de dinheiro circulando muitas propriedades rurais esto atrasadas no requisito tecnolgico, sendo que 70% delas no possuem conexo com a internet. Mesmo com tamanha importncia, essas propriedades ainda so gerenciadas e tem seus processos feitos de maneira muito informal e isso acaba gerando problemas. Um termo que resume a necessidade de tecnologia no campo  agricultura 4.0, tambm conhecida como agricultura digital. Para resolver o problemas como esses foi modelado um banco de dados relacional, um modelo de otimizao para produo de rao englobados por uma interface grfica utilizando a linguagem python. Os conceitos utilizados no desenvolvimento do trabalho envolvem o processo de criao de um produto real com a possibilidade de ser comercializvel. A interface  simples facilitando o uso dos fazendeiros.",palavrasChave:["Agropecuria","Python","Tecnologia da Informao"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","guilherme_vieira_2022.pdf")}]},{id:202219,titulo:"PARALELIZAO DA TCNICA DE EXTRAO DE PONTOS DE INTERESSE FOAGDD UTILIZANDO A ARQUITETURA CUDA",autor:"Gustavo Henrique Stahl",orientador:"Prof. Dr. Antonio Carlos Sementille",curso:"BCC",descricao:"Consoante com o desenvolvimento tecnolgico atual que, cada vez mais, solicita abordagens que conectem o meio analgico e digital de maneira interativa, ou seja, funcionando em tempo real, o presente trabalho busca auxiliar nesse cenrio ao acelerar uma das tcnicas de extrao de pontos de interesse em imagem presente no estado da arte da categoria, uma vez que so densamente utilizadas em reas como realidade aumentada, veculos autnomos, robs de servio, reconstruo 3D, e diversas outras que necessitam produzir resultados rpidos e frequentes. O mtodo escolhido para o aperfeioamento  o extrator de cantos FOAGDD (First-order Anisotropic Gaussian Direction Derivative) e seu processo de otimizao se sustentou na massiva paralelizao possibilitada pela arquitetura CUDA (Compute Unified Device Architecture) da NVIDIA. Os resultados obtidos com a melhoria proposta se mostraram promissores. Primeiramente, a sada produzida pela implementao original do mtodo e a paralelizada em CUDA se mostraram muito similares, aps serem testadas e comparadas em um conjunto de 28 imagens. Por ltimo, o cdigo proposto trouxe um Speed-up no tempo de execuo de aproximadamente 3190 (66,03 segundos  20,70 milisegundos) em relao  implementao original do FOAGDD, utilizando como base uma imagem padronizada de resoluo 512  512 pixels.",palavrasChave:["Computao de alto desempenho","NVIDIA CUDA","Extrator de pontos de interesse"],dataDefesa:"2023-01-24",links:[{label:"Monografia",url:p("monografia","gustavo_henrique_2022.pdf")}]},{id:202220,titulo:"SOBRE DETECO DE INTRUSO COM APRENDIZADO DE MQUINA: ESTUDO DA APLICAO DE ENSEMBLE LEARNING E CLUSTERIZAO NA MELHORIA DE DESEMPENHO",autor:"Ina Soares de Figueiredo",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Sistemas de deteco de intruso em redes de computadores tm uma grande importncia na manuteno da segurana de uma rede e so foco constante de pesquisas que buscam aprimorar IDSs j existentes ou desenvolver novos ainda melhores. Este trabalho apresenta um estudo dos modelos de aprendizado de mquina autoencoder e Restricted Boltzmann Machine, comprovadamente efetivos na deteco de intruso. Os modelos so comparados e busca-se melhor-los por meio da aplicao de tcnicas de clusterizao e ensemble learning (majority-voting). As mtricas mostraram-se pouco afetadas pela aplicao das tcnicas de melhoria individualmente, mas bons resultados foram obtidos ao combin-las, alando 84,71% de acurcia e 91,31% F1-score no dataset KDD99.",palavrasChave:["Sistema de deteco de intruso","aprendizado de mquina","redes de computadores"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","inae_soares_2022.pdf")}]},{id:202221,titulo:"DESENVOLVIMENTO DE UM SISTEMA DE SIMULAO COMPUTACIONAL DE OCORRNCIA DE CHUVAS",autor:"Joo Pedro Olimpio",orientador:"Prof. Dr. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"O presente trabalho objetiva o desenvolvimento de um sistema de simulao computacional que seja capaz de representar o regime de chuvas para a cidade de Bauru, So Paulo. Para tanto, sero considerados dois aspectos do fenmeno precipitao: a possibilidade de sua ocorrncia em determinado dia e a probabilidade de acontecer em certa intensidade. A possibilidade de ocorrncia ser gerada a partir do uso do conceito de cadeia de Markov, que  uma sequncia finita de estados, na qual a transio a um estado presente apenas depende do estado que imediatamente o antecede. Neste trabalho, cada estado representa um dia do ano, que possui uma probabilidade de transio para o dia seguinte calculada com base no padro de chuvas dos dados analisados. J a intensidade de chuva ser determinada por uma distribuio de probabilidades em classes de magnitude, de forma que cada classe possua uma condio de entrada que, se satisfeita, ir determinar em qual faixa de magnitude a chuva do dia ocorrer. Os intervalos de tempo analisados, para gerar os valores de probabilidade, sero variados com o objetivo de validar a hiptese de que, ao se utilizar perodos menores, maior  a fidelidade do modelo de simulao ao sistema real e melhor  o resultado simulado, em termos de sua assertividade.",palavrasChave:["sistema de simulao","chuva","cadeia de Markov"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","joao_pedro_2022.pdf")}]},{id:202222,titulo:"PROGRAMAO DAS BOMBAS HIDRULICAS PARA OTIMIZAO ENERGTICA EM SISTEMAS DE ABASTECIMENTO DE GUA UTILIZANDO PYTHON E O SOFTWARE EPANET",autor:"Larissa de Castro Bonadio",orientador:"Prof. Dr. Edilane Martins Soler",curso:"BCC",descricao:"A gua  um recurso natural e essencial que garante o bem-estar e sade da populao. Para a populao humana usufruir desse recurso  fundamental a utilizao dos sistemas de abastecimento de gua. Em diversas etapas de seu funcionamento a energia eltrica  usada, principalmente pelas bombas hidrulicas, as quais so empregadas para viabilizar a transferncia de gua de um ponto inferior para um superior, contudo esse processo apresenta um alto custo energtico. Neste contexto, para auxiliar o desenvolvimento do planejamento da operao das bombas hidrulicas, os modelos e mtodos de otimizao e simuladores hidrulicos so utilizados como ferramenta. Desse modo, esse trabalho desenvolveu um software, em linguagem de programao Python, que verifica a aplicabilidade da soluo obtida pelo modelo matemtico de otimizao energtica desenvolvido por Parras (2020), de forma a analisar a soluo proposta por ele, e simul-la no simulador hidrulico EPANET.",palavrasChave:["Otimizao","Sistema de Abastecimento de gua","EPANET","Python"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","larissa_bonadio_2022.pdf")}]},{id:202223,titulo:"VISUALIZAO DE DADOS E ANLISE DO MERCADO DE AES BRASILEIRO",autor:"Luciano Eiji Tanaka",orientador:"Prof. Dr. Joo Pedro Albino",curso:"BCC",descricao:"O mercado de aes  uma das reas mais populares dentro do mercado financeiro, hoje em dia, atravs da popularizao da internet, da mdia e da democratizao da informao, tornou-se uma das formas mais comuns de obteno de renda alternativa. A previso do preo das aes sempre foi muito pesquisada, mas devido  sua natureza dinmica e voltil,  considerada uma das tarefas mais difceis no campo da matemtica e da cincia da computao. O mercado  afetado por vrios fatores macroeconmicos, como polticas governamentais, relaes internacionais, cenrio econmico, expectativas e psicologia dos investidores, etc. O presente trabalho busca combinar sistemas inteligentes para prever os preos finais das aes do ndice Bovespa, que so as mais consolidadas e negociadas no mercado. Conceitos sobre mercado financeiro, aprendizado de mquina e visualizao de dados sero estudados para dar suporte ao projeto. Foram propostos modelos para analisar e encontrar padres nos preos das aes, bem como indicar tendncias de longo prazo, e por fim a implementao do projeto para uso geral. Para as anlises foram utilizados os dados de janeiro de 2012 a julho de 2022, disponveis na seo de cotaes histricas diretamente do site da B3. O estudo foi desenvolvido utilizando redes neurais e uma mquina de vetores de suporte utilizando dados do preo de fechamento das aes negociadas na bolsa de valores.",palavrasChave:["Redes neurais","redes neurais artificiais","mquina de vetor de suporte","mercado de aes","LSTM","previso de valores","cincia de dados"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","luciano_eiji_2022.pdf")}]},{id:202224,titulo:"SISTEMA DE RECONHECIMENTO BIOMTRICO DE MLTIPLAS PESSOAS BASEADO EM MTODOS DE ESTIMAO DE POSE E RASTREAMENTO DE OBJETOS",autor:"Lus Henrique Morlli",orientador:"Prof. Dr. Aparecido Nilceu Marana",curso:"BCC",descricao:"A biometria se tornou uma importante ferramenta para identificao de indivduos nas mais diversas reas, usada para evitar fraudes e aumentar a segurana dos cidados na sociedade. A marcha tem sido proposta como caracterstica biomtrica, visto que humanos possuem formas distintas de caminhar. Ela  particularmente importante para a identificao de pessoas  distncia. Na maioria das pesquisas encontradas na literatura, os mtodos de reconhecimento de marcha limitam-se a cenrios em que h apenas um indivduo caminhando, quando, em situaes mais realistas,  comum existirem vrias pessoas. Os mtodos atuais de reconhecimento de marcha no podem ser aplicados em cenrios multimarcha. Sendo um problema mais desafiador, para atingir tal objetivo, so necessrios mtodos de deteco e rastreamento de pessoas. O DeepSORT  um mtodo de rastreamento de mltiplos objetos que utiliza mtricas de associao profunda e vem obtendo bons resultados na tarefa. Este trabalho prope a construo de um sistema biomtrico capaz de identificar pessoas atravs de sua marcha e das medidas antropomtricas, empregando mtodos de estimao de poses e rastreamento e reidentificao de objetos. Para tal efeito, um mtodo de reconhecimento de mltiplas pessoas  proposto. O mtodo foi implementado e avaliado em duas bases de dados pblicas, a CASIA Gait Dataset-A e a SMVDU-Multi-Gait, alm de uma base de dados privada, coletada para validao do sistema biomtrico que foi construdo incorporando o mtodo proposto. Os resultados obtidos mostram que essa abordagem  adequada em cenrios de caminhada individual e em grupo, apresentando bom desempenho na identificao de indivduos e robustez para configurar como soluo de baixo oramento em sistemas visuais inteligente.",palavrasChave:["Biometria","Estimao de Poses","Rastreamento e Reidentificao de Objetos","Reconhecimento de Marcha","Medidas Antropomtricas"],dataDefesa:"2023-01-19",links:[{label:"Monografia",url:p("monografia","luis_henrique_2022.pdf")}]},{id:202225,titulo:"UMA APLICAO WEB PARA ANLISE COMPARATIVA DE SELEO DE CARACTERSTICAS BASEADAS EM META-HEURISTICAS",autor:"Luiz Fernando Merli de Oliveira Sementille",orientador:"Prof. Dr. Joo Paulo Papa",curso:"BCC",descricao:"Nos dias atuais,  notrio o crescimento da importncia que as tcnicas de aprendizado de mquina tm tido em virtude da massiva quantidade de dados presentes na Internet. Dentre as situaes em que o aprendizado de mquina pode ser empregado, pode-se citar a deteco de tumores em exames mdicos, a identificao de perfis de consumo e a deteco de intruses em redes de computadores. Diante desse contexto, uma das etapas mais importantes para que um sistema de aprendizado tenha desempenhos satisfatrios  a seleo de aractersticas. Esta etapa envolve aplicar algoritmos ao vetor de caractersticas, com a finalidade de encontrar um subconjunto deste vetor tal que aumente a acurcia na classificao e reduza a complexidade do modelo de aprendizado, podendo assim ser compreendida como um problema de otimizao NPDifcil. Deste modo, a utilizao de mtodos determinsticos no apresenta bom desempenho, tornando as meta-heursticas, tcnicas que se baseiam em comportamentos timos encontrados na natureza, excelentes candidatas para esse tipo de problema. Assim sendo, o presente projeto visa o desenvolvimento e implementao de uma aplicao web cujo objetivo  permitir a comparao de tarefas de seleo de caractersticas baseadas em tcnicas meta-heursticas.",palavrasChave:["Aplicao Web","Seleo de Caractersticas","Meta-Heurstica"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","luiz_fernando_2022.pdf")}]},{id:202226,titulo:"ANLISE DO CRESCIMENTO DA INDSTRIA DOS JOGOS DIGITAIS",autor:"Michel Marques Mbakirtzis",orientador:"Prof. Dr. Joo Pedro Albino",curso:"BCC",descricao:"Este trabalho possui como objetivo entender o contexto que tem levado ao expressivo crescimento histrico da indstria de jogos digitais ao redor do mundo, partindo de pesquisas bibliogrficas sobre as caractersticas dessa indstria, este trabalho se prope a identificar elementos mercadolgicos, tecnolgicos, sociais e pandmicos que contriburam positivamente para o aumento do faturamento e crescimento da base de usurios. Aps realizada a abordagem das principais caractersticas do mercado de jogos, este trabalho apresenta um modelo de visualizao em Dashboard desenvolvido em Power BI, apresentando de modo dinmico e interativo o progresso dos nmeros obtidos pelo setor de jogos digitais desde seus primrdios.",palavrasChave:["Jogos Digitais","Dashboard","Power BI"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","michel_marques_2022.pdf")}]},{id:202227,titulo:"ORGANIZADOR DE ROTINAS DINMICO",autor:"Rafael Kawagoe Gomes Muller",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"A Agenda  uma aplicao mobile que permite aos usurios gerenciar e organizar seus eventos e tarefas de maneira dinmica. Ela foi desenvolvida usando o Flutter, um popular framework de cdigo aberto para a criao de aplicativos mveis cross-platform. Para garantir a qualidade e a manuteno da base de cdigo, utilizou-se vrias tcnicas de engenharia de software, como boas prticas na nomenclatura de variveis, mtodos e classes, e a aplicao dos conceitos de SOLID. Essas prticas ajudaram a identificar e corrigir bugs, bem como evitar o surgimento de novos. O aplicativo de Agenda possui uma interface amigvel e intuitiva ao usurio. Ele foi desenvolvido para ser usado em dispositivos Android. No geral, o desenvolvimento do aplicativo de agenda usando Flutter e tcnicas de engenharia de software resultou em uma ferramenta confivel e eficaz para gerenciar tarefas, e que foi feita em um projeto escalvel e de fcil manuteno.",palavrasChave:["Aplicativo Mobile","Engenharia de Software","Flutter","Clean Code","Clean Architecture"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","rafael_kawagoe_2022.pdf")}]},{id:202228,titulo:"DASHBOARD PARA ANLISE DE DADOS CLIMTICOS DE BAURU",autor:"Rafael Mendes Costa",orientador:"Prof. Dr. Joo Pedro Albino",curso:"BCC",descricao:"A energia eltrica pode ser comercializada pelo mercado livre ou pelo mercado regulado pelo governo, onde os consumidores no possuem a liberdade de escolha de fornecedor nem negociao. J no mercado livre consumidores e fornecedores de energia podem interagir atravs das comercializadoras para negociar energia eltrica. Isso acontece atravs da compra de energia do fornecedor pelo comercializador e a venda dessa energia para o consumidor. No Brasil a matriz energtica depende de 70% de energia gerada por hidreltricas e na regio de Bauru existe a hidreltrica de Iacanga. Sistemas para Anlise de Dados Climticos so importantes para a comercializao de energia e commodities no mercado. O painel de controle para anlise de dados em Bauru permite que o usurio tenha acesso aos dados climticos da regio de Bauru, dando mais segurana nas negociaes de energia gerada pela hidreltrica de Iacanga feitas pelos comercializadores de energia. A aplicao foi desenvolvida usando React, Javascript, Python e Pandas. Alm disso, o projeto foi desenvolvido seguindo tcnicas de boas prticas adotadas por cada um das linguagens e princpiosSOLID.",palavrasChave:["Previso de temperatura","Previso de chuva","Anlise de dados","Dashboard"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","rafael_mendes_2022.pdf")}]},{id:202229,titulo:"CAMINHO TIMO EM MALHA DINMICA BIDIMENSIONAL",autor:"Rafael Nunes Caseiro",orientador:"Prof.Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"Dado um meio fsico ou virtual, a busca por um caminho timo entre dois ou mais pontos  uma problemtica muito estudada na computao, possuindo uma srie de solues j validadas, como o algoritmo de Dijkstra e A. O problema  relevante para um vasto espectro de aplicaes, incluindo trfego de redes, planejamento robtico, simulaes e jogos de computador. No entanto, cada aplicao possui um conjunto de requisitos e restries particular, tornando necessria a adaptao de solues a cada caso especfico. No caso de malhas dinmicas bidimensionais o algoritmo A  comumente utilizado, fornecendo a soluo de forma gil e precisa, e sendo fcil de adaptar. Este trabalho traz uma anlise terica sobre o problema do caminho timo, partindo de uma perspectiva generalizada, a qual , ento, restringida a uma malha dinmica bidimensional, a ser percorrida por um agente virtual, utilizando o algoritmo A*.",palavrasChave:["Caminho timo","Malha dinmica","Dijkstra","A*"],dataDefesa:"2023-01-20",links:[{label:"Monografia",url:p("monografia","rafael_nunes_2022.pdf")}]},{id:202230,titulo:"GAMIFICAO DE EXERCCIOS FSICOS COM LOUSA INTELIGENTE",autor:"Rafael Ragozoni Conrado",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"Realizar atividades fsicas so importantes para uma vida saudvel e equilibrada. Existem muitos exerccios fsicos elaborados de forma a estimular diferentes aspectos do corpo, como o sistema cardiovascular ou cada um dos tecidos musculares, a fim de buscar otimizar seus benefcios. Porm,  possvel observar certa resistncia a sua realizao rotineira tendo em vista sua natureza montona e repetitiva. Com o objetivo de superar essa barreira presente em diversas tarefas, pode-se recorrer a gamificao, que usa elementos tpicos de jogos, sobretudo digitais, para tornar mais interessante quaisquer atividades. Foram utilizados conceitos de gamificao aplicados no contexto de exerccio fsico para buscar estimular a realizao de atividade fsica entre adultos, e contribuir para a manuteno de uma vida ativa entre os usurios. Isso foi feito por meio de um software gamificado feito na plataforma Unity para ser usado na lousa inteligente Huawei IdeaHub que conta com um sistema operacional Windows e uma cmera. O software possui um menu com estatsticas, conquistas e exerccios com descrio da atividade. Com isso, o usurio realiza exerccios providenciados pelo software, visualizando informaes sobre a atividade e com a cmera do IdeaHub, capturando os movimentos para contar os exerccios.",palavrasChave:["Gamificao","Lousa Inteligente","Exerccios Fsicos"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","rafael_ragozoni_2022.pdf")}]},{id:202231,titulo:"UMA ESTRATGIA DE FUTEBOL DE ROBS BASEADA EM APRENDIZADO POR REFORO",autor:"Rodrigo Cesar Barboza Rossetti",orientador:"Prof. Dr. Ren Pegoraro",curso:"BCC",descricao:"O uso de tcnicas de aprendizado de mquina se popularizou muito nos ltimos anos com avanos em diversas reas como carros autnomos, gerao de imagens e texto. O futebol de robs, onde vrios agentes interagem,  um ambiente propcio para aplicao e verificao de tcnicas de aprendizado. Neste trabalho foi aplicado tcnicas de aprendizado por reforo para treinar uma estratgia de futebol de robs completamente autnoma para mitigar os problemas da estratgia baseada em autmatos finitos determinsticos. Para tal, o ambiente do futebol de robs do time Carrossel Caipira foi adaptado como um problema padronizado de aprendizado por reforo utilizando a biblioteca Gym e ento treinado com o algoritmo Soft Actor-Critic com implementao da biblioteca Stable Baselines 3, por ser ideal para problemas com espaos de ao contnuos. Inicialmente, o goleiro foi treinado junto ao volante e atacante da estratgia anterior para fins de testes antes de continuar o treinamento junto ao volante e atacante atuais ao se constatar que o ambiente estava funcionando e o goleiro aprendendo. As recompensas obtidas durante o treinamento foram salvas e analisadas graficamente junto ao comportamento dos jogadores observado durante o treinamento. Para o goleiro, ele aprendeu a defender o gol conforme o aprendizado progrediu, mas para o volante e atacante  necessrio mais tempo de treinamento para aprenderem bem suas posies. Tambm foi possvel observar a tendncia de posicionamento dos robs em certas posies do campo para maximizar suas recompensas. O trabalho foi desenvolvido com base nas regras da competio IEEE Very Small Size Soccer da qual participa a equipe Carrossel Caipira.",palavrasChave:["Aprendizado profundo","Aprendizado por reforo","Futebol de Robs"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","rodrigo_cesar_2022.pdf")}]},{id:202232,titulo:"UM SISTEMA DE TELEMETRIA COM TECNOLOGIAS GSM/GPRS PARA A REA AMBIENTAL",autor:"Samuel Cabral",orientador:"Prof. Dr. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"O monitoramento ambiental remoto  importante sob o ponto de vista social, ecolgico e agrcola, pois oferece melhor visualizao do estado de um ambiente e, consequentemente, providencia o melhor controle dele. A fim de criar uma maneira de monitorar um parmetro fsico ambiental  distncia, mesmo sem rede Wi-Fi, este trabalho prope e detalha o desenvolvimento de um sistema de monitoramento ambiental remoto utilizando rede GSM e GPRS. Os dados de temperatura e umidade relativa do ar so lidos atravs de sensores, verificados e analisados pela placa Arduino UNO, e transmitidos para um servidor na web atravs de rede GPRS, podendo ser exibidos e analisados atravs de um front-end composto de pginas na web. O sistema utiliza um servio de hospedagem na web para armazenamento dos arquivos das pginas, scripts e sistema de gerenciamento de banco de dados. Alm da transmisso de dados atravs da Internet, caso os valores das medies fsicas ultrapassem limites definidos, o usurio  automaticamente notificado atravs de mensagens alerta de SMS em seu telefone, utilizando a tecnologia de rede GSM.",palavrasChave:["Internet das Coisas","Arduino","Redes de dados","Sensores"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","samuel_cabral_2022.pdf")}]},{id:202233,titulo:"ACESSIBILIDADE WEB: METODOLOGIA DE DIAGNSTICO E IMPLEMENTAO DE SITES ACESSVEIS",autor:"Sarah Rodrigues Campos",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"A medida de isolamento social adotada por vrios pases como forma de conteno do coronavrus implicou diretamente no aumento de usurios da internet. Para muitas pessoas, o uso dessa ferramenta se tornou imprescindvel para trabalhos, estudos e at mesmo para socializao. Levando-se em conta que cerca de 24% da populao brasileira possui algum tipo de deficincia,  necessrio garantir que informaes por meio da web sejam o mais abrangente possvel. Para isso, esta pesquisa prope a criao de um guia simplificado sobre acessibilidade na internet para auxiliar desenvolvedores e designers a criar aplicaes web inclusivas. Aps um levantamento bibliogrfico, foram feitas adaptaes em um site da UNESP, validadas por meio de testes com pessoas portadoras de diferentes deficincias. O guia foi construdo a partir da anlise destes dados e do levantamento bibliogrfico.",palavrasChave:["acessibilidade","web","manual","desenvolvimento","design"],dataDefesa:"2023-01-18",links:[{label:"Monografia",url:p("monografia","sarah_rodrigues_2022.pdf")}]},{id:202234,titulo:"SMART CAMPUS: UM ESTUDO SOBRE VISO COMPUTACIONAL PARA DETECO DE PESSOAS EM FILAS",autor:"Thiago Esteves La Scala",orientador:"Prof. Me. Luiz Felipe de Camargo",curso:"BCC",descricao:"Considerando as previses futuras para a rea de Internet das Coisas e as facilidades geradas por aplicaes de viso computacional utilizando aprendizado de mquina, este trabalho visa a deteco de pessoas em imagens usando o modelo de aprendizado de mquina para deteco de objetos YOLO. Para os testes foram utilizadas modificaes do conjunto de dados COCO, composto por diversos tipos de imagens rotuladas, e foram obtidos resultados promissores demonstrados atravs das mtricas ndice mAP que alcanou 98,8% e pontuao F1 que alcanou 97%. Os testes desenvolvidos permitiram a anlise da aplicabilidade do modelo para a deteco de pessoas, visando o futuro esenvolvimento de uma aplicao para acompanhamento de filas em um Smart Campus.",palavrasChave:["Internet das Coisas","Viso Computacional","Aprendizado de Mquina","Deteco de Pessoas"],dataDefesa:"2023-01-18",links:[{label:"Monografia",url:p("monografia","thiago_esteves_2022.pdf")}]},{id:202235,titulo:"DETECO DE PGINAS DE PHISHING UTILIZANDO APRENDIZADO DE MQUINA",autor:"Vinicius Machado Coutinho",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Com o avano da Internet e o aumento de servios digitais, tentativas de fraudes online, como o phishing, se tornaram um problema cada vez maior. Devido ao contnuo aumento e evoluo desses ataques, h a necessidade do desenvolvimento e aprimoramento de mtodos para deteco deles. Neste trabalho, foi criado um sistema de deteco de pginas de phishing, utilizando tcnicas de aprendizado de mquina como rvore de Deciso, Floresta Aleatria, rvores Extremamente Aleatrias e XGBoost. Os modelos foram desenvolvidos com um conjunto de dados de 88.647 entradas e mediu-se suas efetividades atravs de mtricas j estabelecidas na rea de aprendizado de mquina. Os resultados obtidos foram promissores, com o modelo XGBoost apresentando o melhor resultado, mostrando-se eficaz para a deteco de pginas da internet falsas.",palavrasChave:["Aprendizado de mquinas","Inteligncia Artificial","Fraude na Internet","rvores de Deciso"],dataDefesa:"2023-01-01",links:[{label:"Monografia",url:p("monografia","vinicius_machado_2022.pdf")}]},{id:202236,titulo:"TCNICAS DE INTELIGNCIA ARTIFICIAL PARA DIAGNSTICO DE ACIDENTE VASCULAR CEREBRAL ATRAVS DE IMAGENS E DADOS TEXTUAIS SOBRE POSSVEIS VTIMAS",autor:"Vinicius de Paula Pilan",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"O Acidente Vascular Cerebral (AVC)  uma das doenas que mais matam e incapacitam no mundo todo e quanto mais tardio  o seu diagnstico, maiores podem ser os prejuzos para a vtima. Portanto, formas de agilizar e auxiliar o processo de diagnstico da doena podem ser bastante relevantes e benficas. Este trabalho abordou essa questo, aplicando tcnicas de Aprendizado de Mquina e Aprendizagem Profunda, sendo ambas subreas da Inteligncia Artificial, a qual vem sendo amplamente aplicada em diversos segmentos na busca de otimizar tarefas, principalmente no diagnstico de doenas. Modelos classificadores de fatores de risco foram criados a partir da aplicao dos modelos de Regresso Logstica e Floresta Aleatria, assim como uma Rede Neural Convolucional (CNN) para classificao de imagens de tomografia computadorizada da regio cerebral.",palavrasChave:["Inteligncia Artificial","Acidente Vascular Cerebral","Aprendizado de Mquina","Aprendizagem Profunda","Rede Neural Convolucional"],dataDefesa:"2023-01-27",links:[{label:"Monografia",url:p("monografia","vinicius_pilan_2022.pdf")}]},{id:202401,titulo:"EM BUSCA DA APLICAO DE PROTOCOLOS DE ROTEAMENTO PARA EVITAR ATAQUES DO TIPO BURACO NEGRO",autor:"Alex Luiz Domingues Cassinelli",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:`O Ataque Buraco Negro  um tipo de ataque ciberntico que ocorre em uma Rede Mvel Ad hoc (MANET),
    onde um n malicioso se comporta de forma cooperativa durante o processo de descoberta de rotas, mas descarta
    silenciosamente todos os pacotes de dados recebidos. Este trabalho investiga a implementao de protocolos de
    roteamento seguros para mitigar esse tipo de ataque em redes MANETs.`,palavrasChave:["Ataques Buraco Negro","Redes Mveis Ad hoc","Algoritmo de roteamento","Busca em Profundidade"," Mltiplos Caminhos"],dataDefesa:"2024-11-19",links:[{label:"Monografia",url:p("monografia","alex_cassinelli_2024.pdf")},{label:"Apresentao",url:p("apresentacao","alex_cassinelli_apresentacao_2024.pdf")}]},{id:202402,titulo:"Software Interpretador de Demonstraes Financeiras (IDF)",autor:"Anselmo Ruiz Lopes",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O presente trabalho visa ao desenvolvimento de um software para automao da interpretao de demonstraes financeiras, denominado IDF (Interpretador de Demonstraes Financeiras). O objetivo  facilitar a anlise financeira, calculando e interpretando automaticamente ndices de liquidez, estrutura de capital e rentabilidade, essenciais para a avaliao econmica das empresas. Utilizando uma abordagem modular e a linguagem Python com bibliotecas especficas como Pandas e ReportLab, o sistema processa dados extrados de planilhas financeiras, gerando relatrios detalhados. O estudo exploratrio se apoiou em reviso bibliogrfica e experimentao com dados reais, comparando os resultados do sistema com anlises manuais para validar a preciso e consistncia do software. Os resultados indicam que o IDF pode otimizar o tempo de anlise e fornecer interpretaes padronizadas e confiveis, beneficiando profissionais da rea financeira na tomada de decises estratgicas. O trabalho conclui que a automao da anlise financeira  uma ferramenta valiosa para a modernizao da contabilidade e pode ser expandida para outras reas financeiras.",palavrasChave:["contabilidade","anlise financeira","automatizao","ndices financeiros"],dataDefesa:"2024-11-01",links:[{label:"Monografia",url:p("monografia","anselmo_lopes_2024.pdf")},{label:"Apresentao",url:p("apresentacao","anselmo_lopes_apresentacao_2024.pdf")}]},{id:202403,titulo:"Inteligncia Artificial versus Aprendizado de Mquina: Anlise em um jogo desenvolvido em Unity",autor:"Eric Trofino",orientador:"Prof. Dr. Juliana da Costa Feitosa",curso:"BCC",descricao:"Este trabalho compara tcnicas de Inteligncia Artificial (IA) e Machine Learning (ML) aplicadas ao desenvolvimento de personagens no-jogveis (NPCs, do ingls Non-Playable Characters) em jogos eletrnicos, focando no uso do aprendizado por reforo para treinar um agente em um ambiente simulado criado no Unity. Foi implementado um jogo em que o jogador controla um caador tentando capturar um cervo, sendo este ltimo controlado por um agente com IA tradicional ou treinado por ML. O estudo utiliza mtricas de desempenho, como taxa de fuga, tempo de captura e distncia mdia entre os dois, para avaliar a eficcia dos dois agentes. Os resultados mostraram que o agente treinado por ML apresentou melhor desempenho, fugindo por mais tempo do caador e ocasionalmente aplicando estratgias de fuga inesperadas. A pesquisa contribui para o avano no desenvolvimento de jogos ao explorar como o ML pode gerar comportamentos mais dinmicos e imersivos para NPCs, possibilitando novas abordagens para desafios e interaes em jogos eletrnicos.",palavrasChave:["Machine Learning","Inteligncia Artificial","Desenvolvimento de Jogos","Jogos Digitais"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","eric_trofino_2024.pdf")},{label:"Apresentao",url:p("apresentacao","eric_trofino_apresentacao_2024.pdf")}]},{id:202404,titulo:"Implementao de um sistema de captura de movimentos de sinais de libras para animao de avatares 3D",autor:"Gabriel Junqueira do Val",orientador:"Prof. Assoc. Antnio Carlos Sementille",curso:"BCC",descricao:"Este trabalho prope um sistema que captura e redireciona os movimentos da Lngua Brasileira de Sinais (LIBRAS) para animar avatares 3D, usando ferramentas de inteligncia artificial e viso computacional. A captura dos gestos  realizada com o MediaPipe, que identifica e rastreia pontos-chave do corpo em vdeos de sinais de LIBRAS. Esses dados, uma vez extrados, so processados pelo motor Unity3D, que anima avatares com base nas informaes de movimento obtidas. O sistema segue um pipeline estruturado, que abrange desde o processamento inicial dos vdeos at a animao final dos avatares. Durante esse fluxo, os landmarks corporais so mapeados e aplicados a um esqueleto virtual. Que  renderizado pelo motor de jogos Unity3D e replica os movimentos como apresentados no dataset.",palavrasChave:["LIBRAS","MediaPipe","Animao 3D","Avatares Virtuais","Unity3D"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","gabriel_junqueira_2024.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_junqueira_apresentacao_2024.pdf")}]},{id:202405,titulo:"Predio de tendncias no mercado americano com Random Forest",autor:"Gabriel Zanforlin Parizotto",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"Este estudo explora a aplicao de tcnicas avanadas de inteligncia artificial no contexto da anlise e predio de movimentos no mercado financeiro, com nfase na implementao de modelos de aprendizado de mquina para aprimorar a tomada de decises de investimento. Dentre as abordagens desenvolvidas, destaca-se o modelo Random Forest, estruturado como um ensemble de mltiplas rvores de deciso para combinar de forma eficaz dados provenientes de indicadores financeiros amplamente utilizados. Tal abordagem visa  identificao precisa de sinais de compra e venda, capturando padres complexos presentes nos ativos analisados. A anlise de sries temporais foi aplicada em ativos selecionados do mercado financeiro americano, utilizando dados histricos para avaliar a capacidade preditiva do modelo, bem como sua eficcia na mitigao de riscos inerentes  volatilidade dos mercados. O processo de desenvolvimento incluiu tcnicas de validao cruzada e tratamento dos dados, com o objetivo de maximizar o desempenho do modelo, reduzindo o sobreajuste e aprimorando sua generalizao. Ademais, foi desenvolvida uma soluo web que abrange tanto o treinamento de modelos quanto a visualizao das oportunidades de compra e venda no mercado americano, permitindo ao usurio buscar aes especficas e obter resultados do modelo em tempo real, bem como se inscrever para receber notificaes automticas sempre que surgirem oportunidades de compra ou venda. Como resultado, este trabalho apresenta uma aplicao automatizada e de alta confiabilidade que sugere oportunidades de investimento, evidenciando o potencial da inteligncia artificial na anlise preditiva do mercado financeiro.",palavrasChave:["Inteligncia Artificial","Aprendizado de Mquina","Floresta Aleatria","Indicadores Financeiros"," Mercado Financeiro Americano"],dataDefesa:"2024-11-11",links:[{label:"Monografia",url:p("monografia","gabriel_parizotto_2024.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_parizotto_apresentacao_2024.pdf")}]},{id:202406,titulo:"Sistema de recomendao de filmes baseado em filtragem",autor:"Guilherme Souza Mingroni",orientador:"Prof. Dr. Leandro Aparecido Passos Junior",curso:"BCC",descricao:"Este trabalho aborda a evoluo e a relevncia dos sistemas de recomendao no contexto atual de consumo de mdia, especialmente em plataformas de streaming. Com o advento da inteligncia artificial e do aprendizado de mquina, os sistemas de recomendao se tornaram essenciais para personalizar a experincia do usurio, mas ainda enfrentam desafios como o filtro bolha e a diversidade nas sugestes. O sistema proposto, chamado FilmMatch, busca superar essas limitaes por meio da utilizao de mltiplas mtricas de similaridade, incluindo Similaridade Cosseno, Correlao de Pearson e ndice de Jaccard. A pesquisa se prope a desenvolver e avaliar um sistema de recomendao de filmes eficaz, analisando a eficcia das mtricas e comparando seu desempenho com outros sistemas existentes. Os resultados indicam que, embora a preciso do sistema esteja dentro da mdia, o recall  uma rea crtica que precisa de melhorias. Este trabalho contribui para a discusso sobre a importncia de recomendaes diversificadas e personalizadas no setor de entretenimento.",palavrasChave:["Sistemas de Recomendao","Consumo de Mdia","Plataformas de Streaming"," Mtricas de similaridade"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","guilherme_mingroni_2024.pdf")},{label:"Apresentao",url:p("apresentacao","guilherme_mingroni_apresentacao_2024.pdf")}]},{id:202407,titulo:"Aprendizado de mquina para deteco de ransomware",autor:"Ian Marques Breda",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa.",curso:"BCC",descricao:"Este trabalho apresenta o desenvolvimento de um prottipo de ransomware, seguido pela criao e aplicao de um modelo de aprendizado de mquina baseado em Floresta Aleatria para a deteco de ransomwares. O prottipo visa simular o comportamento malicioso do ransomware, enquanto o modelo de deteco  treinado para identificar padres associados a atividades de ransomware, permitindo uma abordagem preventiva eficaz. Os resultados obtidos demonstram a capacidade do modelo de Floresta Aleatria em detectar ataques com alta acurcia, contribuindo para o fortalecimento das defesas cibernticas.",palavrasChave:["Ransomware","Aprendizado de mquina","Floresta aleatria","Prottipo","Modelo","Defesas cibernticas"],dataDefesa:"2024-11-20",links:[{label:"Monografia",url:p("monografia","ian_breda_2024.pdf")},{label:"Apresentao",url:p("apresentacao","ian_breda_apresentacao_2024.pdf")}]},{id:202408,titulo:"Desenvolvimento de algoritmos de aprendizado de mquina para anlise e previso de ativos financeiros",autor:"Joo Henrique Mouro Suaiden",orientador:"Prof. Dr. Douglas Rodrigues",curso:"BCC",descricao:"Este trabalho tem como objetivo explorar o uso de algoritmos de aprendizado de mquina na anlise e previso de preos de ativos financeiros, contribuindo para estratgias de tomada de deciso mais precisas no mercado financeiro. A metodologia aplicada inclui a utilizao do algoritmo XGBoost, alm de indicadores financeiros tcnicos como o RSI (Relative Strength Index) e MACD (Moving Average Convergence Divergence) que auxiliam na identificao de tendncias e padres de preos. Os resultados obtidos indicam que o XGBoost, em combinao com os indicadores financeiros, apresenta um desempenho promissor, com capacidade de prever movimentos de mercado em cenrios de alta volatilidade e em diferentes intervalos de tempo. A avaliao de desempenho foi realizada com base em mtricas como a Acurcia e o F1-Score, permitindo uma anlise robusta da eficcia do modelo. Tambm foram feitas simulaes de investimento, utilizando o modelo proposto, a fim de se observar o seu comportamento no mercado real.",palavrasChave:["XGBoost","aprendizado de mquina","indicadores financeiros","mercado financeiro"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","joao_henrique_suaiden_2024.pdf")},{label:"Apresentao",url:p("apresentacao","joao_henrique_suaiden_apresentacao_2024.pdf")}]},{id:202409,titulo:"Uso de Realidade Virtual para estudos odontolgicos",autor:"Joo Pedro de Freitas Zanqui",orientador:"Prof. Dr. Juliana da Costa Feitosa",curso:"BCC",descricao:"O uso de Realidade Virtual (RV) para a rea da sade pode superar limitaes do ensino pr-clnico tradicional, como a escassez de materiais para estudo e a falta de realismo em modelos fsicos, oferecendo uma alternativa eficaz e acessvel para o aprendizado na odontologia. Com o avano contnuo das tecnologias educacionais, a RV tem emergido como uma ferramenta promissora para aprimorar o ensino em diversas reas, incluindo a odontologia. Este trabalho apresenta o desenvolvimento de uma aplicao de RV destinada a auxiliar estudantes de odontologia em seu processo de aprendizagem. Utilizando a plataforma Unity e a API Google Cardboard XR, foi criada uma aplicao para dispositivos Android que, em conjunto com um culos de RV, proporciona um ambiente imersivo e interativo. A aplicao  estruturada em mdulos de interface, visualizao, ambientao e manipulao de objetos, permitindo que os alunos naveguem por diferentes cenrios, interajam com modelos tridimensionais de estruturas odontolgicas e aprofundem seus conhecimentos de forma autnoma e envolvente. A implementao priorizou funcionalidades intuitivas e a reutilizao de modelos 3D disponveis, focando na criao de uma experincia imersiva.",palavrasChave:["Odontologia","Realidade Virtual"," Imerso"," Unity","Educao"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","joao_pedro_zanqui_2024.pdf")},{label:"Apresentao",url:p("apresentacao","joao_pedro_zanqui_apresentacao_2024.pdf")}]},{id:202410,titulo:"Inteligncia Artificial para auxlio no diagnstico de infeces fungicas e neoplasias pulmonares em radiografias torcicas",autor:"Kaio Henrique Domeni de Paulo",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"A radiografia simples (RX) do trax representa na maioria das situaes o primeiro exame radiolgico na avaliao das doenas torcicas e pulmonares. Grande parte das doenas broncopulmonares se apresentam no RX como opacidades, como  o caso da tuberculose, infeces fngicas, doenas intersticiais pulmonares, cncer de pulmo e pneumonias virais. Tcnicas de aprendizado de mquina vm sendo aplicadas para auxiliar na deteco de alteraes nos exames de imagem, mas a falta de exames de RX anotados de pacientes com infeco fngica em bases de dados torna difcil a sua classificao. O objetivo desta pesquisa  testar e aprimorar Redes Neurais Convolucionais (CNN, do ingls convolutional neural network) para auxlio ao diagnstico de pacientes com infeces fngicas e neoplasia, utilizando uma base de dados anotada de exames de RX fornecidos pelo Hospital das Clnicas de Ribeiro Preto. Para tal, foram testados diferentes tcnicas de processamento de imagem e Ensemble com o intuito de maximizar a acurcia e evitar o overfitting do modelo, concluindo com o desenvolvimento de uma interface que simule uma ferramenta de auxlio computadorizado ao diagnstico (CAD, do ingls computed aided diagnosis).",palavrasChave:["Pneumonia Fngica","Neoplasia","Redes Neurais Convolucionais","Radiografias do Trax","CAD"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","kaio_henrique_domeni_2024.pdf")},{label:"Apresentao",url:p("apresentacao","kaio_henrique_domeni_apresentacao_2024.pdf")}]},{id:202411,titulo:"Minerao de repositrios par avaliar a influncia das mudanas de cdigo ao longo do tempo",autor:"Leonardo Scarmato J de Paula",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"Sempre em constante evoluo, a tecnologia demanda novas necessidades que auxiliem a avaliao de mtricas expostas em cdigos fonte, alm do surgimento de novos softwares, solues e funes que facilitem o desenvolvimento e anlises em si. Tendo essa anlise como base, surge a minerao de repositrios, uma tcnica de extrema valiosidade para a coleta de grandes quantidades de dados e informao a partir de um simples cdigo. Possibilitando fundamentar decises estratgicas, analises micro que aceleram a manuteno e diminui o retrabalho ou anlises macro com perspectivas abrangentes que podem direcionar o software e seu desenvolvimento. Este trabalho analisou cinco projetos Python de bibliotecas e frameworks que so amplamente conhecidos e utilizados, com o objetivo de relacionar as alteraes em determinados trechos do cdigo em diferentes faixas de tempo,  necessidade de manuteno dos componentes. As mtricas analisadas inclouiram o nmero de commits, data de criao e os issues reportados, possibilitando comparao dos dados extrados dos repositrios com o prprio GitHub do projeto, formando uma abordagem relevante ao direcionar desenvolvedores para prticas de manuteno que sejam mais eficientes e alinhadas com as necessidades do software.",palavrasChave:["Minerao de repositrios","bibliotecas","anlises","qualidade","software","cincia de dados"],dataDefesa:"2024-11-13",links:[{label:"Monografia",url:p("monografia","leonardo_scarmato_2024.pdf")},{label:"Apresentao",url:p("apresentacao","leonardo_scarmato_apresentacao_2024.pdf")}]},{id:202412,titulo:"Desenvolvimento de um sistema de simulao de gerao de energia elica e anlise de eficincia para a regio de Bauru/SP",autor:"Leonel Lorca Biolcati",orientador:"Prof. Assoc. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"A energia elica  um dos tipos de energia limpa que continuam a ser fortemente desenvolvidos e crescem no mercado energtico atual, porm um aspecto importante desta tecnologia  que sua instalao deve ser feita em locais apropriados para que os sistemas possam funcionar eficientemente. Para isso, neste trabalho foi desenvolvido um programa na plataforma Mathematical Laboratory, ou MATLAB, para simular a gerao de energia de uma turbina elica, com base em seus parmetros e dados meteorolgicos relevantes para um sistema ideal que ainda considera valores possveis do coeficiente de potncia da Lei de Betz. Os resultados permitem uma anlise da eficincia de um aerogerador dentro da regio dos dados usados, assim o estudo da capacidade e aplicao desta forma de gerao de energia pode ser mais facilmente explorado, considerado ou desconsiderado.",palavrasChave:["Turbina elica","potencial eltrico","simulao por computador e energia elica"],dataDefesa:"2024-11-11",links:[{label:"Monografia",url:p("monografia","leonel_biolcati_2024.pdf")},{label:"Apresentao",url:p("apresentacao","leonel_biolcati_apresentacao_2024.pdf")}]},{id:202413,titulo:"Anlise de mobilidade urbana utilizando dados de viagens de bicicleta",autor:"Luca Melo Munekata",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"A mobilidade ativa tem ganho relevncia em discusses sobre o planejamento urbano, se mostrando um meio de transporte que traz benefcios para a qualidade de vida nas cidades. Nesse contexto, o presente trabalho tem como objetivo aplicar tcnicas de cincia de dados no desenvolvimento de uma ferramenta que permita a realizao de anlises estatsticas e geoespaciais sobre dados de ciclistas de um aplicativo rastreador de viagens na cidade de So Paulo. Visando a implementao de polticas pblicas, as anlises em questo envolvem a distribuio de viagens de ciclistas pela cidade, as caractersticas de viagens e ciclistas e a relao delas com a infraestrutura dedicada. A ferramenta foi desenvolvida utilizando linguagem Python, em notebooks Jupyter.",palavrasChave:["Cincia de dados","Mobilidade ativa","Ciclistas"," Infraestrutura cicloviria","Polticas pblicas"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","luca_munekata_2024.pdf")},{label:"Apresentao",url:p("apresentacao","luca_munekata_apresentacao_2024.pdf")}]},{id:202414,titulo:"Aplicao de tcnicas de aprendizado de mquina como estratgia operacional no mercado de capitais brasileiro",autor:"Lucas Yuki Nishimoto",orientador:"Prof. Dr. Mateus Roder",curso:"BCC",descricao:"Este trabalho investiga a aplicao de tcnicas de aprendizado de mquina para maximizar o retorno financeiro no mercado de capitais brasileiro, tilizando os algoritmos Random Forest, Support Vector Machine e XGBoost. O estudo visa construir e avaliar portflios de ativos com base em previses de movimentaes do mercado. Os dados histricos foram obtidos por meio do Yahoo Finance, e indicadores financeiros foram extrados para alimentar os modelos. A anlise compara o desempenho dos modelos em termos de retorno percentual e ndice de Sharpe no perodo de janeiro de 2022 a outubro de 2024. Os resultados revelam que os modelos de aprendizado de mquina ofereceram uma relao risco-retorno muito superior ao Ibovespa, mais estvel em casos como o RF, mas com destaque em retorno acumulado para o XGBoost, tambm com o maior ndice de Sharpe. Comparados ao Ibovespa, todos os modelos apresentaram retornos mais elevados e maior consistncia, o que aponta para o potencial do aprendizado de mquina em estratgias de investimento seguras e rentveis, uma vez que todos os modelos levaram a valores de retorno percentual acumulado de mais de 150% em pouco menos de trs anos.",palavrasChave:["ML","IA","mercado financeiro"," otimizao de portflio"," ndice de Sharpe","RF","SVM","XGBoost"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","lucas_nishimoto_2024.pdf")},{label:"Apresentao",url:p("apresentacao","lucas_nishimoto_apresentacao_2024.pdf")}]},{id:202415,titulo:"Ferramenta de deteco de phishing com Aprendizado de Mquina",autor:"Marina Rijo de Oliveira",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Com a popularizao da internet, crimes virtuais como o phishing esto se tornando cada vez mais comuns. Em funo disto, torna-se necessrio o desenvolvimento de mtodos de deteco simples para proteger a populao. Este trabalho prope a criao de uma aplicao simplificada para a deteco destes ataques, utilizando-se de modelos de aprendizado de mquina para validar os endereos web apresentados pelo usurio. Os modelos utilizados foram rvore de Deciso, Floresta Aleatria, rvores Extremamente Aleatrias, XGBoost, CatBoost e Regresso Logstica, orquestrados de forma a poupar poder computacional e minimizar o tempo de execuo.",palavrasChave:["Aprendizado de mquina","Crimes Virtuais","Inteligncia Artificial","rvore de Deciso","XGBoost"],dataDefesa:"2024-11-01",links:[{label:"Monografia",url:p("monografia","marina_rijo_2024.pdf")},{label:"Apresentao",url:p("apresentacao","marina_rijo_apresentacao_2024.pdf")}]},{id:202416,titulo:"Desenvolvimento de um sistema para apoio a pessoas com deficincia visual e auditiva",autor:"Matheus Herminio da Silva",orientador:"Prof. Assoc. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"A tecnologia assistiva envolve ferramentas e solues voltadas para melhorar a qualidade de vida e promover a independncia de pessoas com deficincia, facilitando suas atividades dirias e promovendo sua incluso social. Este trabalho tem como objetivo aplicar esse conceito para criar um sistema assistivo destinado a pessoas surdocegas, visando facilitar a comunicao e o gerenciamento de tempo. O sistema  composto por dois aplicativos e um circuito com Arduino: o primeiro aplicativo permite configurar alarmes vibratrios, possibilitando que o usurio seja notificado sobre eventos por meio de vibraes no celular. J o segundo aplicativo  integrado ao Arduino e conecta-se a uma campainha domstica, enviando um alerta vibratrio sempre que algum toca a campainha. O sistema foi testado pelo desenvolvedor, demonstrando-se vivel, embora com sugestes de adaptaes para aumentar a acessibilidade. Este projeto prope ainda melhorias futuras, como a integrao com mais dispositivos IoT, ampliando a eficcia e usabilidade do sistema.",palavrasChave:["tecnologia assistiva","surdocegueira","Arduino"," alarmes vibratrios","incluso"],dataDefesa:"2024-11-13",links:[{label:"Monografia",url:p("monografia","matheus_herminio_2024.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_herminio_apresentacao_2024.pdf")}]},{id:202417,titulo:"Desenvolvimento de sistemas de reconhecimento de sinais de alfabeto manual de Libras utilizando MediaPipe Hands e rede LSTM",autor:"Pedro Ferreira Caliman",orientador:"Prof. Assoc. Antnio Carlos Sementille",curso:"BCC",descricao:"A Lngua Brasileira de Sinais (Libras)  um idioma visual que, assim como muitas outras linguagens de sinais, ainda no possui uma infraestrutura suficientemente desenvolvida. Isso  algo que se torna ainda mais agravante quando considerada a sua importncia como meio de comunicao para a comunidade surda. Por muito tempo, a anlise dos sinais de Libras tem sido uma tarefa difcil para os computadores, em parte devido s dependncias espaciais-temporais envolvidas no reconhecimento de gestos que utilizam a movimentao das mos. Porm, os avanos recentes nas tecnologias de viso computacional e machine learning permitem cada vez mais a superao destes obstculos. Portanto, o objetivo deste trabalho consiste na implementao de um pipeline completo para o reconhecimento dos sinais do alfabeto manual de Libras, incluindo a coleta de fontes para a elaborao do conjunto de dados, a extrao dos pontos de referncia das mos, e o treinamento de uma Rede Long Short-Term Memory capaz de analisar os sinais individuais.",palavrasChave:["Lngua Brasileira de Sinais","Rede LSTM","Detecao de Pontos de Referncia","Reconhecimento de Linguagem de Sinais"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","pedro_caliman_2024.pdf")}]},{id:202418,titulo:"Aplicativo gamificado para aprendizagem de Kanji (ideogramas chineses)",autor:"Raul Alexandre Gonzalez Augusto",orientador:"Prof. Dr. Juliana da Costa Feitosa",curso:"BCC",descricao:"A maior dificuldade que um estudante de japons pode encontrar so os pouco mais de dois mil kanji (caracteres chineses) que ele precisar memorizar para ser alfabetizado no idioma. Cada caractere  uma representao abstrata de uma ideia ou de uma imagem que normalmente possui mais de uma leitura e mais de um significado, aumentando ainda mais a dificuldade. Por exemplo, o smbolo   um pictograma do sol, sendo mais utilizado com o significado de dia. Porm, ele pode tambm significar sol, Japo e ser usado como contador de dias. Alm disso, ele pode ser lido como hi,-bi,-ka, nichi e jitsu. Por esses motivos, a maior dificuldade na alfabetizao do japons so os kanji, o que leva muitos estudantes a desistirem de estudar o idioma ou a aprenderem apenas a falar, sem se preocupar com a leitura. Por conta disso, Heisig criou um mtodo para a aprendizagem de kanji que vai alm do mtodo tradicional de escrever e ler repetidamente at decorar. O mtodo de Heisig consiste em criar histrias com os componentes do kanji para formar uma imagem vvida do caractere na mente. Ademais, ele indica a utilizao de flashcards para a reviso. Diante disso, o presente trabalho visa apresentar um aplicativo Android desenvolvido com elementos de jogos, utilizando flashcards e seguindo o mtodo de Heisig com algumas alteraes para estudar e revisar os kanji.",palavrasChave:["Estudo de kanji","Mtodo de Heisig","Gamificao","Flashcards","Estudo de Japons","Android"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","raul_augusto_2024.pdf")},{label:"Apresentao",url:p("apresentacao","raul_augusto_apresentacao_2024.pdf")}]},{id:202419,titulo:"Identificao biomtrica de ces por meio do reconhecimento facial utilizando transformadores",autor:"Vinicius Rodrigues de S Fiedler Garcia",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"Oreconhecimento biomtrico de ces, utilizando viso computacional e aprendizagem de mquina, apresenta-se como uma soluo atual e bastante relevante, tanto do ponto de vista social quanto econmico, em aplicaes como o cadastro e a identificao automtica desses animais para fins de gerenciamento e controle da populao canina, a localizao dos tutores dos animais perdidos e a preveno de fraudes nos atendimentos em clnicas veterinrias pblicas e privadas. Este trabalho prope uma abordagem para a identificao biomtrica automtica de ces que utiliza o modelo YOLOnadeteco automtica das cabeas dos ces, durante a etapa de segmentao das imagens digitais dos animais, e o modelo de transformador visual na etapa de extrao das caractersticas faciais dos ces. A abordagem proposta foi incorporada a um sistema biomtrico projetado e implementado neste trabalho para ser executado em um servidor, hospedado em um ambiente de nuvem, de forma integrada a um aplicativo mvel que visa facilitar a captura e o envio das imagens ao servidor diretamente pelo usurio.",palavrasChave:["Identificao Biomtrica de Ces","YOLO","Transformador Visual","Viso Computacional","Aprendizado Profundo"," Aplicao Mvel"],dataDefesa:"2024-11-13",links:[{label:"Monografia",url:p("monografia","vinicius_garcia_2024.pdf")},{label:"Apresentao",url:p("apresentacao","vinicius_garcia_apresentacao_2024.pdf")}]}];function Ds(e){return e?parseInt(e.split("-")[0]):null}function Gd(){const e=Es.map(a=>Ds(a.dataDefesa)).filter(a=>a!==null);return Math.max(...e)}function Uo(e){return Es.filter(a=>Ds(a.dataDefesa)===e)}Uo(2025).length>0?Uo(2025):Uo(Gd());const Ud={name:"TccsList",components:{TccItem:wd},props:{tccs:{type:Array,required:!0}},data(){return{openItems:[],searchTerm:"",anoAtual:2025}},computed:{anoExibicao(){return 2025},tccsFiltrados(){if(!this.searchTerm)return this.tccs.filter(a=>Ds(a.dataDefesa)===2025);const e=this.searchTerm.toLowerCase().trim();return this.tccs.filter(a=>{const o=a.curso.toLowerCase()==="bcc"?"bcc bacharelado cincia computao":"bsi bacharelado sistemas informao";return a.titulo.toLowerCase().includes(e)||a.autor.toLowerCase().includes(e)||a.curso.toLowerCase().includes(e)||o.includes(e)||a.descricao.toLowerCase().includes(e)||a.palavrasChave&&a.palavrasChave.some(s=>s.toLowerCase().includes(e))})},totalTccs(){return this.tccs.length}},methods:{toggleItem(e){const a=this.openItems.indexOf(e);a>-1?this.openItems.splice(a,1):this.openItems.push(e)},clearSearch(){this.searchTerm=""},expandAll(){this.openItems=this.tccsFiltrados.map(e=>e.id)},collapseAll(){this.openItems=[]}}},Vd={class:"tccs-container"},Hd={class:"tccs-header"},Kd={class:"search-container"},$d={key:0,class:"year-info"},Jd={class:"tccs-list"},Wd={key:0,class:"no-results"},Zd={key:0,class:"tccs-footer"},Xd={class:"results-count"};function Qd(e,a,o,s,i,r){const t=co("TccItem");return ee(),se("div",Vd,[j("div",Hd,[j("h2",null,"Trabalhos Disponveis ("+le(r.tccsFiltrados.length)+")",1),j("div",Kd,[Gi(j("input",{"onUpdate:modelValue":a[0]||(a[0]=n=>i.searchTerm=n),type:"text",placeholder:"Buscar por ttulo, autor, curso (BCC/BSI) ou palavra-chave...",class:"search-input"},null,512),[[Yn,i.searchTerm]]),i.searchTerm?(ee(),se("button",{key:0,onClick:a[1]||(a[1]=(...n)=>r.clearSearch&&r.clearSearch(...n)),class:"clear-search"},"")):Ye("",!0)]),i.searchTerm?Ye("",!0):(ee(),se("p",$d,"Exibindo trabalhos de "+le(r.anoExibicao)+". Use a busca para ver trabalhos de outros anos.",1))]),j("div",Jd,[r.tccsFiltrados.length===0?(ee(),se("div",Wd,[...a[2]||(a[2]=[j("p",null,"Nenhum trabalho encontrado com os critrios de busca.",-1)])])):Ye("",!0),(ee(!0),se(Se,null,Xo(r.tccsFiltrados,n=>(ee(),As(t,{key:n.id,tcc:n,"is-open":i.openItems.includes(n.id),onToggle:l=>r.toggleItem(n.id)},null,8,["tcc","is-open","onToggle"]))),128))]),r.tccsFiltrados.length>0?(ee(),se("div",Zd,[j("p",Xd," Exibindo "+le(r.tccsFiltrados.length)+" de "+le(r.totalTccs)+" trabalhos ",1)])):Ye("",!0)])}const Yd=Ka(Ud,[["render",Qd],["__scopeId","data-v-2e7de66d"]]),el={name:"App",components:{Header:gd,TccsList:Yd},data(){return{allTccs:Es}}};function al(e,a,o,s,i,r){const t=co("Header"),n=co("TccsList");return ee(),se("div",null,[te(t,{titulo:"TCCs do DCo",subtitulo:"Trabalhos de Concluso de Curso do Departamento de Computao - Unesp de Bauru (FC)"}),j("main",null,[te(n,{tccs:i.allTccs},null,8,["tccs"])])])}const ol=Ka(el,[["render",al]]);od(ol).mount("#app");
