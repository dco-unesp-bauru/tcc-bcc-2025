(function(){const a=document.createElement("link").relList;if(a&&a.supports&&a.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const t of i)if(t.type==="childList")for(const r of t.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function o(i){const t={};return i.integrity&&(t.integrity=i.integrity),i.referrerPolicy&&(t.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?t.credentials="include":i.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function s(i){if(i.ep)return;i.ep=!0;const t=o(i);fetch(i.href,t)}})();function is(e){const a=Object.create(null);for(const o of e.split(","))a[o]=1;return o=>o in a}const U={},ha=[],Fe=()=>{},ui=()=>!1,vo=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),ts=e=>e.startsWith("onUpdate:"),ne=Object.assign,rs=(e,a)=>{const o=e.indexOf(a);o>-1&&e.splice(o,1)},St=Object.prototype.hasOwnProperty,L=(e,a)=>St.call(e,a),E=Array.isArray,ba=e=>ho(e)==="[object Map]",mi=e=>ho(e)==="[object Set]",w=e=>typeof e=="function",ae=e=>typeof e=="string",aa=e=>typeof e=="symbol",X=e=>e!==null&&typeof e=="object",pi=e=>(X(e)||w(e))&&w(e.then)&&w(e.catch),fi=Object.prototype.toString,ho=e=>fi.call(e),Mt=e=>ho(e).slice(8,-1),gi=e=>ho(e)==="[object Object]",ns=e=>ae(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Ea=is(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),bo=e=>{const a=Object.create(null);return(o=>a[o]||(a[o]=e(o)))},yt=/-\w/g,Me=bo(e=>e.replace(yt,a=>a.slice(1).toUpperCase())),Et=/\B([A-Z])/g,pa=bo(e=>e.replace(Et,"-$1").toLowerCase()),_o=bo(e=>e.charAt(0).toUpperCase()+e.slice(1)),Eo=bo(e=>e?`on${_o(e)}`:""),ca=(e,a)=>!Object.is(e,a),Za=(e,...a)=>{for(let o=0;o<e.length;o++)e[o](...a)},vi=(e,a,o,s=!1)=>{Object.defineProperty(e,a,{configurable:!0,enumerable:!1,writable:s,value:o})},Go=e=>{const a=parseFloat(e);return isNaN(a)?e:a},jt=e=>{const a=ae(e)?Number(e):NaN;return isNaN(a)?e:a};let Ms;const Co=()=>Ms||(Ms=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function ds(e){if(E(e)){const a={};for(let o=0;o<e.length;o++){const s=e[o],i=ae(s)?It(s):ds(s);if(i)for(const t in i)a[t]=i[t]}return a}else if(ae(e)||X(e))return e}const Ot=/;(?![^(]*\))/g,wt=/:([^]+)/,Tt=/\/\*[^]*?\*\//g;function It(e){const a={};return e.replace(Tt,"").split(Ot).forEach(o=>{if(o){const s=o.split(wt);s.length>1&&(a[s[0].trim()]=s[1].trim())}}),a}function Ao(e){let a="";if(ae(e))a=e;else if(E(e))for(let o=0;o<e.length;o++){const s=Ao(e[o]);s&&(a+=s+" ")}else if(X(e))for(const o in e)e[o]&&(a+=o+" ");return a.trim()}const Rt="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Bt=is(Rt);function hi(e){return!!e||e===""}const bi=e=>!!(e&&e.__v_isRef===!0),le=e=>ae(e)?e:e==null?"":E(e)||X(e)&&(e.toString===fi||!w(e.toString))?bi(e)?le(e.value):JSON.stringify(e,_i,2):String(e),_i=(e,a)=>bi(a)?_i(e,a.value):ba(a)?{[`Map(${a.size})`]:[...a.entries()].reduce((o,[s,i],t)=>(o[jo(s,t)+" =>"]=i,o),{})}:mi(a)?{[`Set(${a.size})`]:[...a.values()].map(o=>jo(o))}:aa(a)?jo(a):X(a)&&!E(a)&&!gi(a)?String(a):a,jo=(e,a="")=>{var o;return aa(e)?`Symbol(${(o=e.description)!=null?o:a})`:e};let Ae;class Nt{constructor(a=!1){this.detached=a,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=Ae,!a&&Ae&&(this.index=(Ae.scopes||(Ae.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let a,o;if(this.scopes)for(a=0,o=this.scopes.length;a<o;a++)this.scopes[a].pause();for(a=0,o=this.effects.length;a<o;a++)this.effects[a].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let a,o;if(this.scopes)for(a=0,o=this.scopes.length;a<o;a++)this.scopes[a].resume();for(a=0,o=this.effects.length;a<o;a++)this.effects[a].resume()}}run(a){if(this._active){const o=Ae;try{return Ae=this,a()}finally{Ae=o}}}on(){++this._on===1&&(this.prevScope=Ae,Ae=this)}off(){this._on>0&&--this._on===0&&(Ae=this.prevScope,this.prevScope=void 0)}stop(a){if(this._active){this._active=!1;let o,s;for(o=0,s=this.effects.length;o<s;o++)this.effects[o].stop();for(this.effects.length=0,o=0,s=this.cleanups.length;o<s;o++)this.cleanups[o]();if(this.cleanups.length=0,this.scopes){for(o=0,s=this.scopes.length;o<s;o++)this.scopes[o].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!a){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0}}}function Ft(){return Ae}let W;const Oo=new WeakSet;class Ci{constructor(a){this.fn=a,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,Ae&&Ae.active&&Ae.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,Oo.has(this)&&(Oo.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||zi(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,ys(this),qi(this);const a=W,o=ye;W=this,ye=!0;try{return this.fn()}finally{xi(this),W=a,ye=o,this.flags&=-3}}stop(){if(this.flags&1){for(let a=this.deps;a;a=a.nextDep)us(a);this.deps=this.depsTail=void 0,ys(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?Oo.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Uo(this)&&this.run()}get dirty(){return Uo(this)}}let Ai=0,ja,Oa;function zi(e,a=!1){if(e.flags|=8,a){e.next=Oa,Oa=e;return}e.next=ja,ja=e}function ls(){Ai++}function cs(){if(--Ai>0)return;if(Oa){let a=Oa;for(Oa=void 0;a;){const o=a.next;a.next=void 0,a.flags&=-9,a=o}}let e;for(;ja;){let a=ja;for(ja=void 0;a;){const o=a.next;if(a.next=void 0,a.flags&=-9,a.flags&1)try{a.trigger()}catch(s){e||(e=s)}a=o}}if(e)throw e}function qi(e){for(let a=e.deps;a;a=a.nextDep)a.version=-1,a.prevActiveLink=a.dep.activeLink,a.dep.activeLink=a}function xi(e){let a,o=e.depsTail,s=o;for(;s;){const i=s.prevDep;s.version===-1?(s===o&&(o=i),us(s),Lt(s)):a=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=i}e.deps=a,e.depsTail=o}function Uo(e){for(let a=e.deps;a;a=a.nextDep)if(a.dep.version!==a.version||a.dep.computed&&(Pi(a.dep.computed)||a.dep.version!==a.version))return!0;return!!e._dirty}function Pi(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===Ba)||(e.globalVersion=Ba,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Uo(e))))return;e.flags|=2;const a=e.dep,o=W,s=ye;W=e,ye=!0;try{qi(e);const i=e.fn(e._value);(a.version===0||ca(i,e._value))&&(e.flags|=128,e._value=i,a.version++)}catch(i){throw a.version++,i}finally{W=o,ye=s,xi(e),e.flags&=-3}}function us(e,a=!1){const{dep:o,prevSub:s,nextSub:i}=e;if(s&&(s.nextSub=i,e.prevSub=void 0),i&&(i.prevSub=s,e.nextSub=void 0),o.subs===e&&(o.subs=s,!s&&o.computed)){o.computed.flags&=-5;for(let t=o.computed.deps;t;t=t.nextDep)us(t,!0)}!a&&!--o.sc&&o.map&&o.map.delete(o.key)}function Lt(e){const{prevDep:a,nextDep:o}=e;a&&(a.nextDep=o,e.prevDep=void 0),o&&(o.prevDep=a,e.nextDep=void 0)}let ye=!0;const Di=[];function Ke(){Di.push(ye),ye=!1}function Je(){const e=Di.pop();ye=e===void 0?!0:e}function ys(e){const{cleanup:a}=e;if(e.cleanup=void 0,a){const o=W;W=void 0;try{a()}finally{W=o}}}let Ba=0;class kt{constructor(a,o){this.sub=a,this.dep=o,this.version=o.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Si{constructor(a){this.computed=a,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(a){if(!W||!ye||W===this.computed)return;let o=this.activeLink;if(o===void 0||o.sub!==W)o=this.activeLink=new kt(W,this),W.deps?(o.prevDep=W.depsTail,W.depsTail.nextDep=o,W.depsTail=o):W.deps=W.depsTail=o,Mi(o);else if(o.version===-1&&(o.version=this.version,o.nextDep)){const s=o.nextDep;s.prevDep=o.prevDep,o.prevDep&&(o.prevDep.nextDep=s),o.prevDep=W.depsTail,o.nextDep=void 0,W.depsTail.nextDep=o,W.depsTail=o,W.deps===o&&(W.deps=s)}return o}trigger(a){this.version++,Ba++,this.notify(a)}notify(a){ls();try{for(let o=this.subs;o;o=o.prevSub)o.sub.notify()&&o.sub.dep.notify()}finally{cs()}}}function Mi(e){if(e.dep.sc++,e.sub.flags&4){const a=e.dep.computed;if(a&&!e.dep.subs){a.flags|=20;for(let s=a.deps;s;s=s.nextDep)Mi(s)}const o=e.dep.subs;o!==e&&(e.prevSub=o,o&&(o.nextSub=e)),e.dep.subs=e}}const $o=new WeakMap,ua=Symbol(""),Ko=Symbol(""),Na=Symbol("");function ce(e,a,o){if(ye&&W){let s=$o.get(e);s||$o.set(e,s=new Map);let i=s.get(o);i||(s.set(o,i=new Si),i.map=s,i.key=o),i.track()}}function Ue(e,a,o,s,i,t){const r=$o.get(e);if(!r){Ba++;return}const n=l=>{l&&l.trigger()};if(ls(),a==="clear")r.forEach(n);else{const l=E(e),m=l&&ns(o);if(l&&o==="length"){const c=Number(s);r.forEach((f,C)=>{(C==="length"||C===Na||!aa(C)&&C>=c)&&n(f)})}else switch((o!==void 0||r.has(void 0))&&n(r.get(o)),m&&n(r.get(Na)),a){case"add":l?m&&n(r.get("length")):(n(r.get(ua)),ba(e)&&n(r.get(Ko)));break;case"delete":l||(n(r.get(ua)),ba(e)&&n(r.get(Ko)));break;case"set":ba(e)&&n(r.get(ua));break}}cs()}function fa(e){const a=V(e);return a===e?a:(ce(a,"iterate",Na),Ee(e)?a:a.map(fe))}function zo(e){return ce(e=V(e),"iterate",Na),e}const Vt={__proto__:null,[Symbol.iterator](){return wo(this,Symbol.iterator,fe)},concat(...e){return fa(this).concat(...e.map(a=>E(a)?fa(a):a))},entries(){return wo(this,"entries",e=>(e[1]=fe(e[1]),e))},every(e,a){return ke(this,"every",e,a,void 0,arguments)},filter(e,a){return ke(this,"filter",e,a,o=>o.map(fe),arguments)},find(e,a){return ke(this,"find",e,a,fe,arguments)},findIndex(e,a){return ke(this,"findIndex",e,a,void 0,arguments)},findLast(e,a){return ke(this,"findLast",e,a,fe,arguments)},findLastIndex(e,a){return ke(this,"findLastIndex",e,a,void 0,arguments)},forEach(e,a){return ke(this,"forEach",e,a,void 0,arguments)},includes(...e){return To(this,"includes",e)},indexOf(...e){return To(this,"indexOf",e)},join(e){return fa(this).join(e)},lastIndexOf(...e){return To(this,"lastIndexOf",e)},map(e,a){return ke(this,"map",e,a,void 0,arguments)},pop(){return Pa(this,"pop")},push(...e){return Pa(this,"push",e)},reduce(e,...a){return Es(this,"reduce",e,a)},reduceRight(e,...a){return Es(this,"reduceRight",e,a)},shift(){return Pa(this,"shift")},some(e,a){return ke(this,"some",e,a,void 0,arguments)},splice(...e){return Pa(this,"splice",e)},toReversed(){return fa(this).toReversed()},toSorted(e){return fa(this).toSorted(e)},toSpliced(...e){return fa(this).toSpliced(...e)},unshift(...e){return Pa(this,"unshift",e)},values(){return wo(this,"values",fe)}};function wo(e,a,o){const s=zo(e),i=s[a]();return s!==e&&!Ee(e)&&(i._next=i.next,i.next=()=>{const t=i._next();return t.done||(t.value=o(t.value)),t}),i}const Ht=Array.prototype;function ke(e,a,o,s,i,t){const r=zo(e),n=r!==e&&!Ee(e),l=r[a];if(l!==Ht[a]){const f=l.apply(e,t);return n?fe(f):f}let m=o;r!==e&&(n?m=function(f,C){return o.call(this,fe(f),C,e)}:o.length>2&&(m=function(f,C){return o.call(this,f,C,e)}));const c=l.call(r,m,s);return n&&i?i(c):c}function Es(e,a,o,s){const i=zo(e);let t=o;return i!==e&&(Ee(e)?o.length>3&&(t=function(r,n,l){return o.call(this,r,n,l,e)}):t=function(r,n,l){return o.call(this,r,fe(n),l,e)}),i[a](t,...s)}function To(e,a,o){const s=V(e);ce(s,"iterate",Na);const i=s[a](...o);return(i===-1||i===!1)&&gs(o[0])?(o[0]=V(o[0]),s[a](...o)):i}function Pa(e,a,o=[]){Ke(),ls();const s=V(e)[a].apply(e,o);return cs(),Je(),s}const Gt=is("__proto__,__v_isRef,__isVue"),yi=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(aa));function Ut(e){aa(e)||(e=String(e));const a=V(this);return ce(a,"has",e),a.hasOwnProperty(e)}class Ei{constructor(a=!1,o=!1){this._isReadonly=a,this._isShallow=o}get(a,o,s){if(o==="__v_skip")return a.__v_skip;const i=this._isReadonly,t=this._isShallow;if(o==="__v_isReactive")return!i;if(o==="__v_isReadonly")return i;if(o==="__v_isShallow")return t;if(o==="__v_raw")return s===(i?t?ar:Ti:t?wi:Oi).get(a)||Object.getPrototypeOf(a)===Object.getPrototypeOf(s)?a:void 0;const r=E(a);if(!i){let l;if(r&&(l=Vt[o]))return l;if(o==="hasOwnProperty")return Ut}const n=Reflect.get(a,o,he(a)?a:s);if((aa(o)?yi.has(o):Gt(o))||(i||ce(a,"get",o),t))return n;if(he(n)){const l=r&&ns(o)?n:n.value;return i&&X(l)?Wo(l):l}return X(n)?i?Wo(n):ps(n):n}}class ji extends Ei{constructor(a=!1){super(!1,a)}set(a,o,s,i){let t=a[o];if(!this._isShallow){const l=ma(t);if(!Ee(s)&&!ma(s)&&(t=V(t),s=V(s)),!E(a)&&he(t)&&!he(s))return l||(t.value=s),!0}const r=E(a)&&ns(o)?Number(o)<a.length:L(a,o),n=Reflect.set(a,o,s,he(a)?a:i);return a===V(i)&&(r?ca(s,t)&&Ue(a,"set",o,s):Ue(a,"add",o,s)),n}deleteProperty(a,o){const s=L(a,o);a[o];const i=Reflect.deleteProperty(a,o);return i&&s&&Ue(a,"delete",o,void 0),i}has(a,o){const s=Reflect.has(a,o);return(!aa(o)||!yi.has(o))&&ce(a,"has",o),s}ownKeys(a){return ce(a,"iterate",E(a)?"length":ua),Reflect.ownKeys(a)}}class $t extends Ei{constructor(a=!1){super(!0,a)}set(a,o){return!0}deleteProperty(a,o){return!0}}const Kt=new ji,Jt=new $t,Wt=new ji(!0);const Jo=e=>e,Wa=e=>Reflect.getPrototypeOf(e);function Xt(e,a,o){return function(...s){const i=this.__v_raw,t=V(i),r=ba(t),n=e==="entries"||e===Symbol.iterator&&r,l=e==="keys"&&r,m=i[e](...s),c=o?Jo:a?io:fe;return!a&&ce(t,"iterate",l?Ko:ua),{next(){const{value:f,done:C}=m.next();return C?{value:f,done:C}:{value:n?[c(f[0]),c(f[1])]:c(f),done:C}},[Symbol.iterator](){return this}}}}function Xa(e){return function(...a){return e==="delete"?!1:e==="clear"?void 0:this}}function Yt(e,a){const o={get(i){const t=this.__v_raw,r=V(t),n=V(i);e||(ca(i,n)&&ce(r,"get",i),ce(r,"get",n));const{has:l}=Wa(r),m=a?Jo:e?io:fe;if(l.call(r,i))return m(t.get(i));if(l.call(r,n))return m(t.get(n));t!==r&&t.get(i)},get size(){const i=this.__v_raw;return!e&&ce(V(i),"iterate",ua),i.size},has(i){const t=this.__v_raw,r=V(t),n=V(i);return e||(ca(i,n)&&ce(r,"has",i),ce(r,"has",n)),i===n?t.has(i):t.has(i)||t.has(n)},forEach(i,t){const r=this,n=r.__v_raw,l=V(n),m=a?Jo:e?io:fe;return!e&&ce(l,"iterate",ua),n.forEach((c,f)=>i.call(t,m(c),m(f),r))}};return ne(o,e?{add:Xa("add"),set:Xa("set"),delete:Xa("delete"),clear:Xa("clear")}:{add(i){!a&&!Ee(i)&&!ma(i)&&(i=V(i));const t=V(this);return Wa(t).has.call(t,i)||(t.add(i),Ue(t,"add",i,i)),this},set(i,t){!a&&!Ee(t)&&!ma(t)&&(t=V(t));const r=V(this),{has:n,get:l}=Wa(r);let m=n.call(r,i);m||(i=V(i),m=n.call(r,i));const c=l.call(r,i);return r.set(i,t),m?ca(t,c)&&Ue(r,"set",i,t):Ue(r,"add",i,t),this},delete(i){const t=V(this),{has:r,get:n}=Wa(t);let l=r.call(t,i);l||(i=V(i),l=r.call(t,i)),n&&n.call(t,i);const m=t.delete(i);return l&&Ue(t,"delete",i,void 0),m},clear(){const i=V(this),t=i.size!==0,r=i.clear();return t&&Ue(i,"clear",void 0,void 0),r}}),["keys","values","entries",Symbol.iterator].forEach(i=>{o[i]=Xt(i,e,a)}),o}function ms(e,a){const o=Yt(e,a);return(s,i,t)=>i==="__v_isReactive"?!e:i==="__v_isReadonly"?e:i==="__v_raw"?s:Reflect.get(L(o,i)&&i in s?o:s,i,t)}const Qt={get:ms(!1,!1)},Zt={get:ms(!1,!0)},er={get:ms(!0,!1)};const Oi=new WeakMap,wi=new WeakMap,Ti=new WeakMap,ar=new WeakMap;function or(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function sr(e){return e.__v_skip||!Object.isExtensible(e)?0:or(Mt(e))}function ps(e){return ma(e)?e:fs(e,!1,Kt,Qt,Oi)}function ir(e){return fs(e,!1,Wt,Zt,wi)}function Wo(e){return fs(e,!0,Jt,er,Ti)}function fs(e,a,o,s,i){if(!X(e)||e.__v_raw&&!(a&&e.__v_isReactive))return e;const t=sr(e);if(t===0)return e;const r=i.get(e);if(r)return r;const n=new Proxy(e,t===2?s:o);return i.set(e,n),n}function _a(e){return ma(e)?_a(e.__v_raw):!!(e&&e.__v_isReactive)}function ma(e){return!!(e&&e.__v_isReadonly)}function Ee(e){return!!(e&&e.__v_isShallow)}function gs(e){return e?!!e.__v_raw:!1}function V(e){const a=e&&e.__v_raw;return a?V(a):e}function tr(e){return!L(e,"__v_skip")&&Object.isExtensible(e)&&vi(e,"__v_skip",!0),e}const fe=e=>X(e)?ps(e):e,io=e=>X(e)?Wo(e):e;function he(e){return e?e.__v_isRef===!0:!1}function rr(e){return he(e)?e.value:e}const nr={get:(e,a,o)=>a==="__v_raw"?e:rr(Reflect.get(e,a,o)),set:(e,a,o,s)=>{const i=e[a];return he(i)&&!he(o)?(i.value=o,!0):Reflect.set(e,a,o,s)}};function Ii(e){return _a(e)?e:new Proxy(e,nr)}class dr{constructor(a,o,s){this.fn=a,this.setter=o,this._value=void 0,this.dep=new Si(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Ba-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!o,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&W!==this)return zi(this,!0),!0}get value(){const a=this.dep.track();return Pi(this),a&&(a.version=this.dep.version),this._value}set value(a){this.setter&&this.setter(a)}}function lr(e,a,o=!1){let s,i;return w(e)?s=e:(s=e.get,i=e.set),new dr(s,i,o)}const Ya={},to=new WeakMap;let da;function cr(e,a=!1,o=da){if(o){let s=to.get(o);s||to.set(o,s=[]),s.push(e)}}function ur(e,a,o=U){const{immediate:s,deep:i,once:t,scheduler:r,augmentJob:n,call:l}=o,m=M=>i?M:Ee(M)||i===!1||i===0?$e(M,1):$e(M);let c,f,C,x,j=!1,T=!1;if(he(e)?(f=()=>e.value,j=Ee(e)):_a(e)?(f=()=>m(e),j=!0):E(e)?(T=!0,j=e.some(M=>_a(M)||Ee(M)),f=()=>e.map(M=>{if(he(M))return M.value;if(_a(M))return m(M);if(w(M))return l?l(M,2):M()})):w(e)?a?f=l?()=>l(e,2):e:f=()=>{if(C){Ke();try{C()}finally{Je()}}const M=da;da=c;try{return l?l(e,3,[x]):e(x)}finally{da=M}}:f=Fe,a&&i){const M=f,$=i===!0?1/0:i;f=()=>$e(M(),$)}const oe=Ft(),R=()=>{c.stop(),oe&&oe.active&&rs(oe.effects,c)};if(t&&a){const M=a;a=(...$)=>{M(...$),R()}}let F=T?new Array(e.length).fill(Ya):Ya;const G=M=>{if(!(!(c.flags&1)||!c.dirty&&!M))if(a){const $=c.run();if(i||j||(T?$.some((ie,me)=>ca(ie,F[me])):ca($,F))){C&&C();const ie=da;da=c;try{const me=[$,F===Ya?void 0:T&&F[0]===Ya?[]:F,x];F=$,l?l(a,3,me):a(...me)}finally{da=ie}}}else c.run()};return n&&n(G),c=new Ci(f),c.scheduler=r?()=>r(G,!1):G,x=M=>cr(M,!1,c),C=c.onStop=()=>{const M=to.get(c);if(M){if(l)l(M,4);else for(const $ of M)$();to.delete(c)}},a?s?G(!0):F=c.run():r?r(G.bind(null,!0),!0):c.run(),R.pause=c.pause.bind(c),R.resume=c.resume.bind(c),R.stop=R,R}function $e(e,a=1/0,o){if(a<=0||!X(e)||e.__v_skip||(o=o||new Map,(o.get(e)||0)>=a))return e;if(o.set(e,a),a--,he(e))$e(e.value,a,o);else if(E(e))for(let s=0;s<e.length;s++)$e(e[s],a,o);else if(mi(e)||ba(e))e.forEach(s=>{$e(s,a,o)});else if(gi(e)){for(const s in e)$e(e[s],a,o);for(const s of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,s)&&$e(e[s],a,o)}return e}function Ga(e,a,o,s){try{return s?e(...s):e()}catch(i){qo(i,a,o)}}function je(e,a,o,s){if(w(e)){const i=Ga(e,a,o,s);return i&&pi(i)&&i.catch(t=>{qo(t,a,o)}),i}if(E(e)){const i=[];for(let t=0;t<e.length;t++)i.push(je(e[t],a,o,s));return i}}function qo(e,a,o,s=!0){const i=a?a.vnode:null,{errorHandler:t,throwUnhandledErrorInProduction:r}=a&&a.appContext.config||U;if(a){let n=a.parent;const l=a.proxy,m=`https://vuejs.org/error-reference/#runtime-${o}`;for(;n;){const c=n.ec;if(c){for(let f=0;f<c.length;f++)if(c[f](e,l,m)===!1)return}n=n.parent}if(t){Ke(),Ga(t,null,10,[e,l,m]),Je();return}}mr(e,o,i,s,r)}function mr(e,a,o,s=!0,i=!1){if(i)throw e;console.error(e)}const ge=[];let Be=-1;const Ca=[];let Ye=null,ga=0;const Ri=Promise.resolve();let ro=null;function pr(e){const a=ro||Ri;return e?a.then(this?e.bind(this):e):a}function fr(e){let a=Be+1,o=ge.length;for(;a<o;){const s=a+o>>>1,i=ge[s],t=Fa(i);t<e||t===e&&i.flags&2?a=s+1:o=s}return a}function vs(e){if(!(e.flags&1)){const a=Fa(e),o=ge[ge.length-1];!o||!(e.flags&2)&&a>=Fa(o)?ge.push(e):ge.splice(fr(a),0,e),e.flags|=1,Bi()}}function Bi(){ro||(ro=Ri.then(Fi))}function gr(e){E(e)?Ca.push(...e):Ye&&e.id===-1?Ye.splice(ga+1,0,e):e.flags&1||(Ca.push(e),e.flags|=1),Bi()}function js(e,a,o=Be+1){for(;o<ge.length;o++){const s=ge[o];if(s&&s.flags&2){if(e&&s.id!==e.uid)continue;ge.splice(o,1),o--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function Ni(e){if(Ca.length){const a=[...new Set(Ca)].sort((o,s)=>Fa(o)-Fa(s));if(Ca.length=0,Ye){Ye.push(...a);return}for(Ye=a,ga=0;ga<Ye.length;ga++){const o=Ye[ga];o.flags&4&&(o.flags&=-2),o.flags&8||o(),o.flags&=-2}Ye=null,ga=0}}const Fa=e=>e.id==null?e.flags&2?-1:1/0:e.id;function Fi(e){try{for(Be=0;Be<ge.length;Be++){const a=ge[Be];a&&!(a.flags&8)&&(a.flags&4&&(a.flags&=-2),Ga(a,a.i,a.i?15:14),a.flags&4||(a.flags&=-2))}}finally{for(;Be<ge.length;Be++){const a=ge[Be];a&&(a.flags&=-2)}Be=-1,ge.length=0,Ni(),ro=null,(ge.length||Ca.length)&&Fi()}}let Pe=null,Li=null;function no(e){const a=Pe;return Pe=e,Li=e&&e.type.__scopeId||null,a}function ki(e,a=Pe,o){if(!a||e._n)return e;const s=(...i)=>{s._d&&mo(-1);const t=no(a);let r;try{r=e(...i)}finally{no(t),s._d&&mo(1)}return r};return s._n=!0,s._c=!0,s._d=!0,s}function Vi(e,a){if(Pe===null)return e;const o=Mo(Pe),s=e.dirs||(e.dirs=[]);for(let i=0;i<a.length;i++){let[t,r,n,l=U]=a[i];t&&(w(t)&&(t={mounted:t,updated:t}),t.deep&&$e(r),s.push({dir:t,instance:o,value:r,oldValue:void 0,arg:n,modifiers:l}))}return e}function ia(e,a,o,s){const i=e.dirs,t=a&&a.dirs;for(let r=0;r<i.length;r++){const n=i[r];t&&(n.oldValue=t[r].value);let l=n.dir[s];l&&(Ke(),je(l,o,8,[e.el,n,e,a]),Je())}}const vr=Symbol("_vte"),Hi=e=>e.__isTeleport,Ge=Symbol("_leaveCb"),Qa=Symbol("_enterCb");function hr(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return Yi(()=>{e.isMounted=!0}),Qi(()=>{e.isUnmounting=!0}),e}const Se=[Function,Array],Gi={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Se,onEnter:Se,onAfterEnter:Se,onEnterCancelled:Se,onBeforeLeave:Se,onLeave:Se,onAfterLeave:Se,onLeaveCancelled:Se,onBeforeAppear:Se,onAppear:Se,onAfterAppear:Se,onAppearCancelled:Se},Ui=e=>{const a=e.subTree;return a.component?Ui(a.component):a},br={name:"BaseTransition",props:Gi,setup(e,{slots:a}){const o=_t(),s=hr();return()=>{const i=a.default&&Ji(a.default(),!0);if(!i||!i.length)return;const t=$i(i),r=V(e),{mode:n}=r;if(s.isLeaving)return Io(t);const l=Os(t);if(!l)return Io(t);let m=Xo(l,r,s,o,f=>m=f);l.type!==ve&&La(l,m);let c=o.subTree&&Os(o.subTree);if(c&&c.type!==ve&&!la(c,l)&&Ui(o).type!==ve){let f=Xo(c,r,s,o);if(La(c,f),n==="out-in"&&l.type!==ve)return s.isLeaving=!0,f.afterLeave=()=>{s.isLeaving=!1,o.job.flags&8||o.update(),delete f.afterLeave,c=void 0},Io(t);n==="in-out"&&l.type!==ve?f.delayLeave=(C,x,j)=>{const T=Ki(s,c);T[String(c.key)]=c,C[Ge]=()=>{x(),C[Ge]=void 0,delete m.delayedLeave,c=void 0},m.delayedLeave=()=>{j(),delete m.delayedLeave,c=void 0}}:c=void 0}else c&&(c=void 0);return t}}};function $i(e){let a=e[0];if(e.length>1){for(const o of e)if(o.type!==ve){a=o;break}}return a}const _r=br;function Ki(e,a){const{leavingVNodes:o}=e;let s=o.get(a.type);return s||(s=Object.create(null),o.set(a.type,s)),s}function Xo(e,a,o,s,i){const{appear:t,mode:r,persisted:n=!1,onBeforeEnter:l,onEnter:m,onAfterEnter:c,onEnterCancelled:f,onBeforeLeave:C,onLeave:x,onAfterLeave:j,onLeaveCancelled:T,onBeforeAppear:oe,onAppear:R,onAfterAppear:F,onAppearCancelled:G}=a,M=String(e.key),$=Ki(o,e),ie=(I,H)=>{I&&je(I,s,9,H)},me=(I,H)=>{const Q=H[1];ie(I,H),E(I)?I.every(D=>D.length<=1)&&Q():I.length<=1&&Q()},be={mode:r,persisted:n,beforeEnter(I){let H=l;if(!o.isMounted)if(t)H=oe||l;else return;I[Ge]&&I[Ge](!0);const Q=$[M];Q&&la(e,Q)&&Q.el[Ge]&&Q.el[Ge](),ie(H,[I])},enter(I){let H=m,Q=c,D=f;if(!o.isMounted)if(t)H=R||m,Q=F||c,D=G||f;else return;let Y=!1;const de=I[Qa]=Le=>{Y||(Y=!0,Le?ie(D,[I]):ie(Q,[I]),be.delayedLeave&&be.delayedLeave(),I[Qa]=void 0)};H?me(H,[I,de]):de()},leave(I,H){const Q=String(e.key);if(I[Qa]&&I[Qa](!0),o.isUnmounting)return H();ie(C,[I]);let D=!1;const Y=I[Ge]=de=>{D||(D=!0,H(),de?ie(T,[I]):ie(j,[I]),I[Ge]=void 0,$[Q]===e&&delete $[Q])};$[Q]=e,x?me(x,[I,Y]):Y()},clone(I){const H=Xo(I,a,o,s,i);return i&&i(H),H}};return be}function Io(e){if(xo(e))return e=ea(e),e.children=null,e}function Os(e){if(!xo(e))return Hi(e.type)&&e.children?$i(e.children):e;if(e.component)return e.component.subTree;const{shapeFlag:a,children:o}=e;if(o){if(a&16)return o[0];if(a&32&&w(o.default))return o.default()}}function La(e,a){e.shapeFlag&6&&e.component?(e.transition=a,La(e.component.subTree,a)):e.shapeFlag&128?(e.ssContent.transition=a.clone(e.ssContent),e.ssFallback.transition=a.clone(e.ssFallback)):e.transition=a}function Ji(e,a=!1,o){let s=[],i=0;for(let t=0;t<e.length;t++){let r=e[t];const n=o==null?r.key:String(o)+String(r.key!=null?r.key:t);r.type===xe?(r.patchFlag&128&&i++,s=s.concat(Ji(r.children,a,n))):(a||r.type!==ve)&&s.push(n!=null?ea(r,{key:n}):r)}if(i>1)for(let t=0;t<s.length;t++)s[t].patchFlag=-2;return s}function Wi(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}const lo=new WeakMap;function wa(e,a,o,s,i=!1){if(E(e)){e.forEach((j,T)=>wa(j,a&&(E(a)?a[T]:a),o,s,i));return}if(Ta(s)&&!i){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&wa(e,a,o,s.component.subTree);return}const t=s.shapeFlag&4?Mo(s.component):s.el,r=i?null:t,{i:n,r:l}=e,m=a&&a.r,c=n.refs===U?n.refs={}:n.refs,f=n.setupState,C=V(f),x=f===U?ui:j=>L(C,j);if(m!=null&&m!==l){if(ws(a),ae(m))c[m]=null,x(m)&&(f[m]=null);else if(he(m)){m.value=null;const j=a;j.k&&(c[j.k]=null)}}if(w(l))Ga(l,n,12,[r,c]);else{const j=ae(l),T=he(l);if(j||T){const oe=()=>{if(e.f){const R=j?x(l)?f[l]:c[l]:l.value;if(i)E(R)&&rs(R,t);else if(E(R))R.includes(t)||R.push(t);else if(j)c[l]=[t],x(l)&&(f[l]=c[l]);else{const F=[t];l.value=F,e.k&&(c[e.k]=F)}}else j?(c[l]=r,x(l)&&(f[l]=r)):T&&(l.value=r,e.k&&(c[e.k]=r))};if(r){const R=()=>{oe(),lo.delete(e)};R.id=-1,lo.set(e,R),qe(R,o)}else ws(e),oe()}}}function ws(e){const a=lo.get(e);a&&(a.flags|=8,lo.delete(e))}Co().requestIdleCallback;Co().cancelIdleCallback;const Ta=e=>!!e.type.__asyncLoader,xo=e=>e.type.__isKeepAlive;function Cr(e,a){Xi(e,"a",a)}function Ar(e,a){Xi(e,"da",a)}function Xi(e,a,o=ue){const s=e.__wdc||(e.__wdc=()=>{let i=o;for(;i;){if(i.isDeactivated)return;i=i.parent}return e()});if(Po(a,s,o),o){let i=o.parent;for(;i&&i.parent;)xo(i.parent.vnode)&&zr(s,a,o,i),i=i.parent}}function zr(e,a,o,s){const i=Po(a,e,s,!0);Zi(()=>{rs(s[a],i)},o)}function Po(e,a,o=ue,s=!1){if(o){const i=o[e]||(o[e]=[]),t=a.__weh||(a.__weh=(...r)=>{Ke();const n=Ua(o),l=je(a,o,e,r);return n(),Je(),l});return s?i.unshift(t):i.push(t),t}}const We=e=>(a,o=ue)=>{(!Va||e==="sp")&&Po(e,(...s)=>a(...s),o)},qr=We("bm"),Yi=We("m"),xr=We("bu"),Pr=We("u"),Qi=We("bum"),Zi=We("um"),Dr=We("sp"),Sr=We("rtg"),Mr=We("rtc");function yr(e,a=ue){Po("ec",e,a)}const Er="components";function co(e,a){return Or(Er,e,!0,a)||e}const jr=Symbol.for("v-ndc");function Or(e,a,o=!0,s=!1){const i=Pe||ue;if(i){const t=i.type;{const n=zn(t,!1);if(n&&(n===a||n===Me(a)||n===_o(Me(a))))return t}const r=Ts(i[e]||t[e],a)||Ts(i.appContext[e],a);return!r&&s?t:r}}function Ts(e,a){return e&&(e[a]||e[Me(a)]||e[_o(Me(a))])}function Yo(e,a,o,s){let i;const t=o,r=E(e);if(r||ae(e)){const n=r&&_a(e);let l=!1,m=!1;n&&(l=!Ee(e),m=ma(e),e=zo(e)),i=new Array(e.length);for(let c=0,f=e.length;c<f;c++)i[c]=a(l?m?io(fe(e[c])):fe(e[c]):e[c],c,void 0,t)}else if(typeof e=="number"){i=new Array(e);for(let n=0;n<e;n++)i[n]=a(n+1,n,void 0,t)}else if(X(e))if(e[Symbol.iterator])i=Array.from(e,(n,l)=>a(n,l,void 0,t));else{const n=Object.keys(e);i=new Array(n.length);for(let l=0,m=n.length;l<m;l++){const c=n[l];i[l]=a(e[c],c,l,t)}}else i=[];return i}const Qo=e=>e?Ct(e)?Mo(e):Qo(e.parent):null,Ia=ne(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Qo(e.parent),$root:e=>Qo(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>at(e),$forceUpdate:e=>e.f||(e.f=()=>{vs(e.update)}),$nextTick:e=>e.n||(e.n=pr.bind(e.proxy)),$watch:e=>en.bind(e)}),Ro=(e,a)=>e!==U&&!e.__isScriptSetup&&L(e,a),wr={get({_:e},a){if(a==="__v_skip")return!0;const{ctx:o,setupState:s,data:i,props:t,accessCache:r,type:n,appContext:l}=e;let m;if(a[0]!=="$"){const x=r[a];if(x!==void 0)switch(x){case 1:return s[a];case 2:return i[a];case 4:return o[a];case 3:return t[a]}else{if(Ro(s,a))return r[a]=1,s[a];if(i!==U&&L(i,a))return r[a]=2,i[a];if((m=e.propsOptions[0])&&L(m,a))return r[a]=3,t[a];if(o!==U&&L(o,a))return r[a]=4,o[a];Zo&&(r[a]=0)}}const c=Ia[a];let f,C;if(c)return a==="$attrs"&&ce(e.attrs,"get",""),c(e);if((f=n.__cssModules)&&(f=f[a]))return f;if(o!==U&&L(o,a))return r[a]=4,o[a];if(C=l.config.globalProperties,L(C,a))return C[a]},set({_:e},a,o){const{data:s,setupState:i,ctx:t}=e;return Ro(i,a)?(i[a]=o,!0):s!==U&&L(s,a)?(s[a]=o,!0):L(e.props,a)||a[0]==="$"&&a.slice(1)in e?!1:(t[a]=o,!0)},has({_:{data:e,setupState:a,accessCache:o,ctx:s,appContext:i,propsOptions:t,type:r}},n){let l,m;return!!(o[n]||e!==U&&n[0]!=="$"&&L(e,n)||Ro(a,n)||(l=t[0])&&L(l,n)||L(s,n)||L(Ia,n)||L(i.config.globalProperties,n)||(m=r.__cssModules)&&m[n])},defineProperty(e,a,o){return o.get!=null?e._.accessCache[a]=0:L(o,"value")&&this.set(e,a,o.value,null),Reflect.defineProperty(e,a,o)}};function Is(e){return E(e)?e.reduce((a,o)=>(a[o]=null,a),{}):e}let Zo=!0;function Tr(e){const a=at(e),o=e.proxy,s=e.ctx;Zo=!1,a.beforeCreate&&Rs(a.beforeCreate,e,"bc");const{data:i,computed:t,methods:r,watch:n,provide:l,inject:m,created:c,beforeMount:f,mounted:C,beforeUpdate:x,updated:j,activated:T,deactivated:oe,beforeDestroy:R,beforeUnmount:F,destroyed:G,unmounted:M,render:$,renderTracked:ie,renderTriggered:me,errorCaptured:be,serverPrefetch:I,expose:H,inheritAttrs:Q,components:D,directives:Y,filters:de}=a;if(m&&Ir(m,s,null),r)for(const Z in r){const K=r[Z];w(K)&&(s[Z]=K.bind(o))}if(i){const Z=i.call(o,o);X(Z)&&(e.data=ps(Z))}if(Zo=!0,t)for(const Z in t){const K=t[Z],oa=w(K)?K.bind(o,o):w(K.get)?K.get.bind(o,o):Fe,Ka=!w(K)&&w(K.set)?K.set.bind(o):Fe,sa=xn({get:oa,set:Ka});Object.defineProperty(s,Z,{enumerable:!0,configurable:!0,get:()=>sa.value,set:Oe=>sa.value=Oe})}if(n)for(const Z in n)et(n[Z],s,o,Z);if(l){const Z=w(l)?l.call(o):l;Reflect.ownKeys(Z).forEach(K=>{kr(K,Z[K])})}c&&Rs(c,e,"c");function te(Z,K){E(K)?K.forEach(oa=>Z(oa.bind(o))):K&&Z(K.bind(o))}if(te(qr,f),te(Yi,C),te(xr,x),te(Pr,j),te(Cr,T),te(Ar,oe),te(yr,be),te(Mr,ie),te(Sr,me),te(Qi,F),te(Zi,M),te(Dr,I),E(H))if(H.length){const Z=e.exposed||(e.exposed={});H.forEach(K=>{Object.defineProperty(Z,K,{get:()=>o[K],set:oa=>o[K]=oa,enumerable:!0})})}else e.exposed||(e.exposed={});$&&e.render===Fe&&(e.render=$),Q!=null&&(e.inheritAttrs=Q),D&&(e.components=D),Y&&(e.directives=Y),I&&Wi(e)}function Ir(e,a,o=Fe){E(e)&&(e=es(e));for(const s in e){const i=e[s];let t;X(i)?"default"in i?t=eo(i.from||s,i.default,!0):t=eo(i.from||s):t=eo(i),he(t)?Object.defineProperty(a,s,{enumerable:!0,configurable:!0,get:()=>t.value,set:r=>t.value=r}):a[s]=t}}function Rs(e,a,o){je(E(e)?e.map(s=>s.bind(a.proxy)):e.bind(a.proxy),a,o)}function et(e,a,o,s){let i=s.includes(".")?ft(o,s):()=>o[s];if(ae(e)){const t=a[e];w(t)&&No(i,t)}else if(w(e))No(i,e.bind(o));else if(X(e))if(E(e))e.forEach(t=>et(t,a,o,s));else{const t=w(e.handler)?e.handler.bind(o):a[e.handler];w(t)&&No(i,t,e)}}function at(e){const a=e.type,{mixins:o,extends:s}=a,{mixins:i,optionsCache:t,config:{optionMergeStrategies:r}}=e.appContext,n=t.get(a);let l;return n?l=n:!i.length&&!o&&!s?l=a:(l={},i.length&&i.forEach(m=>uo(l,m,r,!0)),uo(l,a,r)),X(a)&&t.set(a,l),l}function uo(e,a,o,s=!1){const{mixins:i,extends:t}=a;t&&uo(e,t,o,!0),i&&i.forEach(r=>uo(e,r,o,!0));for(const r in a)if(!(s&&r==="expose")){const n=Rr[r]||o&&o[r];e[r]=n?n(e[r],a[r]):a[r]}return e}const Rr={data:Bs,props:Ns,emits:Ns,methods:Ma,computed:Ma,beforeCreate:pe,created:pe,beforeMount:pe,mounted:pe,beforeUpdate:pe,updated:pe,beforeDestroy:pe,beforeUnmount:pe,destroyed:pe,unmounted:pe,activated:pe,deactivated:pe,errorCaptured:pe,serverPrefetch:pe,components:Ma,directives:Ma,watch:Nr,provide:Bs,inject:Br};function Bs(e,a){return a?e?function(){return ne(w(e)?e.call(this,this):e,w(a)?a.call(this,this):a)}:a:e}function Br(e,a){return Ma(es(e),es(a))}function es(e){if(E(e)){const a={};for(let o=0;o<e.length;o++)a[e[o]]=e[o];return a}return e}function pe(e,a){return e?[...new Set([].concat(e,a))]:a}function Ma(e,a){return e?ne(Object.create(null),e,a):a}function Ns(e,a){return e?E(e)&&E(a)?[...new Set([...e,...a])]:ne(Object.create(null),Is(e),Is(a??{})):a}function Nr(e,a){if(!e)return a;if(!a)return e;const o=ne(Object.create(null),e);for(const s in a)o[s]=pe(e[s],a[s]);return o}function ot(){return{app:null,config:{isNativeTag:ui,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Fr=0;function Lr(e,a){return function(s,i=null){w(s)||(s=ne({},s)),i!=null&&!X(i)&&(i=null);const t=ot(),r=new WeakSet,n=[];let l=!1;const m=t.app={_uid:Fr++,_component:s,_props:i,_container:null,_context:t,_instance:null,version:Dn,get config(){return t.config},set config(c){},use(c,...f){return r.has(c)||(c&&w(c.install)?(r.add(c),c.install(m,...f)):w(c)&&(r.add(c),c(m,...f))),m},mixin(c){return t.mixins.includes(c)||t.mixins.push(c),m},component(c,f){return f?(t.components[c]=f,m):t.components[c]},directive(c,f){return f?(t.directives[c]=f,m):t.directives[c]},mount(c,f,C){if(!l){const x=m._ceVNode||re(s,i);return x.appContext=t,C===!0?C="svg":C===!1&&(C=void 0),e(x,c,C),l=!0,m._container=c,c.__vue_app__=m,Mo(x.component)}},onUnmount(c){n.push(c)},unmount(){l&&(je(n,m._instance,16),e(null,m._container),delete m._container.__vue_app__)},provide(c,f){return t.provides[c]=f,m},runWithContext(c){const f=Aa;Aa=m;try{return c()}finally{Aa=f}}};return m}}let Aa=null;function kr(e,a){if(ue){let o=ue.provides;const s=ue.parent&&ue.parent.provides;s===o&&(o=ue.provides=Object.create(s)),o[e]=a}}function eo(e,a,o=!1){const s=_t();if(s||Aa){let i=Aa?Aa._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(i&&e in i)return i[e];if(arguments.length>1)return o&&w(a)?a.call(s&&s.proxy):a}}const st={},it=()=>Object.create(st),tt=e=>Object.getPrototypeOf(e)===st;function Vr(e,a,o,s=!1){const i={},t=it();e.propsDefaults=Object.create(null),rt(e,a,i,t);for(const r in e.propsOptions[0])r in i||(i[r]=void 0);o?e.props=s?i:ir(i):e.type.props?e.props=i:e.props=t,e.attrs=t}function Hr(e,a,o,s){const{props:i,attrs:t,vnode:{patchFlag:r}}=e,n=V(i),[l]=e.propsOptions;let m=!1;if((s||r>0)&&!(r&16)){if(r&8){const c=e.vnode.dynamicProps;for(let f=0;f<c.length;f++){let C=c[f];if(Do(e.emitsOptions,C))continue;const x=a[C];if(l)if(L(t,C))x!==t[C]&&(t[C]=x,m=!0);else{const j=Me(C);i[j]=as(l,n,j,x,e,!1)}else x!==t[C]&&(t[C]=x,m=!0)}}}else{rt(e,a,i,t)&&(m=!0);let c;for(const f in n)(!a||!L(a,f)&&((c=pa(f))===f||!L(a,c)))&&(l?o&&(o[f]!==void 0||o[c]!==void 0)&&(i[f]=as(l,n,f,void 0,e,!0)):delete i[f]);if(t!==n)for(const f in t)(!a||!L(a,f))&&(delete t[f],m=!0)}m&&Ue(e.attrs,"set","")}function rt(e,a,o,s){const[i,t]=e.propsOptions;let r=!1,n;if(a)for(let l in a){if(Ea(l))continue;const m=a[l];let c;i&&L(i,c=Me(l))?!t||!t.includes(c)?o[c]=m:(n||(n={}))[c]=m:Do(e.emitsOptions,l)||(!(l in s)||m!==s[l])&&(s[l]=m,r=!0)}if(t){const l=V(o),m=n||U;for(let c=0;c<t.length;c++){const f=t[c];o[f]=as(i,l,f,m[f],e,!L(m,f))}}return r}function as(e,a,o,s,i,t){const r=e[o];if(r!=null){const n=L(r,"default");if(n&&s===void 0){const l=r.default;if(r.type!==Function&&!r.skipFactory&&w(l)){const{propsDefaults:m}=i;if(o in m)s=m[o];else{const c=Ua(i);s=m[o]=l.call(null,a),c()}}else s=l;i.ce&&i.ce._setProp(o,s)}r[0]&&(t&&!n?s=!1:r[1]&&(s===""||s===pa(o))&&(s=!0))}return s}const Gr=new WeakMap;function nt(e,a,o=!1){const s=o?Gr:a.propsCache,i=s.get(e);if(i)return i;const t=e.props,r={},n=[];let l=!1;if(!w(e)){const c=f=>{l=!0;const[C,x]=nt(f,a,!0);ne(r,C),x&&n.push(...x)};!o&&a.mixins.length&&a.mixins.forEach(c),e.extends&&c(e.extends),e.mixins&&e.mixins.forEach(c)}if(!t&&!l)return X(e)&&s.set(e,ha),ha;if(E(t))for(let c=0;c<t.length;c++){const f=Me(t[c]);Fs(f)&&(r[f]=U)}else if(t)for(const c in t){const f=Me(c);if(Fs(f)){const C=t[c],x=r[f]=E(C)||w(C)?{type:C}:ne({},C),j=x.type;let T=!1,oe=!0;if(E(j))for(let R=0;R<j.length;++R){const F=j[R],G=w(F)&&F.name;if(G==="Boolean"){T=!0;break}else G==="String"&&(oe=!1)}else T=w(j)&&j.name==="Boolean";x[0]=T,x[1]=oe,(T||L(x,"default"))&&n.push(f)}}const m=[r,n];return X(e)&&s.set(e,m),m}function Fs(e){return e[0]!=="$"&&!Ea(e)}const hs=e=>e==="_"||e==="_ctx"||e==="$stable",bs=e=>E(e)?e.map(Ne):[Ne(e)],Ur=(e,a,o)=>{if(a._n)return a;const s=ki((...i)=>bs(a(...i)),o);return s._c=!1,s},dt=(e,a,o)=>{const s=e._ctx;for(const i in e){if(hs(i))continue;const t=e[i];if(w(t))a[i]=Ur(i,t,s);else if(t!=null){const r=bs(t);a[i]=()=>r}}},lt=(e,a)=>{const o=bs(a);e.slots.default=()=>o},ct=(e,a,o)=>{for(const s in a)(o||!hs(s))&&(e[s]=a[s])},$r=(e,a,o)=>{const s=e.slots=it();if(e.vnode.shapeFlag&32){const i=a._;i?(ct(s,a,o),o&&vi(s,"_",i,!0)):dt(a,s)}else a&&lt(e,a)},Kr=(e,a,o)=>{const{vnode:s,slots:i}=e;let t=!0,r=U;if(s.shapeFlag&32){const n=a._;n?o&&n===1?t=!1:ct(i,a,o):(t=!a.$stable,dt(a,i)),r=a}else a&&(lt(e,a),r={default:1});if(t)for(const n in i)!hs(n)&&r[n]==null&&delete i[n]},qe=ln;function Jr(e){return Wr(e)}function Wr(e,a){const o=Co();o.__VUE__=!0;const{insert:s,remove:i,patchProp:t,createElement:r,createText:n,createComment:l,setText:m,setElementText:c,parentNode:f,nextSibling:C,setScopeId:x=Fe,insertStaticContent:j}=e,T=(d,u,g,b=null,v=null,h=null,q=void 0,z=null,A=!!u.dynamicChildren)=>{if(d===u)return;d&&!la(d,u)&&(b=Ja(d),Oe(d,v,h,!0),d=null),u.patchFlag===-2&&(A=!1,u.dynamicChildren=null);const{type:_,ref:y,shapeFlag:P}=u;switch(_){case So:oe(d,u,g,b);break;case ve:R(d,u,g,b);break;case ao:d==null&&F(u,g,b,q);break;case xe:D(d,u,g,b,v,h,q,z,A);break;default:P&1?$(d,u,g,b,v,h,q,z,A):P&6?Y(d,u,g,b,v,h,q,z,A):(P&64||P&128)&&_.process(d,u,g,b,v,h,q,z,A,qa)}y!=null&&v?wa(y,d&&d.ref,h,u||d,!u):y==null&&d&&d.ref!=null&&wa(d.ref,null,h,d,!0)},oe=(d,u,g,b)=>{if(d==null)s(u.el=n(u.children),g,b);else{const v=u.el=d.el;u.children!==d.children&&m(v,u.children)}},R=(d,u,g,b)=>{d==null?s(u.el=l(u.children||""),g,b):u.el=d.el},F=(d,u,g,b)=>{[d.el,d.anchor]=j(d.children,u,g,b,d.el,d.anchor)},G=({el:d,anchor:u},g,b)=>{let v;for(;d&&d!==u;)v=C(d),s(d,g,b),d=v;s(u,g,b)},M=({el:d,anchor:u})=>{let g;for(;d&&d!==u;)g=C(d),i(d),d=g;i(u)},$=(d,u,g,b,v,h,q,z,A)=>{u.type==="svg"?q="svg":u.type==="math"&&(q="mathml"),d==null?ie(u,g,b,v,h,q,z,A):I(d,u,v,h,q,z,A)},ie=(d,u,g,b,v,h,q,z)=>{let A,_;const{props:y,shapeFlag:P,transition:S,dirs:O}=d;if(A=d.el=r(d.type,h,y&&y.is,y),P&8?c(A,d.children):P&16&&be(d.children,A,null,b,v,Bo(d,h),q,z),O&&ia(d,null,b,"created"),me(A,d,d.scopeId,q,b),y){for(const J in y)J!=="value"&&!Ea(J)&&t(A,J,null,y[J],h,b);"value"in y&&t(A,"value",null,y.value,h),(_=y.onVnodeBeforeMount)&&Re(_,b,d)}O&&ia(d,null,b,"beforeMount");const N=Xr(v,S);N&&S.beforeEnter(A),s(A,u,g),((_=y&&y.onVnodeMounted)||N||O)&&qe(()=>{_&&Re(_,b,d),N&&S.enter(A),O&&ia(d,null,b,"mounted")},v)},me=(d,u,g,b,v)=>{if(g&&x(d,g),b)for(let h=0;h<b.length;h++)x(d,b[h]);if(v){let h=v.subTree;if(u===h||vt(h.type)&&(h.ssContent===u||h.ssFallback===u)){const q=v.vnode;me(d,q,q.scopeId,q.slotScopeIds,v.parent)}}},be=(d,u,g,b,v,h,q,z,A=0)=>{for(let _=A;_<d.length;_++){const y=d[_]=z?Qe(d[_]):Ne(d[_]);T(null,y,u,g,b,v,h,q,z)}},I=(d,u,g,b,v,h,q)=>{const z=u.el=d.el;let{patchFlag:A,dynamicChildren:_,dirs:y}=u;A|=d.patchFlag&16;const P=d.props||U,S=u.props||U;let O;if(g&&ta(g,!1),(O=S.onVnodeBeforeUpdate)&&Re(O,g,u,d),y&&ia(u,d,g,"beforeUpdate"),g&&ta(g,!0),(P.innerHTML&&S.innerHTML==null||P.textContent&&S.textContent==null)&&c(z,""),_?H(d.dynamicChildren,_,z,g,b,Bo(u,v),h):q||K(d,u,z,null,g,b,Bo(u,v),h,!1),A>0){if(A&16)Q(z,P,S,g,v);else if(A&2&&P.class!==S.class&&t(z,"class",null,S.class,v),A&4&&t(z,"style",P.style,S.style,v),A&8){const N=u.dynamicProps;for(let J=0;J<N.length;J++){const k=N[J],_e=P[k],Ce=S[k];(Ce!==_e||k==="value")&&t(z,k,_e,Ce,v,g)}}A&1&&d.children!==u.children&&c(z,u.children)}else!q&&_==null&&Q(z,P,S,g,v);((O=S.onVnodeUpdated)||y)&&qe(()=>{O&&Re(O,g,u,d),y&&ia(u,d,g,"updated")},b)},H=(d,u,g,b,v,h,q)=>{for(let z=0;z<u.length;z++){const A=d[z],_=u[z],y=A.el&&(A.type===xe||!la(A,_)||A.shapeFlag&198)?f(A.el):g;T(A,_,y,null,b,v,h,q,!0)}},Q=(d,u,g,b,v)=>{if(u!==g){if(u!==U)for(const h in u)!Ea(h)&&!(h in g)&&t(d,h,u[h],null,v,b);for(const h in g){if(Ea(h))continue;const q=g[h],z=u[h];q!==z&&h!=="value"&&t(d,h,z,q,v,b)}"value"in g&&t(d,"value",u.value,g.value,v)}},D=(d,u,g,b,v,h,q,z,A)=>{const _=u.el=d?d.el:n(""),y=u.anchor=d?d.anchor:n("");let{patchFlag:P,dynamicChildren:S,slotScopeIds:O}=u;O&&(z=z?z.concat(O):O),d==null?(s(_,g,b),s(y,g,b),be(u.children||[],g,y,v,h,q,z,A)):P>0&&P&64&&S&&d.dynamicChildren?(H(d.dynamicChildren,S,g,v,h,q,z),(u.key!=null||v&&u===v.subTree)&&ut(d,u,!0)):K(d,u,g,y,v,h,q,z,A)},Y=(d,u,g,b,v,h,q,z,A)=>{u.slotScopeIds=z,d==null?u.shapeFlag&512?v.ctx.activate(u,g,b,q,A):de(u,g,b,v,h,q,A):Le(d,u,A)},de=(d,u,g,b,v,h,q)=>{const z=d.component=hn(d,b,v);if(xo(d)&&(z.ctx.renderer=qa),bn(z,!1,q),z.asyncDep){if(v&&v.registerDep(z,te,q),!d.el){const A=z.subTree=re(ve);R(null,A,u,g),d.placeholder=A.el}}else te(z,d,u,g,v,h,q)},Le=(d,u,g)=>{const b=u.component=d.component;if(nn(d,u,g))if(b.asyncDep&&!b.asyncResolved){Z(b,u,g);return}else b.next=u,b.update();else u.el=d.el,b.vnode=u},te=(d,u,g,b,v,h,q)=>{const z=()=>{if(d.isMounted){let{next:P,bu:S,u:O,parent:N,vnode:J}=d;{const Te=mt(d);if(Te){P&&(P.el=J.el,Z(d,P,q)),Te.asyncDep.then(()=>{d.isUnmounted||z()});return}}let k=P,_e;ta(d,!1),P?(P.el=J.el,Z(d,P,q)):P=J,S&&Za(S),(_e=P.props&&P.props.onVnodeBeforeUpdate)&&Re(_e,N,P,J),ta(d,!0);const Ce=ks(d),we=d.subTree;d.subTree=Ce,T(we,Ce,f(we.el),Ja(we),d,v,h),P.el=Ce.el,k===null&&dn(d,Ce.el),O&&qe(O,v),(_e=P.props&&P.props.onVnodeUpdated)&&qe(()=>Re(_e,N,P,J),v)}else{let P;const{el:S,props:O}=u,{bm:N,m:J,parent:k,root:_e,type:Ce}=d,we=Ta(u);ta(d,!1),N&&Za(N),!we&&(P=O&&O.onVnodeBeforeMount)&&Re(P,k,u),ta(d,!0);{_e.ce&&_e.ce._def.shadowRoot!==!1&&_e.ce._injectChildStyle(Ce);const Te=d.subTree=ks(d);T(null,Te,g,b,d,v,h),u.el=Te.el}if(J&&qe(J,v),!we&&(P=O&&O.onVnodeMounted)){const Te=u;qe(()=>Re(P,k,Te),v)}(u.shapeFlag&256||k&&Ta(k.vnode)&&k.vnode.shapeFlag&256)&&d.a&&qe(d.a,v),d.isMounted=!0,u=g=b=null}};d.scope.on();const A=d.effect=new Ci(z);d.scope.off();const _=d.update=A.run.bind(A),y=d.job=A.runIfDirty.bind(A);y.i=d,y.id=d.uid,A.scheduler=()=>vs(y),ta(d,!0),_()},Z=(d,u,g)=>{u.component=d;const b=d.vnode.props;d.vnode=u,d.next=null,Hr(d,u.props,b,g),Kr(d,u.children,g),Ke(),js(d),Je()},K=(d,u,g,b,v,h,q,z,A=!1)=>{const _=d&&d.children,y=d?d.shapeFlag:0,P=u.children,{patchFlag:S,shapeFlag:O}=u;if(S>0){if(S&128){Ka(_,P,g,b,v,h,q,z,A);return}else if(S&256){oa(_,P,g,b,v,h,q,z,A);return}}O&8?(y&16&&za(_,v,h),P!==_&&c(g,P)):y&16?O&16?Ka(_,P,g,b,v,h,q,z,A):za(_,v,h,!0):(y&8&&c(g,""),O&16&&be(P,g,b,v,h,q,z,A))},oa=(d,u,g,b,v,h,q,z,A)=>{d=d||ha,u=u||ha;const _=d.length,y=u.length,P=Math.min(_,y);let S;for(S=0;S<P;S++){const O=u[S]=A?Qe(u[S]):Ne(u[S]);T(d[S],O,g,null,v,h,q,z,A)}_>y?za(d,v,h,!0,!1,P):be(u,g,b,v,h,q,z,A,P)},Ka=(d,u,g,b,v,h,q,z,A)=>{let _=0;const y=u.length;let P=d.length-1,S=y-1;for(;_<=P&&_<=S;){const O=d[_],N=u[_]=A?Qe(u[_]):Ne(u[_]);if(la(O,N))T(O,N,g,null,v,h,q,z,A);else break;_++}for(;_<=P&&_<=S;){const O=d[P],N=u[S]=A?Qe(u[S]):Ne(u[S]);if(la(O,N))T(O,N,g,null,v,h,q,z,A);else break;P--,S--}if(_>P){if(_<=S){const O=S+1,N=O<y?u[O].el:b;for(;_<=S;)T(null,u[_]=A?Qe(u[_]):Ne(u[_]),g,N,v,h,q,z,A),_++}}else if(_>S)for(;_<=P;)Oe(d[_],v,h,!0),_++;else{const O=_,N=_,J=new Map;for(_=N;_<=S;_++){const ze=u[_]=A?Qe(u[_]):Ne(u[_]);ze.key!=null&&J.set(ze.key,_)}let k,_e=0;const Ce=S-N+1;let we=!1,Te=0;const xa=new Array(Ce);for(_=0;_<Ce;_++)xa[_]=0;for(_=O;_<=P;_++){const ze=d[_];if(_e>=Ce){Oe(ze,v,h,!0);continue}let Ie;if(ze.key!=null)Ie=J.get(ze.key);else for(k=N;k<=S;k++)if(xa[k-N]===0&&la(ze,u[k])){Ie=k;break}Ie===void 0?Oe(ze,v,h,!0):(xa[Ie-N]=_+1,Ie>=Te?Te=Ie:we=!0,T(ze,u[Ie],g,null,v,h,q,z,A),_e++)}const Ps=we?Yr(xa):ha;for(k=Ps.length-1,_=Ce-1;_>=0;_--){const ze=N+_,Ie=u[ze],Ds=u[ze+1],Ss=ze+1<y?Ds.el||Ds.placeholder:b;xa[_]===0?T(null,Ie,g,Ss,v,h,q,z,A):we&&(k<0||_!==Ps[k]?sa(Ie,g,Ss,2):k--)}}},sa=(d,u,g,b,v=null)=>{const{el:h,type:q,transition:z,children:A,shapeFlag:_}=d;if(_&6){sa(d.component.subTree,u,g,b);return}if(_&128){d.suspense.move(u,g,b);return}if(_&64){q.move(d,u,g,qa);return}if(q===xe){s(h,u,g);for(let P=0;P<A.length;P++)sa(A[P],u,g,b);s(d.anchor,u,g);return}if(q===ao){G(d,u,g);return}if(b!==2&&_&1&&z)if(b===0)z.beforeEnter(h),s(h,u,g),qe(()=>z.enter(h),v);else{const{leave:P,delayLeave:S,afterLeave:O}=z,N=()=>{d.ctx.isUnmounted?i(h):s(h,u,g)},J=()=>{h._isLeaving&&h[Ge](!0),P(h,()=>{N(),O&&O()})};S?S(h,N,J):J()}else s(h,u,g)},Oe=(d,u,g,b=!1,v=!1)=>{const{type:h,props:q,ref:z,children:A,dynamicChildren:_,shapeFlag:y,patchFlag:P,dirs:S,cacheIndex:O}=d;if(P===-2&&(v=!1),z!=null&&(Ke(),wa(z,null,g,d,!0),Je()),O!=null&&(u.renderCache[O]=void 0),y&256){u.ctx.deactivate(d);return}const N=y&1&&S,J=!Ta(d);let k;if(J&&(k=q&&q.onVnodeBeforeUnmount)&&Re(k,u,d),y&6)Dt(d.component,g,b);else{if(y&128){d.suspense.unmount(g,b);return}N&&ia(d,null,u,"beforeUnmount"),y&64?d.type.remove(d,u,g,qa,b):_&&!_.hasOnce&&(h!==xe||P>0&&P&64)?za(_,u,g,!1,!0):(h===xe&&P&384||!v&&y&16)&&za(A,u,g),b&&qs(d)}(J&&(k=q&&q.onVnodeUnmounted)||N)&&qe(()=>{k&&Re(k,u,d),N&&ia(d,null,u,"unmounted")},g)},qs=d=>{const{type:u,el:g,anchor:b,transition:v}=d;if(u===xe){Pt(g,b);return}if(u===ao){M(d);return}const h=()=>{i(g),v&&!v.persisted&&v.afterLeave&&v.afterLeave()};if(d.shapeFlag&1&&v&&!v.persisted){const{leave:q,delayLeave:z}=v,A=()=>q(g,h);z?z(d.el,h,A):A()}else h()},Pt=(d,u)=>{let g;for(;d!==u;)g=C(d),i(d),d=g;i(u)},Dt=(d,u,g)=>{const{bum:b,scope:v,job:h,subTree:q,um:z,m:A,a:_}=d;Ls(A),Ls(_),b&&Za(b),v.stop(),h&&(h.flags|=8,Oe(q,d,u,g)),z&&qe(z,u),qe(()=>{d.isUnmounted=!0},u)},za=(d,u,g,b=!1,v=!1,h=0)=>{for(let q=h;q<d.length;q++)Oe(d[q],u,g,b,v)},Ja=d=>{if(d.shapeFlag&6)return Ja(d.component.subTree);if(d.shapeFlag&128)return d.suspense.next();const u=C(d.anchor||d.el),g=u&&u[vr];return g?C(g):u};let yo=!1;const xs=(d,u,g)=>{d==null?u._vnode&&Oe(u._vnode,null,null,!0):T(u._vnode||null,d,u,null,null,null,g),u._vnode=d,yo||(yo=!0,js(),Ni(),yo=!1)},qa={p:T,um:Oe,m:sa,r:qs,mt:de,mc:be,pc:K,pbc:H,n:Ja,o:e};return{render:xs,hydrate:void 0,createApp:Lr(xs)}}function Bo({type:e,props:a},o){return o==="svg"&&e==="foreignObject"||o==="mathml"&&e==="annotation-xml"&&a&&a.encoding&&a.encoding.includes("html")?void 0:o}function ta({effect:e,job:a},o){o?(e.flags|=32,a.flags|=4):(e.flags&=-33,a.flags&=-5)}function Xr(e,a){return(!e||e&&!e.pendingBranch)&&a&&!a.persisted}function ut(e,a,o=!1){const s=e.children,i=a.children;if(E(s)&&E(i))for(let t=0;t<s.length;t++){const r=s[t];let n=i[t];n.shapeFlag&1&&!n.dynamicChildren&&((n.patchFlag<=0||n.patchFlag===32)&&(n=i[t]=Qe(i[t]),n.el=r.el),!o&&n.patchFlag!==-2&&ut(r,n)),n.type===So&&n.patchFlag!==-1&&(n.el=r.el),n.type===ve&&!n.el&&(n.el=r.el)}}function Yr(e){const a=e.slice(),o=[0];let s,i,t,r,n;const l=e.length;for(s=0;s<l;s++){const m=e[s];if(m!==0){if(i=o[o.length-1],e[i]<m){a[s]=i,o.push(s);continue}for(t=0,r=o.length-1;t<r;)n=t+r>>1,e[o[n]]<m?t=n+1:r=n;m<e[o[t]]&&(t>0&&(a[s]=o[t-1]),o[t]=s)}}for(t=o.length,r=o[t-1];t-- >0;)o[t]=r,r=a[r];return o}function mt(e){const a=e.subTree.component;if(a)return a.asyncDep&&!a.asyncResolved?a:mt(a)}function Ls(e){if(e)for(let a=0;a<e.length;a++)e[a].flags|=8}const Qr=Symbol.for("v-scx"),Zr=()=>eo(Qr);function No(e,a,o){return pt(e,a,o)}function pt(e,a,o=U){const{immediate:s,deep:i,flush:t,once:r}=o,n=ne({},o),l=a&&s||!a&&t!=="post";let m;if(Va){if(t==="sync"){const x=Zr();m=x.__watcherHandles||(x.__watcherHandles=[])}else if(!l){const x=()=>{};return x.stop=Fe,x.resume=Fe,x.pause=Fe,x}}const c=ue;n.call=(x,j,T)=>je(x,c,j,T);let f=!1;t==="post"?n.scheduler=x=>{qe(x,c&&c.suspense)}:t!=="sync"&&(f=!0,n.scheduler=(x,j)=>{j?x():vs(x)}),n.augmentJob=x=>{a&&(x.flags|=4),f&&(x.flags|=2,c&&(x.id=c.uid,x.i=c))};const C=ur(e,a,n);return Va&&(m?m.push(C):l&&C()),C}function en(e,a,o){const s=this.proxy,i=ae(e)?e.includes(".")?ft(s,e):()=>s[e]:e.bind(s,s);let t;w(a)?t=a:(t=a.handler,o=a);const r=Ua(this),n=pt(i,t.bind(s),o);return r(),n}function ft(e,a){const o=a.split(".");return()=>{let s=e;for(let i=0;i<o.length&&s;i++)s=s[o[i]];return s}}const an=(e,a)=>a==="modelValue"||a==="model-value"?e.modelModifiers:e[`${a}Modifiers`]||e[`${Me(a)}Modifiers`]||e[`${pa(a)}Modifiers`];function on(e,a,...o){if(e.isUnmounted)return;const s=e.vnode.props||U;let i=o;const t=a.startsWith("update:"),r=t&&an(s,a.slice(7));r&&(r.trim&&(i=o.map(c=>ae(c)?c.trim():c)),r.number&&(i=o.map(Go)));let n,l=s[n=Eo(a)]||s[n=Eo(Me(a))];!l&&t&&(l=s[n=Eo(pa(a))]),l&&je(l,e,6,i);const m=s[n+"Once"];if(m){if(!e.emitted)e.emitted={};else if(e.emitted[n])return;e.emitted[n]=!0,je(m,e,6,i)}}const sn=new WeakMap;function gt(e,a,o=!1){const s=o?sn:a.emitsCache,i=s.get(e);if(i!==void 0)return i;const t=e.emits;let r={},n=!1;if(!w(e)){const l=m=>{const c=gt(m,a,!0);c&&(n=!0,ne(r,c))};!o&&a.mixins.length&&a.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!t&&!n?(X(e)&&s.set(e,null),null):(E(t)?t.forEach(l=>r[l]=null):ne(r,t),X(e)&&s.set(e,r),r)}function Do(e,a){return!e||!vo(a)?!1:(a=a.slice(2).replace(/Once$/,""),L(e,a[0].toLowerCase()+a.slice(1))||L(e,pa(a))||L(e,a))}function ks(e){const{type:a,vnode:o,proxy:s,withProxy:i,propsOptions:[t],slots:r,attrs:n,emit:l,render:m,renderCache:c,props:f,data:C,setupState:x,ctx:j,inheritAttrs:T}=e,oe=no(e);let R,F;try{if(o.shapeFlag&4){const M=i||s,$=M;R=Ne(m.call($,M,c,f,x,C,j)),F=n}else{const M=a;R=Ne(M.length>1?M(f,{attrs:n,slots:r,emit:l}):M(f,null)),F=a.props?n:tn(n)}}catch(M){Ra.length=0,qo(M,e,1),R=re(ve)}let G=R;if(F&&T!==!1){const M=Object.keys(F),{shapeFlag:$}=G;M.length&&$&7&&(t&&M.some(ts)&&(F=rn(F,t)),G=ea(G,F,!1,!0))}return o.dirs&&(G=ea(G,null,!1,!0),G.dirs=G.dirs?G.dirs.concat(o.dirs):o.dirs),o.transition&&La(G,o.transition),R=G,no(oe),R}const tn=e=>{let a;for(const o in e)(o==="class"||o==="style"||vo(o))&&((a||(a={}))[o]=e[o]);return a},rn=(e,a)=>{const o={};for(const s in e)(!ts(s)||!(s.slice(9)in a))&&(o[s]=e[s]);return o};function nn(e,a,o){const{props:s,children:i,component:t}=e,{props:r,children:n,patchFlag:l}=a,m=t.emitsOptions;if(a.dirs||a.transition)return!0;if(o&&l>=0){if(l&1024)return!0;if(l&16)return s?Vs(s,r,m):!!r;if(l&8){const c=a.dynamicProps;for(let f=0;f<c.length;f++){const C=c[f];if(r[C]!==s[C]&&!Do(m,C))return!0}}}else return(i||n)&&(!n||!n.$stable)?!0:s===r?!1:s?r?Vs(s,r,m):!0:!!r;return!1}function Vs(e,a,o){const s=Object.keys(a);if(s.length!==Object.keys(e).length)return!0;for(let i=0;i<s.length;i++){const t=s[i];if(a[t]!==e[t]&&!Do(o,t))return!0}return!1}function dn({vnode:e,parent:a},o){for(;a;){const s=a.subTree;if(s.suspense&&s.suspense.activeBranch===e&&(s.el=e.el),s===e)(e=a.vnode).el=o,a=a.parent;else break}}const vt=e=>e.__isSuspense;function ln(e,a){a&&a.pendingBranch?E(e)?a.effects.push(...e):a.effects.push(e):gr(e)}const xe=Symbol.for("v-fgt"),So=Symbol.for("v-txt"),ve=Symbol.for("v-cmt"),ao=Symbol.for("v-stc"),Ra=[];let De=null;function ee(e=!1){Ra.push(De=e?null:[])}function cn(){Ra.pop(),De=Ra[Ra.length-1]||null}let ka=1;function mo(e,a=!1){ka+=e,e<0&&De&&a&&(De.hasOnce=!0)}function ht(e){return e.dynamicChildren=ka>0?De||ha:null,cn(),ka>0&&De&&De.push(e),e}function se(e,a,o,s,i,t){return ht(B(e,a,o,s,i,t,!0))}function _s(e,a,o,s,i){return ht(re(e,a,o,s,i,!0))}function po(e){return e?e.__v_isVNode===!0:!1}function la(e,a){return e.type===a.type&&e.key===a.key}const bt=({key:e})=>e??null,oo=({ref:e,ref_key:a,ref_for:o})=>(typeof e=="number"&&(e=""+e),e!=null?ae(e)||he(e)||w(e)?{i:Pe,r:e,k:a,f:!!o}:e:null);function B(e,a=null,o=null,s=0,i=null,t=e===xe?0:1,r=!1,n=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:a,key:a&&bt(a),ref:a&&oo(a),scopeId:Li,slotScopeIds:null,children:o,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:t,patchFlag:s,dynamicProps:i,dynamicChildren:null,appContext:null,ctx:Pe};return n?(Cs(l,o),t&128&&e.normalize(l)):o&&(l.shapeFlag|=ae(o)?8:16),ka>0&&!r&&De&&(l.patchFlag>0||t&6)&&l.patchFlag!==32&&De.push(l),l}const re=un;function un(e,a=null,o=null,s=0,i=null,t=!1){if((!e||e===jr)&&(e=ve),po(e)){const n=ea(e,a,!0);return o&&Cs(n,o),ka>0&&!t&&De&&(n.shapeFlag&6?De[De.indexOf(e)]=n:De.push(n)),n.patchFlag=-2,n}if(qn(e)&&(e=e.__vccOpts),a){a=mn(a);let{class:n,style:l}=a;n&&!ae(n)&&(a.class=Ao(n)),X(l)&&(gs(l)&&!E(l)&&(l=ne({},l)),a.style=ds(l))}const r=ae(e)?1:vt(e)?128:Hi(e)?64:X(e)?4:w(e)?2:0;return B(e,a,o,s,i,r,t,!0)}function mn(e){return e?gs(e)||tt(e)?ne({},e):e:null}function ea(e,a,o=!1,s=!1){const{props:i,ref:t,patchFlag:r,children:n,transition:l}=e,m=a?fn(i||{},a):i,c={__v_isVNode:!0,__v_skip:!0,type:e.type,props:m,key:m&&bt(m),ref:a&&a.ref?o&&t?E(t)?t.concat(oo(a)):[t,oo(a)]:oo(a):t,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:n,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:a&&e.type!==xe?r===-1?16:r|16:r,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:l,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&ea(e.ssContent),ssFallback:e.ssFallback&&ea(e.ssFallback),placeholder:e.placeholder,el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return l&&s&&La(c,l.clone(c)),c}function ya(e=" ",a=0){return re(So,null,e,a)}function pn(e,a){const o=re(ao,null,e);return o.staticCount=a,o}function Ze(e="",a=!1){return a?(ee(),_s(ve,null,e)):re(ve,null,e)}function Ne(e){return e==null||typeof e=="boolean"?re(ve):E(e)?re(xe,null,e.slice()):po(e)?Qe(e):re(So,null,String(e))}function Qe(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:ea(e)}function Cs(e,a){let o=0;const{shapeFlag:s}=e;if(a==null)a=null;else if(E(a))o=16;else if(typeof a=="object")if(s&65){const i=a.default;i&&(i._c&&(i._d=!1),Cs(e,i()),i._c&&(i._d=!0));return}else{o=32;const i=a._;!i&&!tt(a)?a._ctx=Pe:i===3&&Pe&&(Pe.slots._===1?a._=1:(a._=2,e.patchFlag|=1024))}else w(a)?(a={default:a,_ctx:Pe},o=32):(a=String(a),s&64?(o=16,a=[ya(a)]):o=8);e.children=a,e.shapeFlag|=o}function fn(...e){const a={};for(let o=0;o<e.length;o++){const s=e[o];for(const i in s)if(i==="class")a.class!==s.class&&(a.class=Ao([a.class,s.class]));else if(i==="style")a.style=ds([a.style,s.style]);else if(vo(i)){const t=a[i],r=s[i];r&&t!==r&&!(E(t)&&t.includes(r))&&(a[i]=t?[].concat(t,r):r)}else i!==""&&(a[i]=s[i])}return a}function Re(e,a,o,s=null){je(e,a,7,[o,s])}const gn=ot();let vn=0;function hn(e,a,o){const s=e.type,i=(a?a.appContext:e.appContext)||gn,t={uid:vn++,vnode:e,type:s,parent:a,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new Nt(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:a?a.provides:Object.create(i.provides),ids:a?a.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:nt(s,i),emitsOptions:gt(s,i),emit:null,emitted:null,propsDefaults:U,inheritAttrs:s.inheritAttrs,ctx:U,data:U,props:U,attrs:U,slots:U,refs:U,setupState:U,setupContext:null,suspense:o,suspenseId:o?o.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return t.ctx={_:t},t.root=a?a.root:t,t.emit=on.bind(null,t),e.ce&&e.ce(t),t}let ue=null;const _t=()=>ue||Pe;let fo,os;{const e=Co(),a=(o,s)=>{let i;return(i=e[o])||(i=e[o]=[]),i.push(s),t=>{i.length>1?i.forEach(r=>r(t)):i[0](t)}};fo=a("__VUE_INSTANCE_SETTERS__",o=>ue=o),os=a("__VUE_SSR_SETTERS__",o=>Va=o)}const Ua=e=>{const a=ue;return fo(e),e.scope.on(),()=>{e.scope.off(),fo(a)}},Hs=()=>{ue&&ue.scope.off(),fo(null)};function Ct(e){return e.vnode.shapeFlag&4}let Va=!1;function bn(e,a=!1,o=!1){a&&os(a);const{props:s,children:i}=e.vnode,t=Ct(e);Vr(e,s,t,a),$r(e,i,o||a);const r=t?_n(e,a):void 0;return a&&os(!1),r}function _n(e,a){const o=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,wr);const{setup:s}=o;if(s){Ke();const i=e.setupContext=s.length>1?An(e):null,t=Ua(e),r=Ga(s,e,0,[e.props,i]),n=pi(r);if(Je(),t(),(n||e.sp)&&!Ta(e)&&Wi(e),n){if(r.then(Hs,Hs),a)return r.then(l=>{Gs(e,l)}).catch(l=>{qo(l,e,0)});e.asyncDep=r}else Gs(e,r)}else At(e)}function Gs(e,a,o){w(a)?e.type.__ssrInlineRender?e.ssrRender=a:e.render=a:X(a)&&(e.setupState=Ii(a)),At(e)}function At(e,a,o){const s=e.type;e.render||(e.render=s.render||Fe);{const i=Ua(e);Ke();try{Tr(e)}finally{Je(),i()}}}const Cn={get(e,a){return ce(e,"get",""),e[a]}};function An(e){const a=o=>{e.exposed=o||{}};return{attrs:new Proxy(e.attrs,Cn),slots:e.slots,emit:e.emit,expose:a}}function Mo(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(Ii(tr(e.exposed)),{get(a,o){if(o in a)return a[o];if(o in Ia)return Ia[o](e)},has(a,o){return o in a||o in Ia}})):e.proxy}function zn(e,a=!0){return w(e)?e.displayName||e.name:e.name||a&&e.__name}function qn(e){return w(e)&&"__vccOpts"in e}const xn=(e,a)=>lr(e,a,Va);function Pn(e,a,o){try{mo(-1);const s=arguments.length;return s===2?X(a)&&!E(a)?po(a)?re(e,null,[a]):re(e,a):re(e,null,a):(s>3?o=Array.prototype.slice.call(arguments,2):s===3&&po(o)&&(o=[o]),re(e,a,o))}finally{mo(1)}}const Dn="3.5.22";let ss;const Us=typeof window<"u"&&window.trustedTypes;if(Us)try{ss=Us.createPolicy("vue",{createHTML:e=>e})}catch{}const zt=ss?e=>ss.createHTML(e):e=>e,Sn="http://www.w3.org/2000/svg",Mn="http://www.w3.org/1998/Math/MathML",He=typeof document<"u"?document:null,$s=He&&He.createElement("template"),yn={insert:(e,a,o)=>{a.insertBefore(e,o||null)},remove:e=>{const a=e.parentNode;a&&a.removeChild(e)},createElement:(e,a,o,s)=>{const i=a==="svg"?He.createElementNS(Sn,e):a==="mathml"?He.createElementNS(Mn,e):o?He.createElement(e,{is:o}):He.createElement(e);return e==="select"&&s&&s.multiple!=null&&i.setAttribute("multiple",s.multiple),i},createText:e=>He.createTextNode(e),createComment:e=>He.createComment(e),setText:(e,a)=>{e.nodeValue=a},setElementText:(e,a)=>{e.textContent=a},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>He.querySelector(e),setScopeId(e,a){e.setAttribute(a,"")},insertStaticContent(e,a,o,s,i,t){const r=o?o.previousSibling:a.lastChild;if(i&&(i===t||i.nextSibling))for(;a.insertBefore(i.cloneNode(!0),o),!(i===t||!(i=i.nextSibling)););else{$s.innerHTML=zt(s==="svg"?`<svg>${e}</svg>`:s==="mathml"?`<math>${e}</math>`:e);const n=$s.content;if(s==="svg"||s==="mathml"){const l=n.firstChild;for(;l.firstChild;)n.appendChild(l.firstChild);n.removeChild(l)}a.insertBefore(n,o)}return[r?r.nextSibling:a.firstChild,o?o.previousSibling:a.lastChild]}},Xe="transition",Da="animation",Ha=Symbol("_vtc"),qt={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},En=ne({},Gi,qt),jn=e=>(e.displayName="Transition",e.props=En,e),On=jn((e,{slots:a})=>Pn(_r,wn(e),a)),ra=(e,a=[])=>{E(e)?e.forEach(o=>o(...a)):e&&e(...a)},Ks=e=>e?E(e)?e.some(a=>a.length>1):e.length>1:!1;function wn(e){const a={};for(const D in e)D in qt||(a[D]=e[D]);if(e.css===!1)return a;const{name:o="v",type:s,duration:i,enterFromClass:t=`${o}-enter-from`,enterActiveClass:r=`${o}-enter-active`,enterToClass:n=`${o}-enter-to`,appearFromClass:l=t,appearActiveClass:m=r,appearToClass:c=n,leaveFromClass:f=`${o}-leave-from`,leaveActiveClass:C=`${o}-leave-active`,leaveToClass:x=`${o}-leave-to`}=e,j=Tn(i),T=j&&j[0],oe=j&&j[1],{onBeforeEnter:R,onEnter:F,onEnterCancelled:G,onLeave:M,onLeaveCancelled:$,onBeforeAppear:ie=R,onAppear:me=F,onAppearCancelled:be=G}=a,I=(D,Y,de,Le)=>{D._enterCancelled=Le,na(D,Y?c:n),na(D,Y?m:r),de&&de()},H=(D,Y)=>{D._isLeaving=!1,na(D,f),na(D,x),na(D,C),Y&&Y()},Q=D=>(Y,de)=>{const Le=D?me:F,te=()=>I(Y,D,de);ra(Le,[Y,te]),Js(()=>{na(Y,D?l:t),Ve(Y,D?c:n),Ks(Le)||Ws(Y,s,T,te)})};return ne(a,{onBeforeEnter(D){ra(R,[D]),Ve(D,t),Ve(D,r)},onBeforeAppear(D){ra(ie,[D]),Ve(D,l),Ve(D,m)},onEnter:Q(!1),onAppear:Q(!0),onLeave(D,Y){D._isLeaving=!0;const de=()=>H(D,Y);Ve(D,f),D._enterCancelled?(Ve(D,C),Qs(D)):(Qs(D),Ve(D,C)),Js(()=>{D._isLeaving&&(na(D,f),Ve(D,x),Ks(M)||Ws(D,s,oe,de))}),ra(M,[D,de])},onEnterCancelled(D){I(D,!1,void 0,!0),ra(G,[D])},onAppearCancelled(D){I(D,!0,void 0,!0),ra(be,[D])},onLeaveCancelled(D){H(D),ra($,[D])}})}function Tn(e){if(e==null)return null;if(X(e))return[Fo(e.enter),Fo(e.leave)];{const a=Fo(e);return[a,a]}}function Fo(e){return jt(e)}function Ve(e,a){a.split(/\s+/).forEach(o=>o&&e.classList.add(o)),(e[Ha]||(e[Ha]=new Set)).add(a)}function na(e,a){a.split(/\s+/).forEach(s=>s&&e.classList.remove(s));const o=e[Ha];o&&(o.delete(a),o.size||(e[Ha]=void 0))}function Js(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let In=0;function Ws(e,a,o,s){const i=e._endId=++In,t=()=>{i===e._endId&&s()};if(o!=null)return setTimeout(t,o);const{type:r,timeout:n,propCount:l}=Rn(e,a);if(!r)return s();const m=r+"end";let c=0;const f=()=>{e.removeEventListener(m,C),t()},C=x=>{x.target===e&&++c>=l&&f()};setTimeout(()=>{c<l&&f()},n+1),e.addEventListener(m,C)}function Rn(e,a){const o=window.getComputedStyle(e),s=j=>(o[j]||"").split(", "),i=s(`${Xe}Delay`),t=s(`${Xe}Duration`),r=Xs(i,t),n=s(`${Da}Delay`),l=s(`${Da}Duration`),m=Xs(n,l);let c=null,f=0,C=0;a===Xe?r>0&&(c=Xe,f=r,C=t.length):a===Da?m>0&&(c=Da,f=m,C=l.length):(f=Math.max(r,m),c=f>0?r>m?Xe:Da:null,C=c?c===Xe?t.length:l.length:0);const x=c===Xe&&/\b(?:transform|all)(?:,|$)/.test(s(`${Xe}Property`).toString());return{type:c,timeout:f,propCount:C,hasTransform:x}}function Xs(e,a){for(;e.length<a.length;)e=e.concat(e);return Math.max(...a.map((o,s)=>Ys(o)+Ys(e[s])))}function Ys(e){return e==="auto"?0:Number(e.slice(0,-1).replace(",","."))*1e3}function Qs(e){return(e?e.ownerDocument:document).body.offsetHeight}function Bn(e,a,o){const s=e[Ha];s&&(a=(a?[a,...s]:[...s]).join(" ")),a==null?e.removeAttribute("class"):o?e.setAttribute("class",a):e.className=a}const go=Symbol("_vod"),xt=Symbol("_vsh"),Nn={name:"show",beforeMount(e,{value:a},{transition:o}){e[go]=e.style.display==="none"?"":e.style.display,o&&a?o.beforeEnter(e):Sa(e,a)},mounted(e,{value:a},{transition:o}){o&&a&&o.enter(e)},updated(e,{value:a,oldValue:o},{transition:s}){!a!=!o&&(s?a?(s.beforeEnter(e),Sa(e,!0),s.enter(e)):s.leave(e,()=>{Sa(e,!1)}):Sa(e,a))},beforeUnmount(e,{value:a}){Sa(e,a)}};function Sa(e,a){e.style.display=a?e[go]:"none",e[xt]=!a}const Fn=Symbol(""),Ln=/(?:^|;)\s*display\s*:/;function kn(e,a,o){const s=e.style,i=ae(o);let t=!1;if(o&&!i){if(a)if(ae(a))for(const r of a.split(";")){const n=r.slice(0,r.indexOf(":")).trim();o[n]==null&&so(s,n,"")}else for(const r in a)o[r]==null&&so(s,r,"");for(const r in o)r==="display"&&(t=!0),so(s,r,o[r])}else if(i){if(a!==o){const r=s[Fn];r&&(o+=";"+r),s.cssText=o,t=Ln.test(o)}}else a&&e.removeAttribute("style");go in e&&(e[go]=t?s.display:"",e[xt]&&(s.display="none"))}const Zs=/\s*!important$/;function so(e,a,o){if(E(o))o.forEach(s=>so(e,a,s));else if(o==null&&(o=""),a.startsWith("--"))e.setProperty(a,o);else{const s=Vn(e,a);Zs.test(o)?e.setProperty(pa(s),o.replace(Zs,""),"important"):e[s]=o}}const ei=["Webkit","Moz","ms"],Lo={};function Vn(e,a){const o=Lo[a];if(o)return o;let s=Me(a);if(s!=="filter"&&s in e)return Lo[a]=s;s=_o(s);for(let i=0;i<ei.length;i++){const t=ei[i]+s;if(t in e)return Lo[a]=t}return a}const ai="http://www.w3.org/1999/xlink";function oi(e,a,o,s,i,t=Bt(a)){s&&a.startsWith("xlink:")?o==null?e.removeAttributeNS(ai,a.slice(6,a.length)):e.setAttributeNS(ai,a,o):o==null||t&&!hi(o)?e.removeAttribute(a):e.setAttribute(a,t?"":aa(o)?String(o):o)}function si(e,a,o,s,i){if(a==="innerHTML"||a==="textContent"){o!=null&&(e[a]=a==="innerHTML"?zt(o):o);return}const t=e.tagName;if(a==="value"&&t!=="PROGRESS"&&!t.includes("-")){const n=t==="OPTION"?e.getAttribute("value")||"":e.value,l=o==null?e.type==="checkbox"?"on":"":String(o);(n!==l||!("_value"in e))&&(e.value=l),o==null&&e.removeAttribute(a),e._value=o;return}let r=!1;if(o===""||o==null){const n=typeof e[a];n==="boolean"?o=hi(o):o==null&&n==="string"?(o="",r=!0):n==="number"&&(o=0,r=!0)}try{e[a]=o}catch{}r&&e.removeAttribute(i||a)}function va(e,a,o,s){e.addEventListener(a,o,s)}function Hn(e,a,o,s){e.removeEventListener(a,o,s)}const ii=Symbol("_vei");function Gn(e,a,o,s,i=null){const t=e[ii]||(e[ii]={}),r=t[a];if(s&&r)r.value=s;else{const[n,l]=Un(a);if(s){const m=t[a]=Jn(s,i);va(e,n,m,l)}else r&&(Hn(e,n,r,l),t[a]=void 0)}}const ti=/(?:Once|Passive|Capture)$/;function Un(e){let a;if(ti.test(e)){a={};let s;for(;s=e.match(ti);)e=e.slice(0,e.length-s[0].length),a[s[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):pa(e.slice(2)),a]}let ko=0;const $n=Promise.resolve(),Kn=()=>ko||($n.then(()=>ko=0),ko=Date.now());function Jn(e,a){const o=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=o.attached)return;je(Wn(s,o.value),a,5,[s])};return o.value=e,o.attached=Kn(),o}function Wn(e,a){if(E(a)){const o=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{o.call(e),e._stopped=!0},a.map(s=>i=>!i._stopped&&s&&s(i))}else return a}const ri=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,Xn=(e,a,o,s,i,t)=>{const r=i==="svg";a==="class"?Bn(e,s,r):a==="style"?kn(e,o,s):vo(a)?ts(a)||Gn(e,a,o,s,t):(a[0]==="."?(a=a.slice(1),!0):a[0]==="^"?(a=a.slice(1),!1):Yn(e,a,s,r))?(si(e,a,s),!e.tagName.includes("-")&&(a==="value"||a==="checked"||a==="selected")&&oi(e,a,s,r,t,a!=="value")):e._isVueCE&&(/[A-Z]/.test(a)||!ae(s))?si(e,Me(a),s,t,a):(a==="true-value"?e._trueValue=s:a==="false-value"&&(e._falseValue=s),oi(e,a,s,r))};function Yn(e,a,o,s){if(s)return!!(a==="innerHTML"||a==="textContent"||a in e&&ri(a)&&w(o));if(a==="spellcheck"||a==="draggable"||a==="translate"||a==="autocorrect"||a==="form"||a==="list"&&e.tagName==="INPUT"||a==="type"&&e.tagName==="TEXTAREA")return!1;if(a==="width"||a==="height"){const i=e.tagName;if(i==="IMG"||i==="VIDEO"||i==="CANVAS"||i==="SOURCE")return!1}return ri(a)&&ae(o)?!1:a in e}const ni=e=>{const a=e.props["onUpdate:modelValue"]||!1;return E(a)?o=>Za(a,o):a};function Qn(e){e.target.composing=!0}function di(e){const a=e.target;a.composing&&(a.composing=!1,a.dispatchEvent(new Event("input")))}const Vo=Symbol("_assign"),Zn={created(e,{modifiers:{lazy:a,trim:o,number:s}},i){e[Vo]=ni(i);const t=s||i.props&&i.props.type==="number";va(e,a?"change":"input",r=>{if(r.target.composing)return;let n=e.value;o&&(n=n.trim()),t&&(n=Go(n)),e[Vo](n)}),o&&va(e,"change",()=>{e.value=e.value.trim()}),a||(va(e,"compositionstart",Qn),va(e,"compositionend",di),va(e,"change",di))},mounted(e,{value:a}){e.value=a??""},beforeUpdate(e,{value:a,oldValue:o,modifiers:{lazy:s,trim:i,number:t}},r){if(e[Vo]=ni(r),e.composing)return;const n=(t||e.type==="number")&&!/^0\d/.test(e.value)?Go(e.value):e.value,l=a??"";n!==l&&(document.activeElement===e&&e.type!=="range"&&(s&&a===o||i&&e.value.trim()===l)||(e.value=l))}},ed=ne({patchProp:Xn},yn);let li;function ad(){return li||(li=Jr(ed))}const od=((...e)=>{const a=ad().createApp(...e),{mount:o}=a;return a.mount=s=>{const i=id(s);if(!i)return;const t=a._component;!w(t)&&!t.render&&!t.template&&(t.template=i.innerHTML),i.nodeType===1&&(i.textContent="");const r=o(i,!1,sd(i));return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),r},a});function sd(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function id(e){return ae(e)?document.querySelector(e):e}const td="/tcc-bcc-2025/logo-unesp.svg",rd="/tcc-bcc-2025/logo-fc.jpg",nd="/tcc-bcc-2025/logo-dco.gif",dd="/tcc-bcc-2025/logo-bcc.png",ld="/tcc-bcc-2025/logo-bsi.png",$a=(e,a)=>{const o=e.__vccOpts||e;for(const[s,i]of a)o[s]=i;return o},cd={props:["titulo","subtitulo"]},ud={class:"header-bg"},md={class:"header-content"},pd={class:"text-center"};function fd(e,a,o,s,i,t){return ee(),se("header",ud,[B("div",md,[B("div",pd,[B("h1",null,le(o.titulo),1),B("p",null,le(o.subtitulo),1)]),a[0]||(a[0]=pn('<div class="logos-bottom" data-v-6901c242><img src="'+td+'" alt="UNESP - Universidade Estadual Paulista" class="logo-unesp" data-v-6901c242><img src="'+rd+'" alt="Faculdade de Cincias" class="logo-faculdade" data-v-6901c242><img src="'+nd+'" alt="DCO - Departamento de Computao" class="logo-dco" data-v-6901c242><img src="'+dd+'" alt="BCC - Bacharelado em Cincia da Computao" class="logo-curso" data-v-6901c242><img src="'+ld+'" alt="BSI - Bacharelado em Sistemas de Informao" class="logo-curso" data-v-6901c242></div>',1))])])}const gd=$a(cd,[["render",fd],["__scopeId","data-v-6901c242"]]),vd={name:"TccLink",props:{link:{type:Object,required:!0,validator(e){return e.label!==void 0}}},computed:{mensagemIndisponivel(){return"Arquivo ser disponibilizado aps a apresentao do TCC"}}},hd={class:"tcc-link-wrapper"},bd=["href","aria-label"],_d={class:"link-text"},Cd=["title"],Ad={class:"link-text"};function zd(e,a,o,s,i,t){return ee(),se("div",hd,[o.link.url?(ee(),se("a",{key:0,href:o.link.url,target:"_blank",class:"tcc-link","aria-label":`${o.link.label} do trabalho`},[B("span",_d,le(o.link.label),1)],8,bd)):(ee(),se("button",{key:1,class:"tcc-link tcc-link-disabled",disabled:"",title:t.mensagemIndisponivel},[B("span",Ad,le(o.link.label),1),a[0]||(a[0]=B("span",{class:"lock-icon"},"",-1))],8,Cd))])}const qd=$a(vd,[["render",zd],["__scopeId","data-v-04fe568d"]]),xd={name:"TccItem",components:{TccLink:qd},props:{tcc:{type:Object,required:!0},isOpen:{type:Boolean,default:!1}},computed:{hasIndisponivel(){return this.tcc.links&&this.tcc.links.some(e=>!e.url)}},methods:{toggle(){this.$emit("toggle")},formatarData(e){return new Date(e).toLocaleDateString("pt-BR",{year:"numeric",month:"long",day:"numeric"})},getCursoCompleto(e){return{BCC:"Bacharelado em Cincia da Computao",BSI:"Bacharelado em Sistemas de Informao"}[e]||e}}},Pd={class:"tcc-item"},Dd={class:"tcc-content"},Sd={class:"tcc-info"},Md={class:"info-row"},yd={class:"info-row"},Ed={class:"info-row"},jd={key:0,class:"info-row"},Od={class:"tcc-description"},wd={key:0,class:"keywords"},Td={class:"keywords-list"},Id={key:1,class:"tcc-links"},Rd={class:"links-grid"},Bd={key:0,class:"info-message"};function Nd(e,a,o,s,i,t){const r=co("TccLink");return ee(),se("div",Pd,[B("div",{class:"tcc-header",onClick:a[0]||(a[0]=(...n)=>t.toggle&&t.toggle(...n))},[B("h2",null,le(o.tcc.titulo),1),B("span",{class:Ao(["toggle-icon",{rotated:o.isOpen}])},"",2)]),re(On,{name:"slide-fade"},{default:ki(()=>[Vi(B("div",Dd,[B("div",Sd,[B("div",Md,[a[1]||(a[1]=B("strong",null,"Curso:",-1)),ya(" "+le(t.getCursoCompleto(o.tcc.curso)),1)]),B("div",yd,[a[2]||(a[2]=B("strong",null,"Autor:",-1)),ya(" "+le(o.tcc.autor),1)]),B("div",Ed,[a[3]||(a[3]=B("strong",null,"Orientador:",-1)),ya(" "+le(o.tcc.orientador),1)]),o.tcc.dataDefesa?(ee(),se("div",jd,[a[4]||(a[4]=B("strong",null,"Data de Defesa:",-1)),ya(" "+le(t.formatarData(o.tcc.dataDefesa)),1)])):Ze("",!0)]),B("div",Od,[B("p",null,le(o.tcc.descricao),1)]),o.tcc.palavrasChave&&o.tcc.palavrasChave.length?(ee(),se("div",wd,[a[5]||(a[5]=B("strong",null,"Palavras-chave:",-1)),B("div",Td,[(ee(!0),se(xe,null,Yo(o.tcc.palavrasChave,n=>(ee(),se("span",{key:n,class:"keyword-tag"},le(n),1))),128))])])):Ze("",!0),o.tcc.links&&o.tcc.links.length?(ee(),se("div",Id,[a[7]||(a[7]=B("strong",null,"Recursos disponveis:",-1)),B("div",Rd,[(ee(!0),se(xe,null,Yo(o.tcc.links,n=>(ee(),_s(r,{key:n.label,link:n},null,8,["link"]))),128))]),t.hasIndisponivel?(ee(),se("div",Bd,[...a[6]||(a[6]=[B("span",null,"Os arquivos sero disponibilizados aps a apresentao do TCC",-1)])])):Ze("",!0)])):Ze("",!0)],512),[[Nn,o.isOpen]])]),_:1})])}const Fd=$a(xd,[["render",Nd],["__scopeId","data-v-1b57329a"]]),Ld="/tcc-bcc-2025";function kd(e){return`${Ld}${e}`}const ci={monografias:"/files/monografias/",apresentacoes:"/files/apresentacoes/"};function p(e,a){const o=e==="monografia"?ci.monografias:ci.apresentacoes;return kd(`${o}${a}`)}const As=[{id:202501,titulo:"Implementao de protocolos de roteamento seguros contra ataques avanados em redes ad hoc",autor:"Alex Luiz Domingues Cassinelli",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:`Este trabalho apresenta uma evoluo dos estudos sobre segurana em Redes Mveis Ad hoc (MANET), 
    focando especificamente na mitigao de ataques do tipo Buraco Negro e Buraco de Minhoca. Atravs da 
    implementao de algoritmos avanados de roteamento que combinam tcnicas de mltiplos caminhos e verificao 
    criptogrfica, desenvolvemos um protocolo robusto capaz de detectar e isolar ns maliciosos em tempo real. 
    Os resultados experimentais demonstram uma reduo de 95% na taxa de sucesso de ataques, mantendo o overhead 
    de processamento abaixo de 8%. A soluo proposta contribui significativamente para a segurana de redes 
    mveis ad hoc em ambientes crticos.`,palavrasChave:["Segurana em Redes","MANET","Protocolos de Roteamento","Ataques Buraco Negro","Criptografia"],dataDefesa:"2025-11-15",links:[{label:"Monografia",url:null},{label:"Apresentao",url:null}]},{id:202301,titulo:"Identificao biomtrica de pessoas por meio do reconhecimento facial utilizando vision transformers",autor:"Arthur Francisco Ramos",orientador:"Dr Aparecido Nilceu Marana",curso:"BCC",descricao:"A biometria se tornou uma das formas mais seguras na tarefa de reconhecimento de indivduos, sendo o reconhecimento facial um dos problemas clssicos na rea da viso computacional. Proposto pela primeira vez h 50 anos, os sistemas de reconhecimento automtico de rostos passaram por diversas mudanas ao longo do tempo, desde algoritmos tradicionais at o uso de aprendizado de mquina profundo, com destaque nas redes neurais convolucionais, que hoje predominam as pesquisas na rea. Visando novas alternativas de mtodos para a tarefa de reconhecimento facial, este trabalho props avaliar o desempenho de uma arquitetura baseada em transformadores e autoateno com foco em imagens, o Vision Transformer, em ambientes controlados e no controlados, alm do desenvolvimento de uma aplicao completa para analisar o funcionamento do modelo de forma prtica. Para atingir tal objetivo, a metodologia aplicada consiste no uso de tcnicas de deteco e alinhamento facial, para aperfeioar o treinamento e validao do modelo de reconhecimento, em conjunto com mtodos de anlise comuns a sistemas de identificao e verificao, a fim de mensurar o desempenho da arquitetura proposta na resoluo do problema de reconhecimento facial. Os resultados demonstraram que o Vision Transformer  capaz de desempenhar a funo de reconhecimento com eficcia, todavia apresentando algumas limitaes em ambientes com maior instabilidade de iluminao e variaes de expresses faciais, principalmente devido ao tamanho limitado das bases de dados de imagens utilizadas, mas no prejudicando a experincia do usurio e a confiabilidade do aplicativo desenvolvido.",palavrasChave:["Biometria","Reconhecimento Facial","Vision Transformer"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","arthur_ramos_2023.pdf")},{label:"Apresentao",url:p("apresentacao","arthur_ramos_apresentacao_2023.pdf")}]},{id:202302,titulo:"Abordagem de aprendizado profundo para classificao de parkinson por meio de sinais de voz",autor:"Andre Luiz da Silva Junior",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"A doena de Parkinson  um distrbio neurolgico progressivo que afeta o crebro. O desenvolvimento de sistemas especializados capazes de diagnosticar automaticamente e com alta preciso estgios iniciais da Doena de Parkinon com base em sinais de fala representaria uma contribuio importante para o setor de sade. Para isso, foram analisados modelos de machining learning como a regresso logistica, support vector machine, K-Neightbors, Random Forest, Decion Tree, Naive Bayes e XGBoost, alm disso foi utilizado tcnicas de deep learning como a Rede Neural Convolucional e a Rede Neural Recorrente. Essas abordagens foram aplicadas a trs conjuntos de dados com caracteristicas prprias para um mais amplo estudo dos casos. Dois desses conjuntos de dados foram analisados com o uso de machining learning, e um com a utilizao de deep learning com sries temporais, aps o treino o modelo com o melhor desempenho foi selecionado. Os resultados revelaram que o modelo de teve um desempenho melhor nos dois conjunto de dados que utilizaram machining learning foi a Regresso Linear, e no deep learning foi a Rede Neural Convolucional. Os resultados obtidos revelaram uma acurcia de classificao de 92.31% e 86.84% para os dois conjuntos de dados, o que evidencia a capacidade de obter resultados excelentes mesmo com um conjunto limitado de dados. Alm disso, foram observadas precises de 91.43% e 86.72%, recalls de 100.00% e 97.37%, e F1-Scores de 95.52% e 91.74%. Esses valores corroboram a qualidade dos resultados alcanados. Por sua vez, a Rede Neural Convolucional apresentou uma acurcia de classificao de 86.69%, preciso de 86.83%, recall de 88.20% e F1-Score de 87.51%, mesmo com um nmero reduzido de pocas de treinamento. Isso evidencia a eficcia desse modelo como uma alternativa valiosa para a classificao. Esses resultados indicam que as classificaes tero um papel significativo no avano do setor mdico.  importante ressaltar a relevncia de uma anlise cuidadosa na escolha do modelo a ser utilizado, pois diferentes conjuntos de dados podem apresentar resultados mais favorveis em modelos distintos.",palavrasChave:["Parkinson","Sinais de Voz","Classificao"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","andre_junior_2023.pdf")},{label:"Apresentao",url:p("apresentacao","andre_junior_apresentacao_2023.pdf")}]},{id:202303,titulo:"Auxlio ao diagnstico de doena neurodegenerativa utilizando expresses faciais",autor:"Arissa Yoshida",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"O diagnstico precoce da Esclerose Lateral Amiotrfica (ELA)  fundamental para a determinao do incio dos tratamentos, auxiliando tanto no aumento da expectativa de vida quanto na melhora da qualidade de seus pacientes. A anlise de movimentos faciais fornece informaes importantes para o reconhecimento dos sintomas iniciais da ELA; entretanto, detectar esses sinais no  uma tarefa fcil. Com o advento da viso computacional e dos modelos de aprendizado de mquina, mtodos computacionais de auxlio a diagnstico de doenas neurodegenerativas por meio de vdeos vm se tornando uma realidade, gerando diferentes abordagens para deteco dos biomarcadores da ELA. Por utilizarem mtodos interpretativos, grande parte dos estudos acabam por no explorar a dimenso temporal durante o processo de classificao. Este trabalho prope introduzir modelos sequenciais de Redes Neurais Recorrentes (Recurrent Neural Network - RNN) em dados sequenciais (vdeos) de tal forma que seja investigada a relevncia da dinmica temporal das unidades de ao (Action Units - AUs) na identificao da ELA. Concluindo com o desenvolvimento de uma ferramenta de auxlio ao diagnstico por computador (computer-aided diagnosis, CAD).",palavrasChave:["Esclerose Lateral Amiotrfica","Expresses Faciais","Redes Neurais Recorrentes","Doena Neurodegenerativa"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","arissa_yoshida_2023.pdf")},{label:"Apresentao",url:p("apresentacao","arissa_yoshida_apresentacao_2023.pdf")}]},{id:202304,titulo:"Implementao do devops para gerenciamento de riscos de segurana na nuvem",autor:"Artur Kyung Min Lee",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"A conjuntura do mundo da tecnologia nos ltimos anos permitiu com que a computao em nuvem progredisse de forma exponencial por ter diversos benefcios como a velocidade, a escalabilidade, o custo, a disponibilidade e outros. Porm, assim como novas tecnologias de nuvem foram surgindo, ameaas cibernticas tambm foram aumentando. Hoje, tornou-se necessrio que todo ambiente em 	extit{cloud} tenha ferramentas que sejam capazes de manter a integridade, confiabilidade e disponibilidade das aplicaes nesse ambiente. Entende-se que uma das principais funes das ferramentas de segurana  de detectar falhas ou aes suspeitas que devem ser bloqueadas em prol da proteo da aplicao. Por conta disso,  vital que as tecnologias de segurana sejam implementadas com um estudo prvio para que possam incorporar-se ao fluxo da aplicao sem anular os principais benefcios da nuvem. Esse trabalho prope integrar ferramentas de segurana de maneira que as mesmas no interfiram de negativamente no fluxo da aplicao. Seguindo as melhores prticas do DevOps, ser criado uma aplicao/programa na nuvem (AWS) que tenha fluxo de integrao e entrega contnuas onde sero integradas as ferramentas responsveis por trazer segurana e visibilidade ao ambiente.",palavrasChave:["DevOps","Segurana na Nuvem","Gerenciamento de Riscos"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","artur_lee_2023.pdf")},{label:"Apresentao",url:p("apresentacao","artur_lee_apresentacao_2023.pdf")}]},{id:202305,titulo:"Criao de um mapeador objeto-grafo para otimizao e simplificao no gerenciamento de bancos de dados baseados em grafos em ambientes de big data: uma anlise comparativa com mapeadores objeto-relacional e outros bancos de dados",autor:"Cassiano Henrique A Rodrigues",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"O trabalho visou criar um mapeador objeto-grafo (OGM) para melhorar a manipulao e recuperao de dados em ambientes de big data. Em cenrios de grande amplitude de da- dos,  crucial escolher solues eficientes, uma vez que a complexidade desses ambientes pode impactar negativamente o desempenho. Portanto introduziu-se uma camada de abstrao por meio dos OGMs para simplificar a interao com bancos de dados baseados em grafos. O projeto concentrou-se na estruturao, implementao e avaliao do mapeador. Testes exaustivos foram realizados para capturar mtricas e indicadores, demonstrando a eficin- cia do mapeador em otimizar a manipulao e recuperao de dados, proporcionando uma experincia simplificada para os desenvolvedores e validando sua capacidade de aprimorar a eficcia na manipulao de dados e fornecer uma interface intuitiva para o desenvolvi- mento de aplicaes.",palavrasChave:["Mapeador Objeto-Grafo","Big Data","Bancos de Dados em Grafos","Objeto-Relacional","Otimizao","Simplificao"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","cassiano_rodrigues_2023.pdf")},{label:"Apresentao",url:p("apresentacao","cassiano_rodrigues_apresentacao_2023.pdf")}]},{id:202306,titulo:"Anlise do impacto da segurana viria na mobilidade ativa",autor:"Danilo Alves Siqueira",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O presente trabalho tem como proposta aplicar tcnicas de cincia de dados com python para analisar e visualizar dados tabulares e geolocalizados com o objetivo de entender o impacto do cenrio atual da segurana viria sobre a mobilidade ativa na cidade de So Paulo. As anlises buscam entender o panorama referente a quantidade de acidentes envolvendo ciclistas e pedestres, a distribuio desses, alm de caractersticas dos acidentes e acidentados. Visa-se tambm entender a influncia da segurana das infraestruturas ciclovirias sobre os acidentes e o gasto gerado ao sistema de sade pblico para atendimento das vtimas.",palavrasChave:["Segurana Viria","Mobilidade Ativa","Cincia de Dados","Python","Acidentes"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","danilo_siqueira_2023.pdf")},{label:"Apresentao",url:p("apresentacao","danilo_siqueira_apresentacao_2023.pdf")}]},{id:202307,titulo:"Estudo sobre fraudes digitais e o desenvolvimento de aplicativo para smartphones android e ios para uso em palestras de sensibilizao e esclarecimento",autor:"Gabriel Carvalho Polido",orientador:"Prof. Assoc. Eduardo Martins Morgado",curso:"BCC",descricao:"Golpes e fraudes digitais so uma ameaa em constante evoluo, principalmente quando utilizam trs estratgias de ataque: Phishing, Spoofing e Engenharia Social. Durante a pesquisa, foi destacada a natureza sofisticada dessas ameaas, que visam enganar os usurios e obter acesso a informaes confidenciais. O estudo forneceu uma anlise aprofundada de cada estratgia, explorando exemplos de casos e tcnicas de mitigao. Alm disso, foram estudadas as estratgias de ataque que so utilizadas atualmente para que seja possvel enfrentar com xito essas ameaas. tais estratgias de ataque tem o intuito de roubar informaes e recursos, visando posteriormente utilizar tais informaes para aplicar golpes e fraudes elaboradas na vtima. Assim sendo, foi enfatizada a importncia da conscientizao e da educao como estratgias cruciais para proteger indivduos e organizaes contra essas ameaas digitais em um ambiente cada vez mais interconectado, dependente da tecnologia e em constante evoluo. Foi desenvolvido um aplicativo informtico que incentiva as pessoas a tomarem medidas mais proativas para combater eficazmente os golpes e fraudes digitais, garantindo um ambiente ciberntico mais seguro.",palavrasChave:["Fraudes Digitais","Golpes Digitais","Phishing","Spoofing","Engenharia Social","Segurana da Informao"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","gabriel_polido_2023.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_polido_apresentacao_2023.pdf")}]},{id:202308,titulo:"Aplicativo gamificado para organizao de tarefas e rotinas acadmicas",autor:"Gabriel Henrique Garcia Ticianeli",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"O ingresso na faculdade  um momento de mudanas drsticas no estilo de vida dos estudantes. Ele marca uma transio onde o aluno deve se adaptar a novas responsabilidades que muitas vezes causam uma sobrecarga de trabalho. Esse aumento na demanda pode ser esmagador para aqueles que esto despreparados. Dessa forma, manejar o pouco tempo disponvel de maneira efetiva torna-se essencial para o sucesso acadmico. Como soluo para o problema mencionado, o trabalho objetivou desenvolver um aplicativo mobile gamificado para organizao de tarefas e rotinas, chamado de Guilda dos Universitrios. Gamificao  a utilizao de elementos de design de jogos em aplicaes que no so jogos puros, visando aumentar a interatividade e o engajamento do usurio. Utilizando esta estratgia, o sistema foi projetado para fornecer uma maneira mais envolvente e motivadora de gerenciar a carga de trabalho acadmica e criar bons hbitos. Por ser o sistema operacional mais usado pelos smartphones, foi escolhido o Android como plataforma para o programa, e a construo do trabalho foi feita na Unity Engine. O aplicativo resultante possui as funes de cadastrar tarefas (tanto nicas quanto repetveis), contabilizar hbitos dirios e formar grupos de usurios para compartilharem dos mesmos afazeres. As ferramentas so complementadas por mecnicas de progresso e recompensas, e os grupos possuem uma tabela de classificao para estimular a competitividade. Os resultados obtidos de uma comparao deste projeto com outros disponveis no mercado de aplicativos mostra que existem poucas opes para organizao de tarefas que aplicam a gamificao, e dentre estes, no h a presena de sistemas cooperativos entre os usurios.",palavrasChave:["Aplicativo Gamificado","Organizao de Tarefas","Rotinas Acadmicas","Gamificao","Unity"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","gabriel_ticianeli_2023.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_ticianeli_apresentacao_2023.pdf")}]},{id:202309,titulo:"Qualidade de software: anlise de desempenho de ferramentas de automao em testes E2E",autor:"Geovanna Carolina F V T Brandao",orientador:"Prof. Dr Kleber Rocha de Oliveira",curso:"BCC",descricao:"O presente trabalho tem como tema a anlise de desempenho de ferramentas de automao de testes de ponta-a-ponta. Onde o objetivo  abordar esse estudo de caso a partir do modelo ISSO 25010, aliado aos critrios ortogonais de classificao da abordagem de localizao de objetos em tela. Ademais,  realizada uma anlise do parecer da indstria de tecnologia em relao a essa categoria de testes. A escolha deste tema  impulsionada pela crescente complexidade dos sistemas de software, a necessidade da reduo de custos e aumento da dependncia social na tecnologia da informao.",palavrasChave:["Qualidade de Software","Testes E2E","Automao de Testes","Desempenho de Ferramentas"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","geovanna_brandao_2023.pdf")},{label:"Apresentao",url:p("apresentacao","geovanna_brandao_apresentacao_2023.pdf")}]},{id:202310,titulo:"Uso de aprendizado de mquina para deteco de ataques DDoS",autor:"Gustavo Amaral Duarte Rego",orientador:"Prof. Dr. Kelton Augusto P da Costa",curso:"BCC",descricao:"A Segurana Ciberntica  um tema que possui muita relevncia nos dias atuais, uma vez que a sociedade depende cada vez mais do mundo digital e de suas ferramentas. Ataques nesse meio so comuns de diversas formas, mas um dos mais ameaadores para um servio  o Distributed Denial of Service, ou, Ataque de negao de servio distribudo, que tem por objetivo esgotar recursos do host. Aprendizado de Mquina pode ser definido como uma ramificao da inteligncia artificial, que foca no uso de dados e algoritmos para imitar a forma como humanos aprendem. Por ser altamente eficiente no reconhecimento de padres,  possvel utilizar algoritmos desse tipo para auxiliar no reconhecimento de ataques cibernticos. Nesse trabalho so abordados estudos e implementaes sobre o uso desses algoritmos para verificar sua acurcia e viabilidade utilizando conjuntos de dados de trfego de rede",palavrasChave:["Aprendizado de Mquina","Deteco de Ataques","DDoS","Segurana Ciberntica"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","gustavo_rego_2023.pdf")},{label:"Apresentao",url:p("apresentacao","gustavo_rego_apresentacao_2023.pdf")}]},{id:202311,titulo:"Uso de aprendizado de mquina para deteco de faces falsas geradas por inteligncia artificial",autor:"Joo Pedro Vieira Rodrigues",orientador:"Prof. Dr. Kelton Augusto P da Costa",curso:"BCC",descricao:"O avano no campo da inteligncia artificial, especialmente na rea de aprendizado profundo, possibilitou a criao de rostos humanos por meio de modelos de redes neurais, como a Generative Adversarial Network (GAN). Entretanto, esse avano levantou preocupaes significativas em relao  segurana, especialmente nos contextos de biometria e autenticao digital. Diante desse problema, este trabalho concentra-se na aplicao de uma tcnica especfica de aprendizado de mquina conhecida como Capsule Neural Network (CapsNet). Esta abordagem se mostrou promissora para o processamento de imagens e ser comparada a outras tcnicas, como Local Binary Pattern, Res-Net e Gram-Net. A anlise detalhada desses mtodos permitir uma compreenso mais aprofundada de suas capacidades e limitaes, contribuindo para o desenvolvimento de sistemas mais seguros e eficazes no contexto da inteligncia artificial e suas aplicaes prticas. A avaliao crtica dessas tcnicas  essencial para aprimorar a segurana e a autenticidade em sistemas que dependem de reconhecimento facial e autenticao digital.",palavrasChave:["Aprendizado de Mquina","Deteco de Faces Falsas","Inteligncia Artificial","Capsule Neural Network","Generative Adversarial Network"],dataDefesa:"2023-10",links:[{label:"Monografia",url:p("monografia","joao_rodrigues_2023.pdf")},{label:"Apresentao",url:p("apresentacao","joao_rodrigues_apresentacao_2023.pdf")}]},{id:202312,titulo:"Aplicao de solid em um sistema web para intermediao de compra e venda de comida na unesp",autor:"Julio Cesar Benelli Varella",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"A venda de alimentos por estudantes universitrios tem se mostrado uma prtica recorrente e vital para a manuteno financeira e suporte de projetos acadmicos. Diante das dificuldades enfrentadas pelos estudantes para sustentar-se durante o curso, somado  necessidade de financiamento para projetos de extenso, o desenvolvimento de um sistema unificado para a comercializao de alimentos emerge como uma soluo estratgica. Este trabalho prope a criao de um sistema Web para facilitar e otimizar a venda de alimentos no campus da UNESP-Bauru, fornecendo um ponto de encontro virtual entre compradores e vendedores. Alm disso, o sistema  desenvolvido com nfase em prticas de codificao limpa e padres de projeto, utilizando princpios SOLID e o padro MVC para assegurar um cdigo organizado, manutenvel e expansvel. A escolha do framework Symfony e do Bootstrap proporciona a funcionalidade e responsividade necessrias ao sistema. A disponibilizao do cdigo como open-source refora a inteno de contribuir para a comunidade acadmica, permitindo evoluo contnua do projeto. Este trabalho, portanto, no s atende uma necessidade prtica, mas tambm promove a manutenibilidade, a extensibilidade do sistema e a prtica colaborativa dentro do ambiente universitrio.",palavrasChave:["Sistema Web","Compra e Venda de Comida","UNESP","SOLID","MVC","Symfony","Bootstrap"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","julio_varella_2023.pdf")},{label:"Apresentao",url:p("apresentacao","julio_varella_apresentacao_2023.pdf")}]},{id:202313,titulo:"Deteco de fake news em portugus utilizando inferncia de linguagem natural",autor:"Larissa Mayumi Barela Hondo",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"Com o advento da Internet,  possvel obter informaes a partir de quaisquer fontes sobre eventos ao redor do mundo, inclusive informaes imprecisas e at mesmo falsas, sendo estas chamadas de fake news. A divulgao e a proliferao de fake news podem causar prejuzos e danos serssimos para as pessoas e para a sociedade de modo geral, salientando a extrema importncia de sua identificao. Isso pode ser feito com o uso do Processamento de Linguagem Natural, que abrange tcnicas computacionais para a anlise automtica e  representao de linguagens antropolgicas. Por exemplo, a deteco de fake news pode ser feita com a Inferncia de Linguagem Natural, uma sub-rea do Processamento de Linguagem Natural focada na verificao da implicao ou contradio em um par de sentenas, que pode ser utilizada neste contexto considerando notcias j confirmadas como sendo verdadeiras como a premissa e uma notcia suspeita como a hiptese, dessa forma, caso haja contradio entre a hiptese e a premissa, a notcia suspeita  considerada falsa, caso contrrio, ela  rotulada como verdadeira. Visto isso, o objetivo deste trabalho  propor um mtodo de deteco automtica de fake news para a lngua portuguesa utilizando a Inferncia de Linguagem Natural. Como no h uma base de dados em portugus que utilize a Inferncia de Linguagem Natural para esta aplicao,  possvel traduzir dados j existentes para este idioma, em vista disso, neste trabalho utilizou-se a base de dados em ingls denominada FNID-FakeNewsNet. Com base nos resultados obtidos para o conjunto de teste, observa-se um desempenho melhor quando a premissa  utilizada junto  hiptese. Alm disso, de modo geral,  possvel observar que os resultados no foram afetados significativamente pela traduo dos dados em ingls para o portugus.",palavrasChave:["Fake News","Inferncia de Linguagem Natural","Processamento de Linguagem Natural","Deteco Automtica","FNID","FakeNewsNet"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","larissa_hondo_2023.pdf")},{label:"Apresentao",url:p("apresentacao","larissa_hondo_apresentacao_2023.pdf")}]},{id:202314,titulo:"Construo de um mdulo quntico para o classificador baseado em floresta de caminhos timos",autor:"Maria Anglica Krger Miranda",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"O interesse pela computao quntica tem experimentado um aumento constante, impulsionado principalmente pelas recentes inovaes tecnolgicas anunciadas por empresas renomadas, como a IBM e a Google. Essas inovaes tm o potencial de solucionar desafios significativos em diversos setores, como financeiro, mdico, fsico, farmacutico, qumico, entre outros. Esse potencial advm da capacidade da computao quntica de resolver problemas que eram anteriormente considerados inviveis. Concomitantemente a esse crescimento, o campo do aprendizado de mquina tem se destacado como uma ferramenta computacional crucial para o desenvolvimento de novas solues e tecnologias. Desta forma, o trabalho tem por interesse implementar e avaliar um mdulo quntico para o classificador baseado em floresta de caminhos timos para explorar a abordagem hbrida do aprendizado de mquina quntico. Os experimentos conduzidos revelaram desafios a serem superado, no entanto, a implementao demonstrou ser promissora devido  sua viabilidade, alm de representar o primeiro estudo sobre a aplicao da computao quntica neste classificador em especfico.",palavrasChave:["Computao Quntica","Aprendizado de Mquina Quntico","Floresta de Caminhos timos","Classificador Quntico"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","maria_miranda_2023.pdf")},{label:"Apresentao",url:p("apresentacao","maria_miranda_apresentacao_2023.pdf")}]},{id:202315,titulo:"Desenvolvimento de uma aplicao integrada para gerenciamento de projetos e recursos para programadores",autor:"Matheus dos Santos Ribeiro Silva",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"A rea de Desenvolvimento de Software experimentou um crescimento exponencial nas ltimas dcadas, impulsionando uma revoluo tecnolgica que tem tido um impacto significativo na vida cotidiana de bilhes de pessoas. Esse avano se traduz em benefcios notveis em setores como Educao, Medicina, Engenharia, Matemtica, Indstria, entre outros. Em consonncia com a crescente demanda, houve um aumento substancial na quantidade de profissionais de desenvolvimento de software. No contexto da programao no Brasil, modalidades de emprego mais flexveis, a exemplo o trabalho como pessoa jurdica, oferece vantagens atrativas, como salrios superiores e benefcios fiscais. No entanto, a gesto de projetos em diversas empresas, em mltiplos projetos e com uma variedade de tecnologias pode ser desafiadora, resultando na disperso da ateno dos programadores, o que prejudica sua eficincia e desempenho. Com o advento e a disseminao do acesso s Inteligncias Artificiais Generativas (IAG) para um pblico mais amplo, observou-se a integrao de servios e conjuntos de software com Inteligncia Artificial (IA), unificando funcionalidades e dados para melhorar a eficincia e o desempenho dos usurios. Grandes empresas, como Microsoft e Google, buscam cada vez mais integrar seus diversos servios e ambientes de trabalho com IAs, como o ChatGPT da OpenAI ou o Bart da Google, com o objetivo de disponibilizar produtos teis para seus usurios e otimizar seus lucros por meio da melhoria contnua de suas ferramentas. Nesse contexto, este projeto prope a criao de uma dashboard integrada que utiliza uma Application Programing Interface (API) do ChatGPT e do Google Workspace. Essa plataforma visa centralizar o gerenciamento de cdigos e anotaes em projetos de desenvolvimento, com o propsito de aprimorar a eficincia e a produtividade dos desenvolvedores de software.",palavrasChave:["Gerenciamento de Projetos","Desenvolvimento de Software","Inteligncia Artificial Generativa","ChatGPT","Google Workspace","Dashboard Integrada"],dataDefesa:"2023-03-11",links:[{label:"Monografia",url:p("monografia","matheus_silva_2023.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_silva_apresentacao_2023.pdf")}]},{id:202316,titulo:"Deteco de imagens deepfake: um estudo comparativo",autor:"Miguel Cesar Correa",orientador:"Prof. Dr. Leandro A Passos Junior",curso:"BCC",descricao:"Com o avano acelerado da inteligncia artificial, os deepfakes - vdeos ou imagens manipulados de maneira convincente - emergiram como uma preocupao significativa na era digital. Essas falsificaes hiper-realistas tm o potencial de enganar indivduos, disseminar desinformao e comprometer a autenticidade da informao, representando uma ameaa real  segurana digital e  integridade informativa. Este trabalho aborda a necessidade de desenvolver mtodos eficazes para a deteco de deepfakes, uma ferramenta essencial na luta contra a desinformao, apresentando os conceitos fundamentais da rea. Este trabalho comparou trs mtodos estado-da-arte de deteco de imagens falsas, apresentando resultados satisfatrios, com o mtodo que emprega medidas contra o sobre-ajuste tendo o melhor desempenho.",palavrasChave:["Deepfake","Deteco de Imagens Falsas","Inteligncia Artificial","Segurana Digital","Desinformao"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","miguel_correa_2023.pdf")},{label:"Apresentao",url:p("apresentacao","miguel_correa_apresentacao_2023.pdf")}]},{id:202317,titulo:"Anlise de dados da sade para melhorias em polticas pblicas",autor:"Nathan Del Grande Souza",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O campo da sade pblica enfrenta desafios complexos. Questes de desigualdade na distribuio de mdicos e alto deslocamento de pacientes para internaes tm implicaes profundas na eficincia e equidade do SUS (Sistema nico de Sade). Este trabalho tem como objetivo investigar esses desafios crticos por meio de anlises geoespaciais, grficas e correlacionais. Visa-se avaliar a distribuio de mdicos, o deslocamento de pacientes e a possvel relao entre esses fatores. Alm disso, busca-se fornecer uma base slida para melhorar as polticas pblicas de sade no estado de So Paulo. O estudo empregou anlises geoespaciais para mapear a distribuio de mdicos, grficos de disperso para explorar relaes entre variveis-chave, como renda per capita e deslocamento de pacientes, e anlises correlacionais com o mtodo de Pearson para quantificar essas relaes. As anlises revelaram disparidades significativas na distribuio de mdicos e desafios relacionados ao deslocamento de pacientes. Correlaes importantes foram identificadas, mas a complexidade das variveis sugere que h fatores adicionais a serem considerados.",palavrasChave:["Sade Pblica","Anlise de Dados","Polticas Pblicas","Desigualdade na Sade","Geoespacial"],dataDefesa:"2023-16-11",links:[{label:"Monografia",url:p("monografia","nathan_souza_2023.pdf")},{label:"Apresentao",url:p("apresentacao","nathan_souza_apresentacao_2023.pdf")}]},{id:202318,titulo:"Diagnstico automtico de avc ps-trauma com base na face de pacientes utilizando redes neurais em grafos",autor:"Ncolas Barbosa Gomes",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"O acidente vascular cerebral (AVC) pode causar danos significativos aos neurnios, resultando em vrias sequelas que afetam negativamente a capacidade do paciente de realizar atividades dirias essenciais, como mastigar, engolir e se comunicar verbalmente. Portanto,  importante que pacientes com essas dificuldades passem por um processo de tratamento e sejam monitorados durante sua execuo para avaliar a melhora de sua condio de sade. O uso de ferramentas computadorizadas e algoritmos que podem detectar rapidamente e de maneira acessvel tais sequelas  til para auxiliar na recuperao do paciente. Devido  morte das clulas internas do crebro, um AVC frequentemente leva  paralisia facial, resultando em assimetria entre os dois lados do rosto. Esta monografia se concentra na anlise desta assimetria usando um mtodo de aprendizado profundo sem aplicar clculos de caractersticas manuais, introduzindo o modelo Facial Point Graphs (FPG), uma abordagem inovadora que se destaca na aprendizagem de informaes geomtricas e no tratamento eficaz de variaes, alm do escopo dos clculos manuais. O FPG permite que o modelo detecte de forma eficaz os distrbios orofaciais causados por um AVC, a partir de imagens do paciente. A abordagem proposta atingiu acurcias superiores a 90% no conjunto de dados Toronto Neuroface, apontando para avanos substanciais neste domnio.",palavrasChave:["Acidente Vascular Cerebral","Redes Neurais em Grafos","Diagnstico Automtico","Assimetria Facial","Facial Point Graphs"],dataDefesa:"2023-16-11",links:[{label:"Monografia",url:p("monografia","nicolas_gomes_2023.pdf")},{label:"Apresentao",url:p("apresentacao","nicolas_gomes_apresentacao_2023.pdf")}]},{id:202319,titulo:"Desenvolvimento de uma aplicao para anlise de desempenho de grandes modelos de linguagem",autor:"Nicole Barbosa Gomes",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"A linguagem  uma necessidade humana desde sua origem. Com mtodos mais rudimentares ou mais rebuscados, o ser humano encontra maneiras de se comunicar. A partir do surgimento dos computadores e das mudanas proporcionadas por eles, um novo desafio tambm chegou: descobrir como gerar conversaes com as mquinas. Os estudos a esse respeito levaram a invenes importantes que provocaram ideias antes consideradas impossveis. A rea de aprendizado de mquina foi responsvel pela maior parte desses avanos e, graas ao ramo, modelos de redes neurais artificiais foram cada vez mais explorados. Como um dos resultados, os large language models, caracterizados por serem compostos por essas redes, apresentaram resultados admirveis ao produzir textos muito parecidos com os escritos por humanos. O sucesso desses modelos despertou o interesse de empresas que passaram a desenvolver suas prprias verses. A partir disso, cresce a demanda por entender quais deles so mais apropriados para certas aplicaes, e outras questes de desempenho. Com esse propsito, o projeto buscou desenvolver um site que pudesse reunir large language models a fim de que gerassem respostas baseadas em instrues do usurio. Alm disso, a aplicao deveria ser capaz de receber feedbacks sobre o melhor texto para uma instruo especfica e, dessa maneira, possibilitar anlises dos dados coletados para descobrir os pontos fracos e fortes de cada modelo. No final do desenvolvimento, esses objetivos foram atingidos e o site se tornou uma ferramenta intuitiva, para atender a um grande pblico, e proveitosa para captura de informaes relevantes e estudo dos retornos recebidos.",palavrasChave:["Grandes Modelos de Linguagem","Aprendizado de Mquina","Redes Neurais Artificiais","Anlise de Desempenho","Processamento de Linguagem Natural"],dataDefesa:"2023-16-11",links:[{label:"Monografia",url:p("monografia","nicole_gomes_2023.pdf")},{label:"Apresentao",url:p("apresentacao","nicole_gomes_apresentacao_2023.pdf")}]},{id:202320,titulo:"Reconhecimento de marcha humana utilizando poses 3d estimadas de mltiplas poses 2d",autor:"Pedro Luiz Cason Caldato",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"O reconhecimento biomtrico de indivduos  um campo de estudo amplamente explorado nos dias atuais, impulsionado pelos avanos recentes na computao e pela necessidade premente de reforar a segurana em diversas configuraes, incluindo vigilncia e processos de autenticao em aplicativos como bancos e gerenciamento de documentos. Dentre as diversas abordagens biomtricas desenvolvidas, destacam-se o reconhecimento facial, anlise de impresses digitais, leitura da ris e reconhecimento de voz. No entanto, esses mtodos geralmente exigem interao direta com os indivduos, equipamentos especializados (no caso do reconhecimento de impresses digitais) ou imagens de alta resoluo (no caso do reconhecimento facial ou de ris). Em situaes que demandam reconhecimento biomtrico indireto, a anlise da marcha se mostra valiosa. Essa abordagem envolve a avaliao do padro de caminhada de um indivduo, bem como a anlise de medidas relacionadas ao comprimento dos membros, como braos e pernas, a fim de identificar a pessoa comparando-a com um banco de dados existente. Este projeto tem como objetivo estabelecer uma abordagem de reconhecimento biomtrico com base na marcha, utilizando representaes tridimensionais de poses humanas extradas de mltiplas imagens bidimensionais. Uma das vantagens notveis dessa abordagem  sua maior resistncia a ocluses, juntamente com um aumento na preciso do reconhecimento da marcha, alcanado por meio da incorporao de um conjunto mais abrangente de dados correlacionados provenientes de diferentes fontes de cmeras. O mtodo proposto faz uso de uma Rede Neural Convolucional (CNN) para calcular um vetor descritivo por meio da agregao temporal das poses tridimensionais estimadas a partir de mltiplas imagens bidimensionais. A eficcia desse mtodo foi avaliada usando as bases de dados CASIA GAIT-A e CASIA GAIT-B, resultando em taxas de preciso de 90,00% e 86,10%, respectivamente.",palavrasChave:["marca humana","biometria","poses 3D","redes neurais convolucionais","reconhecimento de padres","poses 2D"],dataDefesa:"2023-14-11",links:[{label:"Monografia",url:p("monografia","pedro_caldato_2023.pdf")},{label:"Apresentao",url:p("apresentacao","pedro_caldato_apresentacao_2023.pdf")}]},{id:202321,titulo:"Anlise do desempenho de honeypots e algoritmos de machine learning em tarefas de deteco de intruso",autor:"Renato Leite Camilo",orientador:"Prof. Dr. Kelton Augusto P da Costa",curso:"BCC",descricao:"A cibersegurana  uma rea de grande interesse na computao. A capacidade de detectar e lidar com invasores em ambientes digitais  uma preocupao para muitas pessoas e empresas. Em contrapartida, os mecanismos que proporcionam essa capacidade nem sempre so totalmente confiveis, falhando em algumas ocasies e causando prejuzos inimaginveis para seus usurios. Como resoluo para esse problema, muito se prope o uso de machine learning. Esse projeto emprega dois algoritmos de clustering: K-Means e DBSCAN. O objetivo  analisar seu impacto quando usados em conjuntos com outros classificadores baseados em trs algoritmos de aprendizado de mquina: Support Vector Machines, Multilayer Perceptron e K-Nearest Neighbors. Alm disso,  empregado o conceito de honeypots para analisar sua usabilidade como receptculo de informaes a respeito de ataques para providenciar dados aos modelos preditivos. Tudo que chega a um honeypot  considerando um ataque e esse tipo de informao pode ser aproveitado por modelos de aprendizado de mquina.",palavrasChave:["Cibersegurana","Ciberataques","Honeypots","Machine Learning","Clustering"],dataDefesa:"2023-12",links:[{label:"Monografia",url:p("monografia","renato_camilo_2023.pdf")},{label:"Apresentao",url:p("apresentacao","renato_camilo_apresentacao_2023.pdf")}]},{id:202322,titulo:"Minerao de repositrios para anlise de ciclos de software",autor:"Ronaldo Rubens Gesse Junior",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"Em um cenrio tecnolgico em constante evoluo, a anlise para escolha dos componentes e tecnologias de forma assertiva desempenha um papel crucial no sucesso de qualquer projeto de software. Frameworks e bibliotecas so componentes essenciais que oferecem funcionalidades ao cdigo e agilizam o processo de desenvolvimento, auxiliando times a entregar um resultado de forma mais eficiente ao usurio final. A minerao de repositrios surgiu como uma forma valiosa de obter informaes sobre os cdigos-fonte desses softwares, possibilitando anlises que visualizem seus ciclos de vida e entendam seu estado atual. Neste trabalho foram analisados 85 softwares com mtricas de tendncias e correlaes para os seguintes dados: nmero de commits e autores dos seus respectivos repositrios de cdigo e nvel do interesse relativo, com base nos dados do Google Trends para medir engajamento dos desenvolvedores. A partir disso foi possvel analisar os resultados e entender se determinado projeto  realmente vivel em seu estado atual de vida, se ele ainda  constantemente atualizado, tem as manutenes devidas e  procurado pela comunidade. Portanto, a aplicao da minerao de repositrios representa um passo importante em direo a um desenvolvimento mais informado e eficaz, alinhado com as necessidades do mercado.",palavrasChave:["Minerao de repositrios","Frameworks","Bibliotecas","Cincia de dados","Tendncias de software","Anlise de ciclos de software","Correlao de dados","Anlise"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","ronaldo_gesse_2023.pdf")},{label:"Apresentao",url:p("apresentacao","ronaldo_gesse_apresentacao_2023.pdf")}]},{id:202323,titulo:"Estudo da eficcia de modelos de estimativa de irradiao solar na regio do centro de so paulo",autor:"Virgilio Santinho Tagliavini",orientador:"Prof. Assoc. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"A irradiao solar incidente na superfcie terrestre  uma varivel importante em diversas aplicaes cientficas e comerciais assim a capacidade de estimar e prever a irradiao solar global  necessria em diversos cenrios, por isso existem diversos modelos para a estimar mas nenhum modelo  efetivo para toda a superfcie terrestre. Assim, este trabalho tem como objetivo avaliar o desempenho de trs modelos numricos para estimar a irradiao solar diria para a regio do centro do estado de So Paulo. Para isso foram utilizados dados meteorolgicos de sete cidades do centro do estado de So Paulo disponibilizados pelo INMET para executar e registrar os resultados dos modelos estudados, ento seus resultados foram comparados com os dados reais registrados utilizando medidas estatsticas e estocsticas. Os resultados inicialmente obtidos indicaram que apenas o modelo de Hargreaves e Samani  efetivo em estimar a irradiao solar incidente na regio porque os resultados dos demais modelos apresentaram baixos ndices de concordncia com os dados reais. Para aumentar a preciso dos modelos estudados foi adicionado um coeficiente de ajuste para cada cidade e modelo, isso resultou em estimativas adequadas em todos os modelos, com altos valores nas medidas de avaliao utilizadas, mas o modelo de Hargreaves e Samani permaneceu como o modelo de maior preciso para todas as cidades estudadas, com exceo de Barra Bonita onde  o segundo modelo mais preciso. Assim, estes modelos so apropriados para a estimativa da irradiao solar na regio do centro do estado de So Paulo.",palavrasChave:["Irradiao Solar","Modelos Numricos","Estimativa","Centro de So Paulo","Avaliao de Desempenho"],dataDefesa:"2023-11",links:[{label:"Monografia",url:p("monografia","virgilio_tagliavini_2023.pdf")},{label:"Apresentao",url:p("apresentacao","virgilio_tagliavini_apresentacao_2023.pdf")}]},{id:202201,titulo:"Investigao de tcnicas de otimizao para algoritmos de aprendizagem de mquina",autor:"Andr Librio de Barros Ferraz",orientador:"Prof. Dr. Joo Paulo Papa",curso:"BCC",descricao:"Tendo em vista as inovaes tecnolgicas da ltima dcada, este trabalho busca, por meio de tcnicas como vetorizao utilizando AVX-512 e arcabouos computacionais para arquiteturas paralelas como o Galois, modificar algoritmos de aprendizado de mquina baseados em grafos, neste caso em particular, o OPF (OptimumPath Forest) com a finalidade de melhorar o seu tempo de execuo.Resultados apresentam ganhos significativos com o uso da tecnologia AVX-512, particularmente nas configuraes com 1 thread de at 26,84% se comparado a verso com uso de AVX2 e 112,83% se comparado a verso no vetorizada.Quanto ao Galois, fora realizado um estudo inicial que avaliou o desempenho do MST (Minimum Spanning Tree) e os resultados preliminares apontam um speedup de at 6x com o dataset Epinions. No futuro, esperase complementar a implementao do Galois para outros algoritmos de grafos baseados no OPF.",palavrasChave:["Computao de alto desempenho","Redes neurais","Informtica"],dataDefesa:"2022-07",links:[{label:"Monografia",url:p("monografia","andre_liborio_2022.pdf")},{label:"Apresentao",url:p("apresentacao","andre_liborio_apresentacao_2022.pdf")}]},{id:202202,titulo:"Sistema para gerenciamento de despensa com utilizao de data visualization",autor:"Karen Aya Murakawa",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"Com a gerao e o armazenamento de crescentes volumes de dados, tm-se destacado a aplicao de conceitos e tcnicas provenientes de diferentes reas do conhecimento com o propsito de auxiliar na anlise e na compreenso de tais elementos, os quais tm adquirido relevncia estratgica nos mais diversos contextos. Considerando-se o potencial da visualizao de dados no apoio  anlise e  transmisso de informaes de maneira precisa e simples, assim como os desafios existentes em relao  gesto de estoques de alimentos tanto nos ambientes residencial como corporativo, este trabalho teve como propsito o desenvolvimento de um prottipo de um aplicativo mvel voltado para o gerenciamento de despensas, com foco residencial, em que fosse possvel, atravs da consulta a representaes visuais dos dados, o acompanhamento e a avaliao de aes efetuadas com relao  aquisio, uso ou consumo, e descarte de alimentos, buscando-se subsidiar futuras tomadas de decises. Para o desenvolvimento do sistema, foram utilizadas como principais tecnologias, dentre outras, os frameworks Ionic e Angular, e a biblioteca Chart.js.",palavrasChave:["Gerenciamento de estoques de alimentos","Visualizao de dados","Aplicativo mvel"],dataDefesa:"2022-08-03",links:[{label:"Monografia",url:p("monografia","karen_aya_2022.pdf")},{label:"Apresentao",url:p("apresentacao","karen_aya_apresentacao_2022.pdf")}]},{id:202203,titulo:"Auxlio ao diagnstico de ela e avc atravs de expresso facial",autor:"Leonardo Silva de Oliveira",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"O presente trabalho foca em verificar a possibilidade do auxlio ao diagnstico de pessoas que possuem ou no doenas neurolgicas atravs do estudo das expresses faciais. O trabalho utiliza a ferramenta de extrao de Action Units (py-feat) para extrair informaes de alguns vdeos, para serem analisados onde nesses vdeos voluntrios realizaram algumas tarefas de fala ou movimento olhando para a cmera. Atravs desses actions units extrados, uma anlise exploratria foi feita dos dados extrados e alguns testes de predio de classificao de algoritmos especficos de aprendizado de mquina para classificar quais dos pacientes possuam ou no algum tipo de doena. Por fim, o trabalho apresenta a concluso com base nos resultados que apresentaram pontuaes altas para tarefas e algoritmos especficos e depois alguns possveis trabalhos futuros.",palavrasChave:["Aprendizado Artificial","Reconhecimento Facial","Diagnstico de doenas neurolgicas","Actions Units","Inteligncia Artificial","Cincia de Dados"],dataDefesa:"2022-07",links:[{label:"Monografia",url:p("monografia","leonardo_silva_2022.pdf")},{label:"Apresentao",url:p("apresentacao","leonardo_silva_apresentacao_2022.pdf")}]},{id:202204,titulo:"Resoluo do problema de escalonamento de enfermeiros em hospital utilizando simulated annealing",autor:"Lucas Henrique Russo do Nascimento",orientador:"Prof. Dr. Andra Carla Gonalves Vianna",curso:"BCC",descricao:"O Problema de Escalonamento de Enfermeiros se baseia em definir em quais dias e turnos cada enfermeiro trabalhar respeitando a demanda do hospital. Geralmente, nas instituies hospitalares, essa escala  definida manualmente por uma pessoa responsvel a cada ms. Como a quantidade de combinaes possveis  muito grande, encontrar uma escala adequada pode levar muito tempo, alm de demandar muita experincia da pessoa encarregada. Este trabalho prope a resoluo do problema utilizando a metaheurstica Simulated Annealing para determinar uma soluo do Problema de Escalonamento de Enfermeiros. Os resultados so apresentados de forma a avaliar a qualidade da soluo obtida. Foram feitos diversos testes computacionais comprovando a viabilidade da metaheurstica proposta.",palavrasChave:["Problema de Escalonamento de Enfermeiros","Metaheursticas","Simulated Annealing","Otimizao Matemtica"],dataDefesa:"2022-08",links:[{label:"Monografia",url:p("monografia","lucas_henrique_2022.pdf")},{label:"Apresentao",url:p("apresentacao","lucas_henrique_apresentacao_2022.pdf")}]},{id:202205,titulo:"Deteco de esteganografia em imagens utilizando aprendizado de mquina",autor:"Matheus Esquinelato Polachini",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Esteganografia em imagens se refere ao processo de incorporao de uma mesagem secreta em um arquivo de imagem sem causar mudana visual perceptvel a quem tenha acesso a essa imagem. Devido ao contnuo desenolvimento de novas tcnicas de esteganografia, h a necessidade de desenvolvimento de novas formas de deteco dessas tcnicas. Este trabalho buscou investigar a eficincia do uso de aprendizado de mquina na deteco das tcnicas de esteganografia LSB, PVD e JSteg em imagens utilizando a tcnica de aprendizado de mquina Support Vector Machine e caractersticas por mtricas de qualidade da imagem.",palavrasChave:["Esteganografia","Aprendizado de Mquina","Sistemas de Segurana","Support Vector Machine"],dataDefesa:"2022-08-03",links:[{label:"Monografia",url:p("monografia","matheus_esquinelato_2022.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_esquinelato_apresentacao_2022.pdf")}]},{id:202206,titulo:"Ferramenta de coleta e anlise de dados de licitaes pblicas",autor:"Matheus Yuichi Yamashiro",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"O mundo conectado atual vm causando grandes mudanas no dia-a-dia das pessoas. Uma delas  a quantidade de informaes consumidas e produzidas. Isso vm crescendo de maneira to alarmante que j no  mais possvel analisar essas informaes de maneira manual.  necessrio automatiz-las. Contudo, a maneira que as pessoas pensam e se comunicam, seja pessoalmente ou por meios informatizados (pela internet),  fundamentalmente diferente da maneira que os computadores o fazem. Assim,  necessrio gerar mtodos e interfaces para que os computadores, capazes de processar um volume de dados muito maior que os humanos, entendam e utilizem os dados gerados pelas pessoas. A rea de pesquisa de Processamento de Linguagem Natural (PLN)  justamente isso, desenvolver tcnicas para que os computadores processem dados textuais gerados por- humanos-para-humanos de maneira automtica. Neste trabalho, foi realizado um estudo sobre esta rea de pesquisa, algumas tcnicas implementadas e aplicadas em dados de licitaes pblicas da Prefeitura de Bauru, e desenvolvida uma interface web para a visualizao dos resultados obtidos.",palavrasChave:["Processamento de Linguagem Natural","Desenvolvimento web","Licitaes Pblicas"],dataDefesa:"2022-08",links:[{label:"Monografia",url:p("monografia","matheus_yuichi_2022.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_yuichi_apresentacao_2022.pdf")}]},{id:202207,titulo:"Criptowatcher: rob de investimento em criptomoedas utlizando algoritmo de arbitragem triangular",autor:"Maurcio Sugimoto Polloni",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"Por possurem alta volatilidade, criptomoedas, como Bitcoin, Ethereum, Dogecoin em um curto espao de tempo e em alta frequncia, tem expressiva variao de preos. O processo de negociaes, envolvendo o atos de compra ou venda destas criptomoedas, denominado trade, pode se mostrar ineficiente e inseguro se executado de forma manual. Neste cenrio, foi produzido um rob de investimentos para executar estas negociaes de forma automtica, ininterrupta e que conseguisse acompanhar a volatilidade das criptomoedas. Este rob foi desenvolvido utilizando a linguagem de programao Python e alocado na plataforma de computao em nuvem AWS. Nele foi implementado o algoritmo de arbitragem triangular, com objetivo de ganho tanto na alta, quanto na baixa. Como resultado foi feito um prottipo para monitorar os preos e executar aes de trade atravs da API da corretora de investimentos em criptomoedas Binance.",palavrasChave:["Criptomoedas","Algoritmo de Arbitragem","Arbitragem Triangular","Licitaes Pblicas"],dataDefesa:"2022-07",links:[{label:"Monografia",url:p("monografia","mauricio_sugimoto_2022.pdf")},{label:"Apresentao",url:p("apresentacao","mauricio_sugimoto_apresentacao_2022.pdf")}]},{id:202208,titulo:"Segurana em web3 : vulnerabilidades em carteiras digitais baseadas em navegadores",autor:"Caio Castilho Donato Regal",orientador:"Prof. Me. Luiz Felipe de Camargo",curso:"BCC",descricao:"A aplicao de carteira de criptomoedas mais utilizada da rede Ethereum, Metamask, possui uma brecha que pode ser manipulada para ter acesso no permitido a uma conta.  apresentada essa falha, assim como  feito uma apresentao sobre os processos envolvidos com a chave privada e a chave publica utilizadas pela Blockchain, como elas so geradas e armazenadas pela aplicao de navegadores Metamask, alm de expor mtodos de criptografia como a criptografia de curva elptica e a criptografia assimtrica. So propostas mudanas na aplicao para reparar esse problema de segurana, como o uso do endereo MAC do computador para ser usado na criptografia, apesar de conseguir fazer uma prova do conceito o resultado no  o suficiente para ser implementado na aplicao real.",palavrasChave:["Ethereum","Metamask","Navegadores","Sandbox","Segurana da informao","Criptografia","Criptografia de curva elptica"],dataDefesa:"2023-01-30",links:[{label:"Monografia",url:p("monografia","caio_castilho_2022.pdf")}]},{id:202209,titulo:"Mdulo de reconhecimento de gestos para ambientes de realidade aumentada",autor:"Davi Augusto Neves Leite",orientador:"Prof. Dr. Antonio Carlos Sementille",curso:"BCC",descricao:"A Realidade Aumentada pode ser definida como a rea responsvel por enriquecer o mundo real por meio da combinao de objetos gerados por computador. Por conta disso, a Realidade Aumentada possui grande potencial para ser aplicada nas mais diversas reas, como Educao, Medicina, Marketing e rea Industrial, uma vez que beneficia qualquer tarefa que necessite de acesso a uma informao que no teria normalmente. Contudo, a dificuldade na utilizao da interatividade natural nas solues recentes de Head-Mounted Displays voltadas para smartphones tem sido um dos principais obstculos para a acessibilidade e popularizao da Realidade Aumentada. Desta forma, era de interesse do projeto estruturar, implementar e avaliar um mdulo reconhecedor de gestos de mo para ambientes de Realidade Aumentada. Os experimentos propostos consistiam na realizao de aes diretas e indiretas do usurio, com relao aos objetos virtuais, em diferentes cenrios da Realidade Aumentada, baseados em tarefas. Os resultados obtidos mostraram a viabilidade do mdulo em aplicaes de Realidade Aumentada com o uso de Head-Mounted Displays Video See-Through baseados em smartphones para tarefas em que a preciso no  um requisito fundamental.",palavrasChave:["Realidade Aumentada","Interao por Gestos de Mo","Head-Mounted Displays","MediaPipe Hands","Vuforia"],dataDefesa:"2023-01-19",links:[{label:"Monografia",url:p("monografia","davi_augusto_2022.pdf")}]},{id:202210,titulo:"Aplicao de tcnicas de ensemble learning na deteco esttica e dinmica de malwares",autor:"Denis Henrique dos Santos",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Com o constante aumento do uso de tecnologia no dia a dia a importncia da segurana da informao cresce drasticamente, levando  existncia de malwares ser uma ameaa ao funcionamento de sistemas e dados importantes, requisitando formas de combat-los. Modelos de ensemble learning so modelos de aprendizado de mquina que utilizam vrios algoritmos para chegar a resultados de um determinado problema. Este trabalho prope um sistema de deteco de malware utilizando modelos ensemble learning dos tipos bagging, boosting e stacking, usando o conjunto de dados Malevis para anlise esttica e o conjunto de dados Top-1000 PE Imports para anlise dinmica. Os modelos foram treinados e os resultados foram comparados com outro sistema de deteco de malware. Os resultados obtidos foram satisfatrios, especialmente os da anlise dinmica, com modelos do tipo bagging e stacking mostrando maior desempenho em ambos os cenrios, enquanto que os modelos do tipo boosting apresentaram maior dificuldade em chegar a resultados mais eficazes com os conjuntos de dados usados.",palavrasChave:["Malware","Aprendizado de mquina","Ensemble learning"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","denis_henrique_2022.pdf")}]},{id:202211,titulo:"Jogo srio para simulao e conscientizao de problemas relacionados  mobilidade urbana",autor:"Eduardo Antonio Comero Stecca Almeida",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"Conforme a criao e o aperfeioamento de novas tecnologias, dispositivos mveis capazes de executar softwares que demandam muito poder computacional atingiram grande destaque na nossa sociedade, atuando hoje em reas fundamentais da nossa economia, como: transporte, alimentao e hospedagem. Pode-se, tambm, utilizar tais dispositivos para melhorar a qualidade de vida, a educao e o acesso  informao. Uma das maneiras de facilitar tais processos  a utilizao de jogos srios no compartilhamento de informaes sobre problemas de difcil compreenso. O trabalho aqui apresentado, trata-se de um jogo srio desenvolvido para simular e expor alguns dos muitos problemas de acessibilidade urbana. O jogo: WheelChair Simulator , utiliza ferramentas atuais de desenvolvimento de jogos multiplataformas, como tambm aplica conceitos de imerso, simulao e experincia do usurio. Voltado para adolescentes e jovens adultos que possuem acesso a um dispositivo mvel, com objetivo de melhorar a compreenso e a incluso social. Utilizando uma rea pouco explorada da Computao na divulgao de tais problemas e incentivar mais pesquisas nessa rea de estudo no ramo de tecnologia da informao.",palavrasChave:["Jogos Srios","Acessibilidade Urbana","Simulao, Dispositivos Mveis"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","eduardo_antonio_2022.pdf")}]},{id:202212,titulo:"Inteligncia artificial explicvel com lime e shap aplicada  rede neural convolucional",autor:"Fabricio Steinle Amoroso",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"Modelos de inteligncia artificial esto presentes na vida cotidiana nos mais diversos contextos, como sistemas mdicos para auxlio na deteco de doenas e motores de busca, estando, por vezes, presentes at de maneira transparente aos usurios como no caso de algoritmos de recomendao de produtos. Ao passo que a adoo de IA cresce, a complexidade dos sistemas de inteligncia artificial tambm aumenta, tornando mais desafiadora a tarefa de compreender como foi obtido determinado resultado. Refere-se a estes modelos complexos como caixa-preta, devido  sua dificuldade de interpretao. Inteligncia artificial explicvel pode ser utilizada para compreender como os modelos complexos, como redes neurais convolucionais, que so amplamente aplicados, chegam a seus resultados.  proposto neste projeto de concluso de curso, implementar tcnicas de inteligncia artificial explicvel utilizando duas das ferramentas mais populares neste contexto: LIME e SHAP, ambas aplicadas a um modelo de rede neural convolucional utilizado para classificar imagens de exames mdicos de escrita, pertencentes a um grupo de indivduos saudveis e outro grupo de pacientes de Parkinson. Atravs dos resultados obtidos foi possvel obter explicaes sobre o modelo descrito que podem ser interpretadas por seres humanos.",palavrasChave:["Inteligncia Artificial Explicvel","LIME","Parkinson","Rede Neural Convolucional","SHAP"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","fabricio_steinle_2022.pdf")}]},{id:202213,titulo:"Trabalhante : rede social para facilitar turnover em trabalhos rotativos",autor:"Felipe Kroitor Cara Modena",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"O turnover  uma medida usada para avaliar a rotatividade de funcionrios em uma empresa, ou seja, o nmero de funcionrios que deixam a empresa em um determinado perodo de tempo.  considerado um indicador importante da sade e da cultura organizacional de uma empresa, pois pode indicar problemas como falta de satisfao no trabalho, baixa remunerao ou falta de oportunidades de crescimento. A proposta apresentada  de desenvolver uma rede social, onde os usurios podem criar perfis, se conectar com outros profissionais e compartilhar suas experincias de trabalho. Os usurios tambm podem avaliar as empresas e funcionrios com os quais trabalharam, informando o nvel de satisfao no trabalho, a remunerao e o nvel de oportunidades de crescimento oferecidas. Com essas informaes, o software cria uma base de dados completa e atualizada sobre as empresas e funcionrios avaliados, permitindo que outros profissionais vejam as avaliaes e tomem decises informadas sobre suas carreiras. Alm disso, as empresas tambm podem acessar o software e ver as avaliaes de seus funcionrios, o que as ajuda a entender melhor os pontos fortes e fracos de sua cultura organizacional e a tomar medidas para melhorar a satisfao no trabalho de seus funcionrios.",palavrasChave:["rotatividade profissional","software","empresas","inteligncia de negcios","contratao","rede social","recomendao profissional","inovao"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","felipe_kroitor_2022.pdf")}]},{id:202214,titulo:"Software para gesto de inventrio de crdito de carbono visando a compensao da emisso de gases de efeito estufa",autor:"Gabriel Dadamos Rossetto",orientador:"Prof. Dr. Kleber Rocha de Oliveira",curso:"BCC",descricao:"A reduo das emisses de gases com efeito de estufa  fundamental na luta contra as alteraes climticas, uma vez que estas as emisses contribuem para o aquecimento global e tm uma srie de impactos negativos no meio ambiente e na sade humana. Os crditos de carbono so uma ferramenta importante para alcanar redues de emisses, pois fornecem um incentivo financeiro para que as empresas reduzam suas emisses, permitindo-lhes venderem crditos por cada tonelada de dixido de carbono que reduzem ou removem da atmosfera. Ao usar crditos de carbono para recompensar pelas redues de emisses, governos e empresas podem encorajar o desenvolvimento e implementao de tecnologias e prticas limpas, assim ajudando a reduzir o nvel geral de emisses de gases do efeito estufa. Este projeto de software visa ajudar as empresas a rastrear e controlar suas emisses de gases do efeito estufa, a fim de cumprir os requisitos regulamentares e reduzir o seu impacto ambiental. Usando o mtodo de linha de base, o software calcula o saldo de crditos de carbono aos quais uma empresa tem direito com base em suas redues de emisses. Alm disso, o software gera relatrios sobre o desempenho da empresa referente as emisses que podem ser submetidas aos rgos reguladores. Ao fornecer uma interface fcil de usar para o rastreamento e gerao de relatrios de emisses, este software visa facilitar com que empresas possam demonstrar seu compromisso com a sustentabilidade e cumprir suas metas de reduo de emisses.",palavrasChave:["Crdito de Carbono","Gas do Efeito Estufa","Aquecimento Global","Sustentabilidade"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","gabriel_dadamos_2022.pdf")}]},{id:202215,titulo:"Uso da computao grfica para ensino de astronomia: desenvolvimento de um software educacional utilizando unity",autor:"Gabriel Francisco Sahm Gallo",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"Com o passar do tempo, percebeu-se que os alunos esto cada vez mais tecnolgicos, porm o modo de ensinar e as ferramentas utilizadas pelos docentes no esto acompanhando essa mudana, principalmente na rea de Astronomia. Durante o ensino de Astronomia, alguns temas so explicados de modo que o aluno consiga entender, porm nos assuntos complexo, tais como a comparao de tamanho dos planetas no  possvel ter um total entendimento. Para resolver tal problema, este trabalho apresenta um software educativo que tem o objetivo de simular o Sistema Solar para auxiliar os docentes  explicarem e apresentarem conceitos de Astronomia, tais como as escalas, velocidades, movimentos e rbitas dos objetos celestiais.",palavrasChave:["Astronomia","Ensino","Softwares educativos","Simulador"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","gabriel_francisco_2022.pdf")}]},{id:202216,titulo:"Uma aplicao web para anlise comparativa de meta-heuristicas de otimizao",autor:"Giovani Candido",orientador:"Prof. Dr. Joo Paulo Papa",curso:"BCC",descricao:"Nas ltimas dcadas, a demanda por uma melhor administrao de recursos como tempo e dinheiro tem crescido na sociedade, fazendo com que problemas de otimizao sejam cada vez mais estudados por reas como pesquisa operacional e cincia da computao. No entanto, as tcnicas tradicionais de otimizao no so eficientes para lidar com os problemas desafiadores encontrados no mundo real. Nesse cenrio, as meta-heursticas se apresentam como uma alternativa interessante, uma vez que so capazes de encontrar solues satisfatrias para inmeros problemas. Logo, faz-se necessrio o desenvolvimento de uma ferramenta que traga as mais populares entre essas abundantes tcnicas, acompanhadas de distintos problemas artificiais de teste que traduzam suas performances, viabilizando a rpida realizao de anlises comparativas. Neste trabalho, estudou-se as meta-heursticas e as funes de teste mais empregadas na literatura, visando a criao de um ambiente web. Dentre as funcionalidades dessa aplicao, pode-se citar o ajuste de parmetros de execuo, a apresentao do progresso das tarefas em tempo real, a persistncia dos dados de execuo, a apresentao dos resultados juntamente com dados estatsticos e a produo de grficos de convergncia.",palavrasChave:["Aplicao Web","Anlise Comparativa","Meta-heursticas","Funes de Teste","Otimizao Matemtica"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","giovani_candido_2022.pdf")}]},{id:202217,titulo:"Aplicao de algoritmo gentico para roteirizao e carregamento de veculo",autor:"Giulia Rossatto Rocha",orientador:"Prof. Dr. Mrcia A Zanoli Meira e Silva",curso:"BCC",descricao:"A globalizao  responsvel pelo surgimento de um maior nmero de clientes exigentes quanto  prazos e qualidade de entrega de mercadorias. Nesse sentido, a capacidade em atender s necessidades dos clientes, com qualidade e com baixo custo despendido  uma urgncia no contexto de concorrncia entre empresas de transporte, distribuio e coleta. A logstica e a gesto apresentam-se como estratgias para realizar a organizao e planejamento dos recursos empresariais de forma a maximizar a execuo de pedidos. No entanto, no mbito da gesto de transportes h dificuldades no planejamento e roteirizao dos veculos envolvidos de modo a determinar o melhor percurso, com menor gasto de tempo e recursos operacionais. O presente trabalho teve por objetivo a construo de um software capaz de realizar a roteirizao de um veculo que percorra a menor distncia possvel entre as localidades pr-definidas por um usurio, considerando uma possvel limitao de carga do veculo e uma cidade inicial que servir como depsito. Foram utilizados Algoritmos Genticos que so meta-heursticas baseadas no conceito de evoluo dos seres vivos e no processo de seleo natural, visto que o Problema de Roteirizao de Veculos Capacitados (PRVC) e que o Problema do Caixeiro Viajante (PCV) so chamados de problemas NP-difcil e, portanto, no so capazes de gerar uma soluo tima em tempo computacional vivel com algoritmos polinomiais ou tcnicas tradicionais da pesquisa operacional. O software desenvolvido consiste em uma aplicao web, desenvolvida em Python, com a utilizao do micro framework Flask e do framework Bootstrap para estilizao das pginas. Finalmente, o algoritmo desenvolvido foi submetido a diversos testes, alterando alguns parmetros como o processo de seleo, cruzamento e mutao. Verificou-se que o algoritmo gentico se apresenta como uma tima alternativa para a soluo do problema, pois permite a utilizao de variedades de parmetros, apresentando timos resultados em um tempo positivo. Por fim, verificou-se que o operador de mutao SM no apresentou bons resultados para obteno da menor distncia possvel, enquanto os operadores que se destacaram foram os operadores de cruzamento OX e PMX e os operadores de mutao EM, SIM e DM, tanto em questo de tempo quanto em melhor soluo obtida.",palavrasChave:["Meta-heurstica","Algoritmo Gentico","Roteamento de veculos"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","giulia_rossatto_2022.pdf")}]},{id:202218,titulo:"Sistema de gerenciamento de uma fazenda",autor:"Guilherme Vieira Siena Martins",orientador:"Prof. Dr. Andra Carla Gonalves Vianna",curso:"BCC",descricao:"O agronegcio  um dos principais setores da economia brasileira, chegando a compor 27,4% do PIB nacional em 2021, porm mesmo com essa grande quantidade de dinheiro circulando muitas propriedades rurais esto atrasadas no requisito tecnolgico, sendo que 70% delas no possuem conexo com a internet. Mesmo com tamanha importncia, essas propriedades ainda so gerenciadas e tem seus processos feitos de maneira muito informal e isso acaba gerando problemas. Um termo que resume a necessidade de tecnologia no campo  agricultura 4.0, tambm conhecida como agricultura digital. Para resolver o problemas como esses foi modelado um banco de dados relacional, um modelo de otimizao para produo de rao englobados por uma interface grfica utilizando a linguagem python. Os conceitos utilizados no desenvolvimento do trabalho envolvem o processo de criao de um produto real com a possibilidade de ser comercializvel. A interface  simples facilitando o uso dos fazendeiros.",palavrasChave:["Agropecuria","Python","Tecnologia da Informao"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","guilherme_vieira_2022.pdf")}]},{id:202219,titulo:"Paralelizao da tcnica de extrao de pontos de interesse foagdd utilizando a arquitetura cuda",autor:"Gustavo Henrique Stahl",orientador:"Prof. Dr. Antonio Carlos Sementille",curso:"BCC",descricao:"Consoante com o desenvolvimento tecnolgico atual que, cada vez mais, solicita abordagens que conectem o meio analgico e digital de maneira interativa, ou seja, funcionando em tempo real, o presente trabalho busca auxiliar nesse cenrio ao acelerar uma das tcnicas de extrao de pontos de interesse em imagem presente no estado da arte da categoria, uma vez que so densamente utilizadas em reas como realidade aumentada, veculos autnomos, robs de servio, reconstruo 3D, e diversas outras que necessitam produzir resultados rpidos e frequentes. O mtodo escolhido para o aperfeioamento  o extrator de cantos FOAGDD (First-order Anisotropic Gaussian Direction Derivative) e seu processo de otimizao se sustentou na massiva paralelizao possibilitada pela arquitetura CUDA (Compute Unified Device Architecture) da NVIDIA. Os resultados obtidos com a melhoria proposta se mostraram promissores. Primeiramente, a sada produzida pela implementao original do mtodo e a paralelizada em CUDA se mostraram muito similares, aps serem testadas e comparadas em um conjunto de 28 imagens. Por ltimo, o cdigo proposto trouxe um Speed-up no tempo de execuo de aproximadamente 3190 (66,03 segundos  20,70 milisegundos) em relao  implementao original do FOAGDD, utilizando como base uma imagem padronizada de resoluo 512  512 pixels.",palavrasChave:["Computao de alto desempenho","NVIDIA CUDA","Extrator de pontos de interesse"],dataDefesa:"2023-01-24",links:[{label:"Monografia",url:p("monografia","gustavo_henrique_2022.pdf")}]},{id:202220,titulo:"Sobre deteco de intruso com aprendizado de mquina: estudo da aplicao de ensemble learning e clusterizao na melhoria de desempenho",autor:"Ina Soares de Figueiredo",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Sistemas de deteco de intruso em redes de computadores tm uma grande importncia na manuteno da segurana de uma rede e so foco constante de pesquisas que buscam aprimorar IDSs j existentes ou desenvolver novos ainda melhores. Este trabalho apresenta um estudo dos modelos de aprendizado de mquina autoencoder e Restricted Boltzmann Machine, comprovadamente efetivos na deteco de intruso. Os modelos so comparados e busca-se melhor-los por meio da aplicao de tcnicas de clusterizao e ensemble learning (majority-voting). As mtricas mostraram-se pouco afetadas pela aplicao das tcnicas de melhoria individualmente, mas bons resultados foram obtidos ao combin-las, alando 84,71% de acurcia e 91,31% F1-score no dataset KDD99.",palavrasChave:["Sistema de deteco de intruso","aprendizado de mquina","redes de computadores"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","inae_soares_2022.pdf")}]},{id:202221,titulo:"Desenvolvimento de um sistema de simulao computacional de ocorrncia de chuvas",autor:"Joo Pedro Olimpio",orientador:"Prof. Dr. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"O presente trabalho objetiva o desenvolvimento de um sistema de simulao computacional que seja capaz de representar o regime de chuvas para a cidade de Bauru, So Paulo. Para tanto, sero considerados dois aspectos do fenmeno precipitao: a possibilidade de sua ocorrncia em determinado dia e a probabilidade de acontecer em certa intensidade. A possibilidade de ocorrncia ser gerada a partir do uso do conceito de cadeia de Markov, que  uma sequncia finita de estados, na qual a transio a um estado presente apenas depende do estado que imediatamente o antecede. Neste trabalho, cada estado representa um dia do ano, que possui uma probabilidade de transio para o dia seguinte calculada com base no padro de chuvas dos dados analisados. J a intensidade de chuva ser determinada por uma distribuio de probabilidades em classes de magnitude, de forma que cada classe possua uma condio de entrada que, se satisfeita, ir determinar em qual faixa de magnitude a chuva do dia ocorrer. Os intervalos de tempo analisados, para gerar os valores de probabilidade, sero variados com o objetivo de validar a hiptese de que, ao se utilizar perodos menores, maior  a fidelidade do modelo de simulao ao sistema real e melhor  o resultado simulado, em termos de sua assertividade.",palavrasChave:["sistema de simulao","chuva","cadeia de Markov"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","joao_pedro_2022.pdf")}]},{id:202222,titulo:"Programao das bombas hidrulicas para otimizao energtica em sistemas de abastecimento de gua utilizando python e o software epanet",autor:"Larissa de Castro Bonadio",orientador:"Prof. Dr. Edilane Martins Soler",curso:"BCC",descricao:"A gua  um recurso natural e essencial que garante o bem-estar e sade da populao. Para a populao humana usufruir desse recurso  fundamental a utilizao dos sistemas de abastecimento de gua. Em diversas etapas de seu funcionamento a energia eltrica  usada, principalmente pelas bombas hidrulicas, as quais so empregadas para viabilizar a transferncia de gua de um ponto inferior para um superior, contudo esse processo apresenta um alto custo energtico. Neste contexto, para auxiliar o desenvolvimento do planejamento da operao das bombas hidrulicas, os modelos e mtodos de otimizao e simuladores hidrulicos so utilizados como ferramenta. Desse modo, esse trabalho desenvolveu um software, em linguagem de programao Python, que verifica a aplicabilidade da soluo obtida pelo modelo matemtico de otimizao energtica desenvolvido por Parras (2020), de forma a analisar a soluo proposta por ele, e simul-la no simulador hidrulico EPANET.",palavrasChave:["Otimizao","Sistema de Abastecimento de gua","EPANET","Python"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","larissa_bonadio_2022.pdf")}]},{id:202223,titulo:"Visualizao de dados e anlise do mercado de aes brasileiro",autor:"Luciano Eiji Tanaka",orientador:"Prof. Dr. Joo Pedro Albino",curso:"BCC",descricao:"O mercado de aes  uma das reas mais populares dentro do mercado financeiro, hoje em dia, atravs da popularizao da internet, da mdia e da democratizao da informao, tornou-se uma das formas mais comuns de obteno de renda alternativa. A previso do preo das aes sempre foi muito pesquisada, mas devido  sua natureza dinmica e voltil,  considerada uma das tarefas mais difceis no campo da matemtica e da cincia da computao. O mercado  afetado por vrios fatores macroeconmicos, como polticas governamentais, relaes internacionais, cenrio econmico, expectativas e psicologia dos investidores, etc. O presente trabalho busca combinar sistemas inteligentes para prever os preos finais das aes do ndice Bovespa, que so as mais consolidadas e negociadas no mercado. Conceitos sobre mercado financeiro, aprendizado de mquina e visualizao de dados sero estudados para dar suporte ao projeto. Foram propostos modelos para analisar e encontrar padres nos preos das aes, bem como indicar tendncias de longo prazo, e por fim a implementao do projeto para uso geral. Para as anlises foram utilizados os dados de janeiro de 2012 a julho de 2022, disponveis na seo de cotaes histricas diretamente do site da B3. O estudo foi desenvolvido utilizando redes neurais e uma mquina de vetores de suporte utilizando dados do preo de fechamento das aes negociadas na bolsa de valores.",palavrasChave:["Redes neurais","redes neurais artificiais","mquina de vetor de suporte","mercado de aes","LSTM","previso de valores","cincia de dados"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","luciano_eiji_2022.pdf")}]},{id:202224,titulo:"Sistema de reconhecimento biomtrico de mltiplas pessoas baseado em mtodos de estimao de pose e rastreamento de objetos",autor:"Lus Henrique Morlli",orientador:"Prof. Dr. Aparecido Nilceu Marana",curso:"BCC",descricao:"A biometria se tornou uma importante ferramenta para identificao de indivduos nas mais diversas reas, usada para evitar fraudes e aumentar a segurana dos cidados na sociedade. A marcha tem sido proposta como caracterstica biomtrica, visto que humanos possuem formas distintas de caminhar. Ela  particularmente importante para a identificao de pessoas  distncia. Na maioria das pesquisas encontradas na literatura, os mtodos de reconhecimento de marcha limitam-se a cenrios em que h apenas um indivduo caminhando, quando, em situaes mais realistas,  comum existirem vrias pessoas. Os mtodos atuais de reconhecimento de marcha no podem ser aplicados em cenrios multimarcha. Sendo um problema mais desafiador, para atingir tal objetivo, so necessrios mtodos de deteco e rastreamento de pessoas. O DeepSORT  um mtodo de rastreamento de mltiplos objetos que utiliza mtricas de associao profunda e vem obtendo bons resultados na tarefa. Este trabalho prope a construo de um sistema biomtrico capaz de identificar pessoas atravs de sua marcha e das medidas antropomtricas, empregando mtodos de estimao de poses e rastreamento e reidentificao de objetos. Para tal efeito, um mtodo de reconhecimento de mltiplas pessoas  proposto. O mtodo foi implementado e avaliado em duas bases de dados pblicas, a CASIA Gait Dataset-A e a SMVDU-Multi-Gait, alm de uma base de dados privada, coletada para validao do sistema biomtrico que foi construdo incorporando o mtodo proposto. Os resultados obtidos mostram que essa abordagem  adequada em cenrios de caminhada individual e em grupo, apresentando bom desempenho na identificao de indivduos e robustez para configurar como soluo de baixo oramento em sistemas visuais inteligente.",palavrasChave:["Biometria","Estimao de Poses","Rastreamento e Reidentificao de Objetos","Reconhecimento de Marcha","Medidas Antropomtricas"],dataDefesa:"2023-01-19",links:[{label:"Monografia",url:p("monografia","luis_henrique_2022.pdf")}]},{id:202225,titulo:"Uma aplicao web para anlise comparativa de seleo de caractersticas baseadas em meta-heuristicas",autor:"Luiz Fernando Merli de Oliveira Sementille",orientador:"Prof. Dr. Joo Paulo Papa",curso:"BCC",descricao:"Nos dias atuais,  notrio o crescimento da importncia que as tcnicas de aprendizado de mquina tm tido em virtude da massiva quantidade de dados presentes na Internet. Dentre as situaes em que o aprendizado de mquina pode ser empregado, pode-se citar a deteco de tumores em exames mdicos, a identificao de perfis de consumo e a deteco de intruses em redes de computadores. Diante desse contexto, uma das etapas mais importantes para que um sistema de aprendizado tenha desempenhos satisfatrios  a seleo de aractersticas. Esta etapa envolve aplicar algoritmos ao vetor de caractersticas, com a finalidade de encontrar um subconjunto deste vetor tal que aumente a acurcia na classificao e reduza a complexidade do modelo de aprendizado, podendo assim ser compreendida como um problema de otimizao NPDifcil. Deste modo, a utilizao de mtodos determinsticos no apresenta bom desempenho, tornando as meta-heursticas, tcnicas que se baseiam em comportamentos timos encontrados na natureza, excelentes candidatas para esse tipo de problema. Assim sendo, o presente projeto visa o desenvolvimento e implementao de uma aplicao web cujo objetivo  permitir a comparao de tarefas de seleo de caractersticas baseadas em tcnicas meta-heursticas.",palavrasChave:["Aplicao Web","Seleo de Caractersticas","Meta-Heurstica"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","luiz_fernando_2022.pdf")}]},{id:202226,titulo:"Anlise do crescimento da indstria dos jogos digitais",autor:"Michel Marques Mbakirtzis",orientador:"Prof. Dr. Joo Pedro Albino",curso:"BCC",descricao:"Este trabalho possui como objetivo entender o contexto que tem levado ao expressivo crescimento histrico da indstria de jogos digitais ao redor do mundo, partindo de pesquisas bibliogrficas sobre as caractersticas dessa indstria, este trabalho se prope a identificar elementos mercadolgicos, tecnolgicos, sociais e pandmicos que contriburam positivamente para o aumento do faturamento e crescimento da base de usurios. Aps realizada a abordagem das principais caractersticas do mercado de jogos, este trabalho apresenta um modelo de visualizao em Dashboard desenvolvido em Power BI, apresentando de modo dinmico e interativo o progresso dos nmeros obtidos pelo setor de jogos digitais desde seus primrdios.",palavrasChave:["Jogos Digitais","Dashboard","Power BI"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","michel_marques_2022.pdf")}]},{id:202227,titulo:"Organizador de rotinas dinmico",autor:"Rafael Kawagoe Gomes Muller",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"A Agenda  uma aplicao mobile que permite aos usurios gerenciar e organizar seus eventos e tarefas de maneira dinmica. Ela foi desenvolvida usando o Flutter, um popular framework de cdigo aberto para a criao de aplicativos mveis cross-platform. Para garantir a qualidade e a manuteno da base de cdigo, utilizou-se vrias tcnicas de engenharia de software, como boas prticas na nomenclatura de variveis, mtodos e classes, e a aplicao dos conceitos de SOLID. Essas prticas ajudaram a identificar e corrigir bugs, bem como evitar o surgimento de novos. O aplicativo de Agenda possui uma interface amigvel e intuitiva ao usurio. Ele foi desenvolvido para ser usado em dispositivos Android. No geral, o desenvolvimento do aplicativo de agenda usando Flutter e tcnicas de engenharia de software resultou em uma ferramenta confivel e eficaz para gerenciar tarefas, e que foi feita em um projeto escalvel e de fcil manuteno.",palavrasChave:["Aplicativo Mobile","Engenharia de Software","Flutter","Clean Code","Clean Architecture"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","rafael_kawagoe_2022.pdf")}]},{id:202228,titulo:"Dashboard para anlise de dados climticos de bauru",autor:"Rafael Mendes Costa",orientador:"Prof. Dr. Joo Pedro Albino",curso:"BCC",descricao:"A energia eltrica pode ser comercializada pelo mercado livre ou pelo mercado regulado pelo governo, onde os consumidores no possuem a liberdade de escolha de fornecedor nem negociao. J no mercado livre consumidores e fornecedores de energia podem interagir atravs das comercializadoras para negociar energia eltrica. Isso acontece atravs da compra de energia do fornecedor pelo comercializador e a venda dessa energia para o consumidor. No Brasil a matriz energtica depende de 70% de energia gerada por hidreltricas e na regio de Bauru existe a hidreltrica de Iacanga. Sistemas para Anlise de Dados Climticos so importantes para a comercializao de energia e commodities no mercado. O painel de controle para anlise de dados em Bauru permite que o usurio tenha acesso aos dados climticos da regio de Bauru, dando mais segurana nas negociaes de energia gerada pela hidreltrica de Iacanga feitas pelos comercializadores de energia. A aplicao foi desenvolvida usando React, Javascript, Python e Pandas. Alm disso, o projeto foi desenvolvido seguindo tcnicas de boas prticas adotadas por cada um das linguagens e princpiosSOLID.",palavrasChave:["Previso de temperatura","Previso de chuva","Anlise de dados","Dashboard"],dataDefesa:"2023-01-17",links:[{label:"Monografia",url:p("monografia","rafael_mendes_2022.pdf")}]},{id:202229,titulo:"Caminho timo em malha dinmica bidimensional",autor:"Rafael Nunes Caseiro",orientador:"Prof.Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"Dado um meio fsico ou virtual, a busca por um caminho timo entre dois ou mais pontos  uma problemtica muito estudada na computao, possuindo uma srie de solues j validadas, como o algoritmo de Dijkstra e A. O problema  relevante para um vasto espectro de aplicaes, incluindo trfego de redes, planejamento robtico, simulaes e jogos de computador. No entanto, cada aplicao possui um conjunto de requisitos e restries particular, tornando necessria a adaptao de solues a cada caso especfico. No caso de malhas dinmicas bidimensionais o algoritmo A  comumente utilizado, fornecendo a soluo de forma gil e precisa, e sendo fcil de adaptar. Este trabalho traz uma anlise terica sobre o problema do caminho timo, partindo de uma perspectiva generalizada, a qual , ento, restringida a uma malha dinmica bidimensional, a ser percorrida por um agente virtual, utilizando o algoritmo A*.",palavrasChave:["Caminho timo","Malha dinmica","Dijkstra","A*"],dataDefesa:"2023-01-20",links:[{label:"Monografia",url:p("monografia","rafael_nunes_2022.pdf")}]},{id:202230,titulo:"Gamificao de exerccios fsicos com lousa inteligente",autor:"Rafael Ragozoni Conrado",orientador:"Prof. Me. Juliana da Costa Feitosa",curso:"BCC",descricao:"Realizar atividades fsicas so importantes para uma vida saudvel e equilibrada. Existem muitos exerccios fsicos elaborados de forma a estimular diferentes aspectos do corpo, como o sistema cardiovascular ou cada um dos tecidos musculares, a fim de buscar otimizar seus benefcios. Porm,  possvel observar certa resistncia a sua realizao rotineira tendo em vista sua natureza montona e repetitiva. Com o objetivo de superar essa barreira presente em diversas tarefas, pode-se recorrer a gamificao, que usa elementos tpicos de jogos, sobretudo digitais, para tornar mais interessante quaisquer atividades. Foram utilizados conceitos de gamificao aplicados no contexto de exerccio fsico para buscar estimular a realizao de atividade fsica entre adultos, e contribuir para a manuteno de uma vida ativa entre os usurios. Isso foi feito por meio de um software gamificado feito na plataforma Unity para ser usado na lousa inteligente Huawei IdeaHub que conta com um sistema operacional Windows e uma cmera. O software possui um menu com estatsticas, conquistas e exerccios com descrio da atividade. Com isso, o usurio realiza exerccios providenciados pelo software, visualizando informaes sobre a atividade e com a cmera do IdeaHub, capturando os movimentos para contar os exerccios.",palavrasChave:["Gamificao","Lousa Inteligente","Exerccios Fsicos"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","rafael_ragozoni_2022.pdf")}]},{id:202231,titulo:"Uma estratgia de futebol de robs baseada em aprendizado por reforo",autor:"Rodrigo Cesar Barboza Rossetti",orientador:"Prof. Dr. Ren Pegoraro",curso:"BCC",descricao:"O uso de tcnicas de aprendizado de mquina se popularizou muito nos ltimos anos com avanos em diversas reas como carros autnomos, gerao de imagens e texto. O futebol de robs, onde vrios agentes interagem,  um ambiente propcio para aplicao e verificao de tcnicas de aprendizado. Neste trabalho foi aplicado tcnicas de aprendizado por reforo para treinar uma estratgia de futebol de robs completamente autnoma para mitigar os problemas da estratgia baseada em autmatos finitos determinsticos. Para tal, o ambiente do futebol de robs do time Carrossel Caipira foi adaptado como um problema padronizado de aprendizado por reforo utilizando a biblioteca Gym e ento treinado com o algoritmo Soft Actor-Critic com implementao da biblioteca Stable Baselines 3, por ser ideal para problemas com espaos de ao contnuos. Inicialmente, o goleiro foi treinado junto ao volante e atacante da estratgia anterior para fins de testes antes de continuar o treinamento junto ao volante e atacante atuais ao se constatar que o ambiente estava funcionando e o goleiro aprendendo. As recompensas obtidas durante o treinamento foram salvas e analisadas graficamente junto ao comportamento dos jogadores observado durante o treinamento. Para o goleiro, ele aprendeu a defender o gol conforme o aprendizado progrediu, mas para o volante e atacante  necessrio mais tempo de treinamento para aprenderem bem suas posies. Tambm foi possvel observar a tendncia de posicionamento dos robs em certas posies do campo para maximizar suas recompensas. O trabalho foi desenvolvido com base nas regras da competio IEEE Very Small Size Soccer da qual participa a equipe Carrossel Caipira.",palavrasChave:["Aprendizado profundo","Aprendizado por reforo","Futebol de Robs"],dataDefesa:"2023-01-16",links:[{label:"Monografia",url:p("monografia","rodrigo_cesar_2022.pdf")}]},{id:202232,titulo:"Um sistema de telemetria com tecnologias gsm/gprs para a rea ambiental",autor:"Samuel Cabral",orientador:"Prof. Dr. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"O monitoramento ambiental remoto  importante sob o ponto de vista social, ecolgico e agrcola, pois oferece melhor visualizao do estado de um ambiente e, consequentemente, providencia o melhor controle dele. A fim de criar uma maneira de monitorar um parmetro fsico ambiental  distncia, mesmo sem rede Wi-Fi, este trabalho prope e detalha o desenvolvimento de um sistema de monitoramento ambiental remoto utilizando rede GSM e GPRS. Os dados de temperatura e umidade relativa do ar so lidos atravs de sensores, verificados e analisados pela placa Arduino UNO, e transmitidos para um servidor na web atravs de rede GPRS, podendo ser exibidos e analisados atravs de um front-end composto de pginas na web. O sistema utiliza um servio de hospedagem na web para armazenamento dos arquivos das pginas, scripts e sistema de gerenciamento de banco de dados. Alm da transmisso de dados atravs da Internet, caso os valores das medies fsicas ultrapassem limites definidos, o usurio  automaticamente notificado atravs de mensagens alerta de SMS em seu telefone, utilizando a tecnologia de rede GSM.",palavrasChave:["Internet das Coisas","Arduino","Redes de dados","Sensores"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","samuel_cabral_2022.pdf")}]},{id:202233,titulo:"Acessibilidade web: metodologia de diagnstico e implementao de sites acessveis",autor:"Sarah Rodrigues Campos",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"A medida de isolamento social adotada por vrios pases como forma de conteno do coronavrus implicou diretamente no aumento de usurios da internet. Para muitas pessoas, o uso dessa ferramenta se tornou imprescindvel para trabalhos, estudos e at mesmo para socializao. Levando-se em conta que cerca de 24% da populao brasileira possui algum tipo de deficincia,  necessrio garantir que informaes por meio da web sejam o mais abrangente possvel. Para isso, esta pesquisa prope a criao de um guia simplificado sobre acessibilidade na internet para auxiliar desenvolvedores e designers a criar aplicaes web inclusivas. Aps um levantamento bibliogrfico, foram feitas adaptaes em um site da UNESP, validadas por meio de testes com pessoas portadoras de diferentes deficincias. O guia foi construdo a partir da anlise destes dados e do levantamento bibliogrfico.",palavrasChave:["acessibilidade","web","manual","desenvolvimento","design"],dataDefesa:"2023-01-18",links:[{label:"Monografia",url:p("monografia","sarah_rodrigues_2022.pdf")}]},{id:202234,titulo:"Smart campus: um estudo sobre viso computacional para deteco de pessoas em filas",autor:"Thiago Esteves La Scala",orientador:"Prof. Me. Luiz Felipe de Camargo",curso:"BCC",descricao:"Considerando as previses futuras para a rea de Internet das Coisas e as facilidades geradas por aplicaes de viso computacional utilizando aprendizado de mquina, este trabalho visa a deteco de pessoas em imagens usando o modelo de aprendizado de mquina para deteco de objetos YOLO. Para os testes foram utilizadas modificaes do conjunto de dados COCO, composto por diversos tipos de imagens rotuladas, e foram obtidos resultados promissores demonstrados atravs das mtricas ndice mAP que alcanou 98,8% e pontuao F1 que alcanou 97%. Os testes desenvolvidos permitiram a anlise da aplicabilidade do modelo para a deteco de pessoas, visando o futuro esenvolvimento de uma aplicao para acompanhamento de filas em um Smart Campus.",palavrasChave:["Internet das Coisas","Viso Computacional","Aprendizado de Mquina","Deteco de Pessoas"],dataDefesa:"2023-01-18",links:[{label:"Monografia",url:p("monografia","thiago_esteves_2022.pdf")}]},{id:202235,titulo:"Deteco de pginas de phishing utilizando aprendizado de mquina",autor:"Vinicius Machado Coutinho",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Com o avano da Internet e o aumento de servios digitais, tentativas de fraudes online, como o phishing, se tornaram um problema cada vez maior. Devido ao contnuo aumento e evoluo desses ataques, h a necessidade do desenvolvimento e aprimoramento de mtodos para deteco deles. Neste trabalho, foi criado um sistema de deteco de pginas de phishing, utilizando tcnicas de aprendizado de mquina como rvore de Deciso, Floresta Aleatria, rvores Extremamente Aleatrias e XGBoost. Os modelos foram desenvolvidos com um conjunto de dados de 88.647 entradas e mediu-se suas efetividades atravs de mtricas j estabelecidas na rea de aprendizado de mquina. Os resultados obtidos foram promissores, com o modelo XGBoost apresentando o melhor resultado, mostrando-se eficaz para a deteco de pginas da internet falsas.",palavrasChave:["Aprendizado de mquinas","Inteligncia Artificial","Fraude na Internet","rvores de Deciso"],dataDefesa:"2023-01",links:[{label:"Monografia",url:p("monografia","vinicius_machado_2022.pdf")}]},{id:202236,titulo:"Tcnicas de inteligncia artificial para diagnstico de acidente vascular cerebral atravs de imagens e dados textuais sobre possveis vtimas",autor:"Vinicius de Paula Pilan",orientador:"Prof. Dr. Clayton Reginaldo Pereira",curso:"BCC",descricao:"O Acidente Vascular Cerebral (AVC)  uma das doenas que mais matam e incapacitam no mundo todo e quanto mais tardio  o seu diagnstico, maiores podem ser os prejuzos para a vtima. Portanto, formas de agilizar e auxiliar o processo de diagnstico da doena podem ser bastante relevantes e benficas. Este trabalho abordou essa questo, aplicando tcnicas de Aprendizado de Mquina e Aprendizagem Profunda, sendo ambas subreas da Inteligncia Artificial, a qual vem sendo amplamente aplicada em diversos segmentos na busca de otimizar tarefas, principalmente no diagnstico de doenas. Modelos classificadores de fatores de risco foram criados a partir da aplicao dos modelos de Regresso Logstica e Floresta Aleatria, assim como uma Rede Neural Convolucional (CNN) para classificao de imagens de tomografia computadorizada da regio cerebral.",palavrasChave:["Inteligncia Artificial","Acidente Vascular Cerebral","Aprendizado de Mquina","Aprendizagem Profunda","Rede Neural Convolucional"],dataDefesa:"2023-01-27",links:[{label:"Monografia",url:p("monografia","vinicius_pilan_2022.pdf")}]},{id:202401,titulo:"Em busca da aplicao de protocolos de roteamento para evitar ataques do tipo buraco negro",autor:"Alex Luiz Domingues Cassinelli",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:`O Ataque Buraco Negro  um tipo de ataque ciberntico que ocorre em uma Rede Mvel Ad hoc (MANET),
    onde um n malicioso se comporta de forma cooperativa durante o processo de descoberta de rotas, mas descarta
    silenciosamente todos os pacotes de dados recebidos. Este trabalho investiga a implementao de protocolos de
    roteamento seguros para mitigar esse tipo de ataque em redes MANETs.`,palavrasChave:["Ataques Buraco Negro","Redes Mveis Ad hoc","Algoritmo de roteamento","Busca em Profundidade"," Mltiplos Caminhos"],dataDefesa:"2024-11-19",links:[{label:"Monografia",url:p("monografia","alex_cassinelli_2024.pdf")},{label:"Apresentao",url:p("apresentacao","alex_cassinelli_apresentacao_2024.pdf")}]},{id:202402,titulo:"Software Interpretador de Demonstraes Financeiras (IDF)",autor:"Anselmo Ruiz Lopes",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"O presente trabalho visa ao desenvolvimento de um software para automao da interpretao de demonstraes financeiras, denominado IDF (Interpretador de Demonstraes Financeiras). O objetivo  facilitar a anlise financeira, calculando e interpretando automaticamente ndices de liquidez, estrutura de capital e rentabilidade, essenciais para a avaliao econmica das empresas. Utilizando uma abordagem modular e a linguagem Python com bibliotecas especficas como Pandas e ReportLab, o sistema processa dados extrados de planilhas financeiras, gerando relatrios detalhados. O estudo exploratrio se apoiou em reviso bibliogrfica e experimentao com dados reais, comparando os resultados do sistema com anlises manuais para validar a preciso e consistncia do software. Os resultados indicam que o IDF pode otimizar o tempo de anlise e fornecer interpretaes padronizadas e confiveis, beneficiando profissionais da rea financeira na tomada de decises estratgicas. O trabalho conclui que a automao da anlise financeira  uma ferramenta valiosa para a modernizao da contabilidade e pode ser expandida para outras reas financeiras.",palavrasChave:["contabilidade","anlise financeira","automatizao","ndices financeiros"],dataDefesa:"2024-11",links:[{label:"Monografia",url:p("monografia","anselmo_lopes_2024.pdf")},{label:"Apresentao",url:p("apresentacao","anselmo_lopes_apresentacao_2024.pdf")}]},{id:202403,titulo:"Inteligncia Artificial versus Aprendizado de Mquina: Anlise em um jogo desenvolvido em Unity",autor:"Eric Trofino",orientador:"Prof. Dr. Juliana da Costa Feitosa",curso:"BCC",descricao:"Este trabalho compara tcnicas de Inteligncia Artificial (IA) e Machine Learning (ML) aplicadas ao desenvolvimento de personagens no-jogveis (NPCs, do ingls Non-Playable Characters) em jogos eletrnicos, focando no uso do aprendizado por reforo para treinar um agente em um ambiente simulado criado no Unity. Foi implementado um jogo em que o jogador controla um caador tentando capturar um cervo, sendo este ltimo controlado por um agente com IA tradicional ou treinado por ML. O estudo utiliza mtricas de desempenho, como taxa de fuga, tempo de captura e distncia mdia entre os dois, para avaliar a eficcia dos dois agentes. Os resultados mostraram que o agente treinado por ML apresentou melhor desempenho, fugindo por mais tempo do caador e ocasionalmente aplicando estratgias de fuga inesperadas. A pesquisa contribui para o avano no desenvolvimento de jogos ao explorar como o ML pode gerar comportamentos mais dinmicos e imersivos para NPCs, possibilitando novas abordagens para desafios e interaes em jogos eletrnicos.",palavrasChave:["Machine Learning","Inteligncia Artificial","Desenvolvimento de Jogos","Jogos Digitais"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","eric_trofino_2024.pdf")},{label:"Apresentao",url:p("apresentacao","eric_trofino_apresentacao_2024.pdf")}]},{id:202404,titulo:"Implementao de um sistema de captura de movimentos de sinais de libras para animao de avatares 3D",autor:"Gabriel Junqueira do Val",orientador:"Prof. Assoc. Antnio Carlos Sementille",curso:"BCC",descricao:"Este trabalho prope um sistema que captura e redireciona os movimentos da Lngua Brasileira de Sinais (LIBRAS) para animar avatares 3D, usando ferramentas de inteligncia artificial e viso computacional. A captura dos gestos  realizada com o MediaPipe, que identifica e rastreia pontos-chave do corpo em vdeos de sinais de LIBRAS. Esses dados, uma vez extrados, so processados pelo motor Unity3D, que anima avatares com base nas informaes de movimento obtidas. O sistema segue um pipeline estruturado, que abrange desde o processamento inicial dos vdeos at a animao final dos avatares. Durante esse fluxo, os landmarks corporais so mapeados e aplicados a um esqueleto virtual. Que  renderizado pelo motor de jogos Unity3D e replica os movimentos como apresentados no dataset.",palavrasChave:["LIBRAS","MediaPipe","Animao 3D","Avatares Virtuais","Unity3D"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","gabriel_junqueira_2024.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_junqueira_apresentacao_2024.pdf")}]},{id:202405,titulo:"Predio de tendncias no mercado americano com Random Forest",autor:"Gabriel Zanforlin Parizotto",orientador:"Prof. Dr. Simone das Graas Domingues Prado",curso:"BCC",descricao:"Este estudo explora a aplicao de tcnicas avanadas de inteligncia artificial no contexto da anlise e predio de movimentos no mercado financeiro, com nfase na implementao de modelos de aprendizado de mquina para aprimorar a tomada de decises de investimento. Dentre as abordagens desenvolvidas, destaca-se o modelo Random Forest, estruturado como um ensemble de mltiplas rvores de deciso para combinar de forma eficaz dados provenientes de indicadores financeiros amplamente utilizados. Tal abordagem visa  identificao precisa de sinais de compra e venda, capturando padres complexos presentes nos ativos analisados. A anlise de sries temporais foi aplicada em ativos selecionados do mercado financeiro americano, utilizando dados histricos para avaliar a capacidade preditiva do modelo, bem como sua eficcia na mitigao de riscos inerentes  volatilidade dos mercados. O processo de desenvolvimento incluiu tcnicas de validao cruzada e tratamento dos dados, com o objetivo de maximizar o desempenho do modelo, reduzindo o sobreajuste e aprimorando sua generalizao. Ademais, foi desenvolvida uma soluo web que abrange tanto o treinamento de modelos quanto a visualizao das oportunidades de compra e venda no mercado americano, permitindo ao usurio buscar aes especficas e obter resultados do modelo em tempo real, bem como se inscrever para receber notificaes automticas sempre que surgirem oportunidades de compra ou venda. Como resultado, este trabalho apresenta uma aplicao automatizada e de alta confiabilidade que sugere oportunidades de investimento, evidenciando o potencial da inteligncia artificial na anlise preditiva do mercado financeiro.",palavrasChave:["Inteligncia Artificial","Aprendizado de Mquina","Floresta Aleatria","Indicadores Financeiros"," Mercado Financeiro Americano"],dataDefesa:"2024-11-11",links:[{label:"Monografia",url:p("monografia","gabriel_parizotto_2024.pdf")},{label:"Apresentao",url:p("apresentacao","gabriel_parizotto_apresentacao_2024.pdf")}]},{id:202406,titulo:"Sistema de recomendao de filmes baseado em filtragem",autor:"Guilherme Souza Mingroni",orientador:"Prof. Dr. Leandro Aparecido Passos Junior",curso:"BCC",descricao:"Este trabalho aborda a evoluo e a relevncia dos sistemas de recomendao no contexto atual de consumo de mdia, especialmente em plataformas de streaming. Com o advento da inteligncia artificial e do aprendizado de mquina, os sistemas de recomendao se tornaram essenciais para personalizar a experincia do usurio, mas ainda enfrentam desafios como o filtro bolha e a diversidade nas sugestes. O sistema proposto, chamado FilmMatch, busca superar essas limitaes por meio da utilizao de mltiplas mtricas de similaridade, incluindo Similaridade Cosseno, Correlao de Pearson e ndice de Jaccard. A pesquisa se prope a desenvolver e avaliar um sistema de recomendao de filmes eficaz, analisando a eficcia das mtricas e comparando seu desempenho com outros sistemas existentes. Os resultados indicam que, embora a preciso do sistema esteja dentro da mdia, o recall  uma rea crtica que precisa de melhorias. Este trabalho contribui para a discusso sobre a importncia de recomendaes diversificadas e personalizadas no setor de entretenimento.",palavrasChave:["Sistemas de Recomendao","Consumo de Mdia","Plataformas de Streaming"," Mtricas de similaridade"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","guilherme_mingroni_2024.pdf")},{label:"Apresentao",url:p("apresentacao","guilherme_mingroni_apresentacao_2024.pdf")}]},{id:202407,titulo:"Aprendizado de mquina para deteco de ransomware",autor:"Ian Marques Breda",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa.",curso:"BCC",descricao:"Este trabalho apresenta o desenvolvimento de um prottipo de ransomware, seguido pela criao e aplicao de um modelo de aprendizado de mquina baseado em Floresta Aleatria para a deteco de ransomwares. O prottipo visa simular o comportamento malicioso do ransomware, enquanto o modelo de deteco  treinado para identificar padres associados a atividades de ransomware, permitindo uma abordagem preventiva eficaz. Os resultados obtidos demonstram a capacidade do modelo de Floresta Aleatria em detectar ataques com alta acurcia, contribuindo para o fortalecimento das defesas cibernticas.",palavrasChave:["Ransomware","Aprendizado de mquina","Floresta aleatria","Prottipo","Modelo","Defesas cibernticas"],dataDefesa:"2024-11-20",links:[{label:"Monografia",url:p("monografia","ian_breda_2024.pdf")},{label:"Apresentao",url:p("apresentacao","ian_breda_apresentacao_2024.pdf")}]},{id:202408,titulo:"Desenvolvimento de algoritmos de aprendizado de mquina para anlise e previso de ativos financeiros",autor:"Joo Henrique Mouro Suaiden",orientador:"Prof. Dr. Douglas Rodrigues",curso:"BCC",descricao:"Este trabalho tem como objetivo explorar o uso de algoritmos de aprendizado de mquina na anlise e previso de preos de ativos financeiros, contribuindo para estratgias de tomada de deciso mais precisas no mercado financeiro. A metodologia aplicada inclui a utilizao do algoritmo XGBoost, alm de indicadores financeiros tcnicos como o RSI (Relative Strength Index) e MACD (Moving Average Convergence Divergence) que auxiliam na identificao de tendncias e padres de preos. Os resultados obtidos indicam que o XGBoost, em combinao com os indicadores financeiros, apresenta um desempenho promissor, com capacidade de prever movimentos de mercado em cenrios de alta volatilidade e em diferentes intervalos de tempo. A avaliao de desempenho foi realizada com base em mtricas como a Acurcia e o F1-Score, permitindo uma anlise robusta da eficcia do modelo. Tambm foram feitas simulaes de investimento, utilizando o modelo proposto, a fim de se observar o seu comportamento no mercado real.",palavrasChave:["XGBoost","aprendizado de mquina","indicadores financeiros","mercado financeiro"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","joao_henrique_suaiden_2024.pdf")},{label:"Apresentao",url:p("apresentacao","joao_henrique_suaiden_apresentacao_2024.pdf")}]},{id:202409,titulo:"Uso de Realidade Virtual para estudos odontolgicos",autor:"Joo Pedro de Freitas Zanqui",orientador:"Prof. Dr. Juliana da Costa Feitosa",curso:"BCC",descricao:"O uso de Realidade Virtual (RV) para a rea da sade pode superar limitaes do ensino pr-clnico tradicional, como a escassez de materiais para estudo e a falta de realismo em modelos fsicos, oferecendo uma alternativa eficaz e acessvel para o aprendizado na odontologia. Com o avano contnuo das tecnologias educacionais, a RV tem emergido como uma ferramenta promissora para aprimorar o ensino em diversas reas, incluindo a odontologia. Este trabalho apresenta o desenvolvimento de uma aplicao de RV destinada a auxiliar estudantes de odontologia em seu processo de aprendizagem. Utilizando a plataforma Unity e a API Google Cardboard XR, foi criada uma aplicao para dispositivos Android que, em conjunto com um culos de RV, proporciona um ambiente imersivo e interativo. A aplicao  estruturada em mdulos de interface, visualizao, ambientao e manipulao de objetos, permitindo que os alunos naveguem por diferentes cenrios, interajam com modelos tridimensionais de estruturas odontolgicas e aprofundem seus conhecimentos de forma autnoma e envolvente. A implementao priorizou funcionalidades intuitivas e a reutilizao de modelos 3D disponveis, focando na criao de uma experincia imersiva.",palavrasChave:["Odontologia","Realidade Virtual"," Imerso"," Unity","Educao"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","joao_pedro_zanqui_2024.pdf")},{label:"Apresentao",url:p("apresentacao","joao_pedro_zanqui_apresentacao_2024.pdf")}]},{id:202410,titulo:"Inteligncia Artificial para auxlio no diagnstico de infeces fungicas e neoplasias pulmonares em radiografias torcicas",autor:"Kaio Henrique Domeni de Paulo",orientador:"Prof. Assoc. Joo Paulo Papa",curso:"BCC",descricao:"A radiografia simples (RX) do trax representa na maioria das situaes o primeiro exame radiolgico na avaliao das doenas torcicas e pulmonares. Grande parte das doenas broncopulmonares se apresentam no RX como opacidades, como  o caso da tuberculose, infeces fngicas, doenas intersticiais pulmonares, cncer de pulmo e pneumonias virais. Tcnicas de aprendizado de mquina vm sendo aplicadas para auxiliar na deteco de alteraes nos exames de imagem, mas a falta de exames de RX anotados de pacientes com infeco fngica em bases de dados torna difcil a sua classificao. O objetivo desta pesquisa  testar e aprimorar Redes Neurais Convolucionais (CNN, do ingls convolutional neural network) para auxlio ao diagnstico de pacientes com infeces fngicas e neoplasia, utilizando uma base de dados anotada de exames de RX fornecidos pelo Hospital das Clnicas de Ribeiro Preto. Para tal, foram testados diferentes tcnicas de processamento de imagem e Ensemble com o intuito de maximizar a acurcia e evitar o overfitting do modelo, concluindo com o desenvolvimento de uma interface que simule uma ferramenta de auxlio computadorizado ao diagnstico (CAD, do ingls computed aided diagnosis).",palavrasChave:["Pneumonia Fngica","Neoplasia","Redes Neurais Convolucionais","Radiografias do Trax","CAD"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","kaio_henrique_domeni_2024.pdf")},{label:"Apresentao",url:p("apresentacao","kaio_henrique_domeni_apresentacao_2024.pdf")}]},{id:202411,titulo:"Minerao de repositrios par avaliar a influncia das mudanas de cdigo ao longo do tempo",autor:"Leonardo Scarmato J de Paula",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"Sempre em constante evoluo, a tecnologia demanda novas necessidades que auxiliem a avaliao de mtricas expostas em cdigos fonte, alm do surgimento de novos softwares, solues e funes que facilitem o desenvolvimento e anlises em si. Tendo essa anlise como base, surge a minerao de repositrios, uma tcnica de extrema valiosidade para a coleta de grandes quantidades de dados e informao a partir de um simples cdigo. Possibilitando fundamentar decises estratgicas, analises micro que aceleram a manuteno e diminui o retrabalho ou anlises macro com perspectivas abrangentes que podem direcionar o software e seu desenvolvimento. Este trabalho analisou cinco projetos Python de bibliotecas e frameworks que so amplamente conhecidos e utilizados, com o objetivo de relacionar as alteraes em determinados trechos do cdigo em diferentes faixas de tempo,  necessidade de manuteno dos componentes. As mtricas analisadas inclouiram o nmero de commits, data de criao e os issues reportados, possibilitando comparao dos dados extrados dos repositrios com o prprio GitHub do projeto, formando uma abordagem relevante ao direcionar desenvolvedores para prticas de manuteno que sejam mais eficientes e alinhadas com as necessidades do software.",palavrasChave:["Minerao de repositrios","bibliotecas","anlises","qualidade","software","cincia de dados"],dataDefesa:"2024-11-13",links:[{label:"Monografia",url:p("monografia","leonardo_scarmato_2024.pdf")},{label:"Apresentao",url:p("apresentacao","leonardo_scarmato_apresentacao_2024.pdf")}]},{id:202412,titulo:"Desenvolvimento de um sistema de simulao de gerao de energia elica e anlise de eficincia para a regio de Bauru/SP",autor:"Leonel Lorca Biolcati",orientador:"Prof. Assoc. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"A energia elica  um dos tipos de energia limpa que continuam a ser fortemente desenvolvidos e crescem no mercado energtico atual, porm um aspecto importante desta tecnologia  que sua instalao deve ser feita em locais apropriados para que os sistemas possam funcionar eficientemente. Para isso, neste trabalho foi desenvolvido um programa na plataforma Mathematical Laboratory, ou MATLAB, para simular a gerao de energia de uma turbina elica, com base em seus parmetros e dados meteorolgicos relevantes para um sistema ideal que ainda considera valores possveis do coeficiente de potncia da Lei de Betz. Os resultados permitem uma anlise da eficincia de um aerogerador dentro da regio dos dados usados, assim o estudo da capacidade e aplicao desta forma de gerao de energia pode ser mais facilmente explorado, considerado ou desconsiderado.",palavrasChave:["Turbina elica","potencial eltrico","simulao por computador e energia elica"],dataDefesa:"2024-11-11",links:[{label:"Monografia",url:p("monografia","leonel_biolcati_2024.pdf")},{label:"Apresentao",url:p("apresentacao","leonel_biolcati_apresentacao_2024.pdf")}]},{id:202413,titulo:"Anlise de mobilidade urbana utilizando dados de viagens de bicicleta",autor:"Luca Melo Munekata",orientador:"Prof. Dr. Higor Amario de Souza",curso:"BCC",descricao:"A mobilidade ativa tem ganho relevncia em discusses sobre o planejamento urbano, se mostrando um meio de transporte que traz benefcios para a qualidade de vida nas cidades. Nesse contexto, o presente trabalho tem como objetivo aplicar tcnicas de cincia de dados no desenvolvimento de uma ferramenta que permita a realizao de anlises estatsticas e geoespaciais sobre dados de ciclistas de um aplicativo rastreador de viagens na cidade de So Paulo. Visando a implementao de polticas pblicas, as anlises em questo envolvem a distribuio de viagens de ciclistas pela cidade, as caractersticas de viagens e ciclistas e a relao delas com a infraestrutura dedicada. A ferramenta foi desenvolvida utilizando linguagem Python, em notebooks Jupyter.",palavrasChave:["Cincia de dados","Mobilidade ativa","Ciclistas"," Infraestrutura cicloviria","Polticas pblicas"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","luca_munekata_2024.pdf")},{label:"Apresentao",url:p("apresentacao","luca_munekata_apresentacao_2024.pdf")}]},{id:202414,titulo:"Aplicao de tcnicas de aprendizado de mquina como estratgia operacional no mercado de capitais brasileiro",autor:"Lucas Yuki Nishimoto",orientador:"Prof. Dr. Mateus Roder",curso:"BCC",descricao:"Este trabalho investiga a aplicao de tcnicas de aprendizado de mquina para maximizar o retorno financeiro no mercado de capitais brasileiro, tilizando os algoritmos Random Forest, Support Vector Machine e XGBoost. O estudo visa construir e avaliar portflios de ativos com base em previses de movimentaes do mercado. Os dados histricos foram obtidos por meio do Yahoo Finance, e indicadores financeiros foram extrados para alimentar os modelos. A anlise compara o desempenho dos modelos em termos de retorno percentual e ndice de Sharpe no perodo de janeiro de 2022 a outubro de 2024. Os resultados revelam que os modelos de aprendizado de mquina ofereceram uma relao risco-retorno muito superior ao Ibovespa, mais estvel em casos como o RF, mas com destaque em retorno acumulado para o XGBoost, tambm com o maior ndice de Sharpe. Comparados ao Ibovespa, todos os modelos apresentaram retornos mais elevados e maior consistncia, o que aponta para o potencial do aprendizado de mquina em estratgias de investimento seguras e rentveis, uma vez que todos os modelos levaram a valores de retorno percentual acumulado de mais de 150% em pouco menos de trs anos.",palavrasChave:["ML","IA","mercado financeiro"," otimizao de portflio"," ndice de Sharpe","RF","SVM","XGBoost"],dataDefesa:"2024-11-12",links:[{label:"Monografia",url:p("monografia","lucas_nishimoto_2024.pdf")},{label:"Apresentao",url:p("apresentacao","lucas_nishimoto_apresentacao_2024.pdf")}]},{id:202415,titulo:"Ferramenta de deteco de phishing com Aprendizado de Mquina",autor:"Marina Rijo de Oliveira",orientador:"Prof. Dr. Kelton Augusto Pontara da Costa",curso:"BCC",descricao:"Com a popularizao da internet, crimes virtuais como o phishing esto se tornando cada vez mais comuns. Em funo disto, torna-se necessrio o desenvolvimento de mtodos de deteco simples para proteger a populao. Este trabalho prope a criao de uma aplicao simplificada para a deteco destes ataques, utilizando-se de modelos de aprendizado de mquina para validar os endereos web apresentados pelo usurio. Os modelos utilizados foram rvore de Deciso, Floresta Aleatria, rvores Extremamente Aleatrias, XGBoost, CatBoost e Regresso Logstica, orquestrados de forma a poupar poder computacional e minimizar o tempo de execuo.",palavrasChave:["Aprendizado de mquina","Crimes Virtuais","Inteligncia Artificial","rvore de Deciso","XGBoost"],dataDefesa:"2024-11",links:[{label:"Monografia",url:p("monografia","marina_rijo_2024.pdf")},{label:"Apresentao",url:p("apresentacao","marina_rijo_apresentacao_2024.pdf")}]},{id:202416,titulo:"Desenvolvimento de um sistema para apoio a pessoas com deficincia visual e auditiva",autor:"Matheus Herminio da Silva",orientador:"Prof. Assoc. Joo Eduardo Machado Perea Martins",curso:"BCC",descricao:"A tecnologia assistiva envolve ferramentas e solues voltadas para melhorar a qualidade de vida e promover a independncia de pessoas com deficincia, facilitando suas atividades dirias e promovendo sua incluso social. Este trabalho tem como objetivo aplicar esse conceito para criar um sistema assistivo destinado a pessoas surdocegas, visando facilitar a comunicao e o gerenciamento de tempo. O sistema  composto por dois aplicativos e um circuito com Arduino: o primeiro aplicativo permite configurar alarmes vibratrios, possibilitando que o usurio seja notificado sobre eventos por meio de vibraes no celular. J o segundo aplicativo  integrado ao Arduino e conecta-se a uma campainha domstica, enviando um alerta vibratrio sempre que algum toca a campainha. O sistema foi testado pelo desenvolvedor, demonstrando-se vivel, embora com sugestes de adaptaes para aumentar a acessibilidade. Este projeto prope ainda melhorias futuras, como a integrao com mais dispositivos IoT, ampliando a eficcia e usabilidade do sistema.",palavrasChave:["tecnologia assistiva","surdocegueira","Arduino"," alarmes vibratrios","incluso"],dataDefesa:"2024-11-13",links:[{label:"Monografia",url:p("monografia","matheus_herminio_2024.pdf")},{label:"Apresentao",url:p("apresentacao","matheus_herminio_apresentacao_2024.pdf")}]},{id:202417,titulo:"Desenvolvimento de sistemas de reconhecimento de sinais de alfabeto manual de Libras utilizando MediaPipe Hands e rede LSTM",autor:"Pedro Ferreira Caliman",orientador:"Prof. Assoc. Antnio Carlos Sementille",curso:"BCC",descricao:"A Lngua Brasileira de Sinais (Libras)  um idioma visual que, assim como muitas outras linguagens de sinais, ainda no possui uma infraestrutura suficientemente desenvolvida. Isso  algo que se torna ainda mais agravante quando considerada a sua importncia como meio de comunicao para a comunidade surda. Por muito tempo, a anlise dos sinais de Libras tem sido uma tarefa difcil para os computadores, em parte devido s dependncias espaciais-temporais envolvidas no reconhecimento de gestos que utilizam a movimentao das mos. Porm, os avanos recentes nas tecnologias de viso computacional e machine learning permitem cada vez mais a superao destes obstculos. Portanto, o objetivo deste trabalho consiste na implementao de um pipeline completo para o reconhecimento dos sinais do alfabeto manual de Libras, incluindo a coleta de fontes para a elaborao do conjunto de dados, a extrao dos pontos de referncia das mos, e o treinamento de uma Rede Long Short-Term Memory capaz de analisar os sinais individuais.",palavrasChave:["Lngua Brasileira de Sinais","Rede LSTM","Detecao de Pontos de Referncia","Reconhecimento de Linguagem de Sinais"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","pedro_caliman_2024.pdf")}]},{id:202418,titulo:"Aplicativo gamificado para aprendizagem de Kanji (ideogramas chineses)",autor:"Raul Alexandre Gonzalez Augusto",orientador:"Prof. Dr. Juliana da Costa Feitosa",curso:"BCC",descricao:"A maior dificuldade que um estudante de japons pode encontrar so os pouco mais de dois mil kanji (caracteres chineses) que ele precisar memorizar para ser alfabetizado no idioma. Cada caractere  uma representao abstrata de uma ideia ou de uma imagem que normalmente possui mais de uma leitura e mais de um significado, aumentando ainda mais a dificuldade. Por exemplo, o smbolo   um pictograma do sol, sendo mais utilizado com o significado de dia. Porm, ele pode tambm significar sol, Japo e ser usado como contador de dias. Alm disso, ele pode ser lido como hi,-bi,-ka, nichi e jitsu. Por esses motivos, a maior dificuldade na alfabetizao do japons so os kanji, o que leva muitos estudantes a desistirem de estudar o idioma ou a aprenderem apenas a falar, sem se preocupar com a leitura. Por conta disso, Heisig criou um mtodo para a aprendizagem de kanji que vai alm do mtodo tradicional de escrever e ler repetidamente at decorar. O mtodo de Heisig consiste em criar histrias com os componentes do kanji para formar uma imagem vvida do caractere na mente. Ademais, ele indica a utilizao de flashcards para a reviso. Diante disso, o presente trabalho visa apresentar um aplicativo Android desenvolvido com elementos de jogos, utilizando flashcards e seguindo o mtodo de Heisig com algumas alteraes para estudar e revisar os kanji.",palavrasChave:["Estudo de kanji","Mtodo de Heisig","Gamificao","Flashcards","Estudo de Japons","Android"],dataDefesa:"2024-11-14",links:[{label:"Monografia",url:p("monografia","raul_augusto_2024.pdf")},{label:"Apresentao",url:p("apresentacao","raul_augusto_apresentacao_2024.pdf")}]},{id:202419,titulo:"Identificao biomtrica de ces por meio do reconhecimento facial utilizando transformadores",autor:"Vinicius Rodrigues de S Fiedler Garcia",orientador:"Prof. Assoc. Aparecido Nilceu Marana",curso:"BCC",descricao:"Oreconhecimento biomtrico de ces, utilizando viso computacional e aprendizagem de mquina, apresenta-se como uma soluo atual e bastante relevante, tanto do ponto de vista social quanto econmico, em aplicaes como o cadastro e a identificao automtica desses animais para fins de gerenciamento e controle da populao canina, a localizao dos tutores dos animais perdidos e a preveno de fraudes nos atendimentos em clnicas veterinrias pblicas e privadas. Este trabalho prope uma abordagem para a identificao biomtrica automtica de ces que utiliza o modelo YOLOnadeteco automtica das cabeas dos ces, durante a etapa de segmentao das imagens digitais dos animais, e o modelo de transformador visual na etapa de extrao das caractersticas faciais dos ces. A abordagem proposta foi incorporada a um sistema biomtrico projetado e implementado neste trabalho para ser executado em um servidor, hospedado em um ambiente de nuvem, de forma integrada a um aplicativo mvel que visa facilitar a captura e o envio das imagens ao servidor diretamente pelo usurio.",palavrasChave:["Identificao Biomtrica de Ces","YOLO","Transformador Visual","Viso Computacional","Aprendizado Profundo"," Aplicao Mvel"],dataDefesa:"2024-11-13",links:[{label:"Monografia",url:p("monografia","vinicius_garcia_2024.pdf")},{label:"Apresentao",url:p("apresentacao","vinicius_garcia_apresentacao_2024.pdf")}]}];function zs(e){return e?parseInt(e.split("-")[0]):null}function Vd(){const e=As.map(a=>zs(a.dataDefesa)).filter(a=>a!==null);return Math.max(...e)}function Ho(e){return As.filter(a=>zs(a.dataDefesa)===e)}Ho(2025).length>0?Ho(2025):Ho(Vd());const Hd={name:"TccsList",components:{TccItem:Fd},props:{tccs:{type:Array,required:!0}},data(){return{openItems:[],searchTerm:"",anoAtual:2025}},computed:{anoExibicao(){return 2025},tccsFiltrados(){if(!this.searchTerm)return this.tccs.filter(a=>zs(a.dataDefesa)===2025);const e=this.searchTerm.toLowerCase().trim();return this.tccs.filter(a=>{const o=a.curso.toLowerCase()==="bcc"?"bcc bacharelado cincia computao":"bsi bacharelado sistemas informao";return a.titulo.toLowerCase().includes(e)||a.autor.toLowerCase().includes(e)||a.curso.toLowerCase().includes(e)||o.includes(e)||a.descricao.toLowerCase().includes(e)||a.palavrasChave&&a.palavrasChave.some(s=>s.toLowerCase().includes(e))})},totalTccs(){return this.tccs.length}},methods:{toggleItem(e){const a=this.openItems.indexOf(e);a>-1?this.openItems.splice(a,1):this.openItems.push(e)},clearSearch(){this.searchTerm=""},expandAll(){this.openItems=this.tccsFiltrados.map(e=>e.id)},collapseAll(){this.openItems=[]}}},Gd={class:"tccs-container"},Ud={class:"tccs-header"},$d={class:"search-container"},Kd={key:0,class:"year-info"},Jd={class:"tccs-list"},Wd={key:0,class:"no-results"},Xd={key:0,class:"tccs-footer"},Yd={class:"results-count"};function Qd(e,a,o,s,i,t){const r=co("TccItem");return ee(),se("div",Gd,[B("div",Ud,[B("h2",null,"Trabalhos Disponveis ("+le(t.tccsFiltrados.length)+")",1),B("div",$d,[Vi(B("input",{"onUpdate:modelValue":a[0]||(a[0]=n=>i.searchTerm=n),type:"text",placeholder:"Buscar por ttulo, autor, curso (BCC/BSI) ou palavra-chave...",class:"search-input"},null,512),[[Zn,i.searchTerm]]),i.searchTerm?(ee(),se("button",{key:0,onClick:a[1]||(a[1]=(...n)=>t.clearSearch&&t.clearSearch(...n)),class:"clear-search"},"")):Ze("",!0)]),i.searchTerm?Ze("",!0):(ee(),se("p",Kd,"Exibindo trabalhos de "+le(t.anoExibicao)+". Use a busca para ver trabalhos de outros anos.",1))]),B("div",Jd,[t.tccsFiltrados.length===0?(ee(),se("div",Wd,[...a[2]||(a[2]=[B("p",null,"Nenhum trabalho encontrado com os critrios de busca.",-1)])])):Ze("",!0),(ee(!0),se(xe,null,Yo(t.tccsFiltrados,n=>(ee(),_s(r,{key:n.id,tcc:n,"is-open":i.openItems.includes(n.id),onToggle:l=>t.toggleItem(n.id)},null,8,["tcc","is-open","onToggle"]))),128))]),t.tccsFiltrados.length>0?(ee(),se("div",Xd,[B("p",Yd," Exibindo "+le(t.tccsFiltrados.length)+" de "+le(t.totalTccs)+" trabalhos ",1)])):Ze("",!0)])}const Zd=$a(Hd,[["render",Qd],["__scopeId","data-v-2e7de66d"]]),el={name:"App",components:{Header:gd,TccsList:Zd},data(){return{allTccs:As}}};function al(e,a,o,s,i,t){const r=co("Header"),n=co("TccsList");return ee(),se("div",null,[re(r,{titulo:"TCCs do DCo",subtitulo:"Trabalhos de Concluso de Curso do Departamento de Computao - Unesp de Bauru (FC)"}),B("main",null,[re(n,{tccs:i.allTccs},null,8,["tccs"])])])}const ol=$a(el,[["render",al]]);od(ol).mount("#app");
